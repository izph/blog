(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{728:function(t,v,_){"use strict";_.r(v);var n=_(13),s=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"tcp3次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp3次握手"}},[t._v("#")]),t._v(" TCP3次握手")]),t._v(" "),_("p",[t._v("第一次握手：客户端给服务器发送一个 SYN 报文，服务端收到了。说明：客户端的发送能力、服务端的接收能力是正常的。")]),t._v(" "),_("p",[t._v("第二次握手：服务器收到 SYN 报文之后，返回一个 SYN+ACK 报文。说明：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 但是此时服务器并不能确认客户端的接收能力是否正常。")]),t._v(" "),_("p",[t._v("第三次握手：客户端收到 SYN+ACK 报文之后，再发送一个 ACK 报文。服务器收到 ACK 报文之后，三次握手建立完成。此时：客户端 和 服务端 都知道对方 接收、发送能力正常。")]),t._v(" "),_("p",[_("strong",[t._v("三次握手的作用：")]),t._v("\n1、确认双方的接受能力、发送能力是否正常。2、初始化一些（数据规则）序列号，为可靠传输做准备。")]),t._v(" "),_("p",[_("strong",[t._v("三次握手过程中可以携带数据吗？ 答案是可以的，一般是第三次握手就可以传输数据了")]),t._v("\n为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。")]),t._v(" "),_("h3",{attrs:{id:"tcp4次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp4次挥手"}},[t._v("#")]),t._v(" TCP4次挥手")]),t._v(" "),_("p",[t._v("第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端 处于 等待远程TCP的连接中断请求状态。")]),t._v(" "),_("p",[t._v("第二次握手：服务端收到 FIN 之后，把客户端的序列号值 + 1 作为 ACK 报文的序列号值发送。说明：服务端已经收到客户端的报文了，此时服务端处于 等待连接中断请求 状态。\n（此时服务器还在传输数据，还没传送完）")]),t._v(" "),_("p",[t._v("第三次挥手：服务端数据传输完毕，想断开连接了，发 FIN 报文给客户端，且指定一个序列号。\n此时服务端处于 等待TCP的连接中断请求的一个确认 状态")]),t._v(" "),_("p",[t._v("第四次挥手：客户端收到 FIN 之后，也会发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端  会等待一段时间。 如果过了这个时间没有再次收到 服务端报文，则表明服务端成功 接受 ACK 报文，关闭连接")]),t._v(" "),_("p",[t._v("为什么第4次挥手之后，客户端不直接关闭连接？\n要确保服务器是否已经收到了 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN报文之后，就知道之前的 报文丢失了，然后再次发送 ACK 报文。")])])}),[],!1,null,null,null);v.default=s.exports}}]);