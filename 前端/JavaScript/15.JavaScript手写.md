---
title: JavaScript手写（一）
date: 2022-01-25 20:53:16
permalink: /前端/JavaScript/JavaScript手写题1
categories:
  - 前端
  - JavaScript
tags:
  - 前端
  - JavaScript
---
## 1、实现一个深拷贝
浅拷贝可以使用 Object.assign 和展开运算符（...）来实现
深拷贝实现方式：手写、第三方库(loadsh)、JSON.parse(JSON.stringfy(data))

```javascript
const target = {
    a: 1,
    b: undefined,
    c: {
        child: 'child'
    },
    d: [2, 4, 6]
};
// 出现循环引用，爆栈问题，递归进入死循环导致栈内存溢出
target.target = target;
```
解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。
这个存储空间，需要可以存储key-value形式的数据，且key可以是一个引用类型，我们可以选择Map这种数据结构。

### 深拷贝的实现(简易版, 不考虑其他复杂情况~)

```javascript
function clone(target, map = new WeakMap()) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        if (map.get(target)) {
            return map.get(target);
        }
        map.set(target, cloneTarget);
        for (const key in target) {
            cloneTarget[key] = clone(target[key], map);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```

## 2、函数柯理化
```js
// 实现柯里化    fn是一个函数
    let curry = (fn) => {
      if (typeof fn !== 'function') {
        return;  //throw Error('No function provided')
      }
      return function curriedFn(...args) {
        if (args.length < fn.length) {
          return function (...nextArgs) {
            return curriedFn.apply(this, [...args, ...nextArgs]);
          }
        }
        return fn.apply(this, args)
      }
    }
    function multiFn1(a, b, c) {
      return a * b * c
    }
    function multiFn2(a, b, c) {
      return a + b + c
    }
    // 参数的长度是固定的
    var multi1 = curry(multiFn1);
    var multi2 = curry(multiFn2);
    console.log(multi1(2)(3)(4)); // multi1 就是curriedFn
    console.log(multi1(2, 3, 4))
    console.log(multi1(2)(3, 4))
    console.log(multi1(2, 3)(4))
    
    console.log(multi2(2)(3)(4)); // multi2 就是curryfn
    console.log(multi2(2, 3, 4))
    console.log(multi2(2)(3, 4))
    console.log(multi2(2, 3)(4))
```
## 3、数组扁平化
```js
// 数组扁平化
// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好 
function fun(array) {
  if (!Array.isArray(array)) return;
  let result = [];
  result = array.reduce(function (pre, cur) {
    // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中 
    return pre.concat(Array.isArray(cur) ? fun(cur) : cur);
  }, []);
  return result;
}

// 数组的扁平化    递归
function spinArr(arr) {
  // write code here
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      // res = res.concat(spinArr(arr[i]))
      res = res.push(...spinArr(arr[i]))
    } else {
      res.push(arr[i])
    }
  }
  return res;
}
let arr = [[1, 2, 3, 4, 5, 6], [18, 19, 20, 21, 22, 7], [17, 28, 29, 30, 23, 8], [16, 27, 26, 25, 24, 9], [15, 14, 13, 12, 11, 10]];
console.log(spinArr(arr))

// 数组的扁平化    递归
function flatten(arr) {
  while (arr.some(item => (Array.isArray(item)))) {
    arr = [].concat(...arr);
  }
  return arr;
}
```
## 4、数组去重

## 5、手写通用累加函数
### 了解前置知识
一般来说，在浏览器控制台打印一个函数，会调用该函数的toString方法，而函数的toString方法默认是以字符串的形式返回该函数
```js
function override() {
    function test(){
      const num = 1;
    }
    test.toString = function () {
        return "重写test的toString方法";
    }
    return test;
}
alert(override())
// 在浏览器中弹出 "重写test的toString方法"
```
### 核心代码实现
```js
function add(...addRest) {
    var args = [...addRest];
    function sum(...sumRest) {
        args.push(...sumRest);
        return sum;
    }
    sum.toString = function () {
        return args.reduce( (prev, curr) =>  prev + curr , 0);
    }
    return sum;
}
alert(add(1, 2, 3)(4, 5, 6)(7, 8, 9))
// 45
```
## 6、封装一个队列Queue
```js
/**
     * 请基于JS中Array对象的push/pop/shift/unshift，实现一个容量为N的整数队列Queue
     *
     *要求：
    * 1. 当队列容量满时，队列内元素的淘汰算法为“先进先出FIFO”
    * 2. 提供max()方法，获取队列中的最大的元素，要求时间复杂度为O(1)
    * 3. 实现队列的入列add、获取头部元素peek、出列remove方法等基本的队列操作
    *
    * @function Queue
    * @param  {number} N {容量}
*/
class Queue {
    constructor(N) {
        this.N = N || 0;  // 数组最大长度
        this.count = 0; // 数组元素个数
        this.arr = [];
    }
    max = function () {
        return Math.max(...this.arr);
    }
    add = function (value) {
        let len = this.arr.length;
        if (len == this.N) {
            this.arr.pop();
            this.count--
        }
        this.arr.unshift(value);
        this.count++
    }
    peek = function () {
        return this.arr[0];
    }
    remove = function () {
        this.count--;
        return this.arr.pop();
    }
}
let q1 = new Queue(3);
q1.add(1)
q1.add(2)
q1.add(3)
q1.add(4)
q1.max();
console.log(q1.max());
console.log(q1.peek());
console.log(q1.remove());
```