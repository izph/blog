---
title: JavaScript手写（一）
date: 2022-01-25 20:53:16
permalink: /前端/JavaScript/JavaScript手写题1
categories:
  - 前端
  - JavaScript
tags:
  - 前端
  - JavaScript
---
## 1、实现一个深拷贝
浅拷贝可以使用 Object.assign 和展开运算符（...）来实现
深拷贝实现方式：手写、第三方库(loadsh)、JSON.parse(JSON.stringfy(data))

```javascript
const target = {
    a: 1,
    b: undefined,
    c: {
        child: 'child'
    },
    d: [2, 4, 6]
};
// 出现循环引用，爆栈问题，递归进入死循环导致栈内存溢出
target.target = target;
```
解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。
这个存储空间，需要可以存储key-value形式的数据，且key可以是一个引用类型，我们可以选择Map这种数据结构。

### 深拷贝的实现(简易版, 不考虑其他复杂情况~)

```javascript
function clone(target, map = new WeakMap()) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        if (map.get(target)) {
            return map.get(target);
        }
        map.set(target, cloneTarget);
        for (const key in target) {
            cloneTarget[key] = clone(target[key], map);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```

## 2、函数柯理化
```js
// 实现柯里化    fn是一个函数
    let curry = (fn) => {
      if (typeof fn !== 'function') {
        return;  //throw Error('No function provided')
      }
      return function curriedFn(...args) {
        if (args.length < fn.length) {
          return function (...nextArgs) {
            return curriedFn.apply(this, [...args, ...nextArgs]);
          }
        }
        return fn.apply(this, args)
      }
    }
    function multiFn1(a, b, c) {
      return a * b * c
    }
    function multiFn2(a, b, c) {
      return a + b + c
    }
    // 参数的长度是固定的
    var multi1 = curry(multiFn1);
    var multi2 = curry(multiFn2);
    console.log(multi1(2)(3)(4)); // multi1 就是curriedFn
    console.log(multi1(2, 3, 4))
    console.log(multi1(2)(3, 4))
    console.log(multi1(2, 3)(4))
    
    console.log(multi2(2)(3)(4)); // multi2 就是curryfn
    console.log(multi2(2, 3, 4))
    console.log(multi2(2)(3, 4))
    console.log(multi2(2, 3)(4))
```
## 3、数组扁平化
```js
// 数组扁平化
// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好 
function fun(array) {
  if (!Array.isArray(array)) return;
  let result = [];
  result = array.reduce(function (pre, cur) {
    // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中 
    return pre.concat(Array.isArray(cur) ? fun(cur) : cur);
  }, []);
  return result;
}

// 数组的扁平化    递归
function spinArr(arr) {
  // write code here
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      // res = res.concat(spinArr(arr[i]))
      res = res.push(...spinArr(arr[i]))
    } else {
      res.push(arr[i])
    }
  }
  return res;
}
let arr = [[1, 2, 3, 4, 5, 6], [18, 19, 20, 21, 22, 7], [17, 28, 29, 30, 23, 8], [16, 27, 26, 25, 24, 9], [15, 14, 13, 12, 11, 10]];
console.log(spinArr(arr))

// 数组的扁平化    递归
function flatten(arr) {
  while (arr.some(item => (Array.isArray(item)))) {
    arr = [].concat(...arr);
  }
  return arr;
}
```
## 4、数组去重