---
title: JavaScript手写（一）
date: 2022-01-25 20:53:16
permalink: /前端/JavaScript/JavaScript手写题1
categories:
  - 前端
  - JavaScript
tags:
  - 前端
  - JavaScript
---
## 1、实现一个深拷贝
浅拷贝可以使用 Object.assign 和展开运算符（...）来实现
深拷贝实现方式：手写、第三方库(loadsh)、JSON.parse(JSON.stringfy(data))

```javascript
const target = {
    a: 1,
    b: undefined,
    c: {
        child: 'child'
    },
    d: [2, 4, 6]
};
// 出现循环引用，爆栈问题，递归进入死循环导致栈内存溢出
target.target = target;
```
解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。
这个存储空间，需要可以存储key-value形式的数据，且key可以是一个引用类型，我们可以选择Map这种数据结构。

### 深拷贝的实现(简易版, 不考虑其他复杂情况~)

```javascript
function clone(target, map = new WeakMap()) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        if (map.get(target)) {
            return map.get(target);
        }
        map.set(target, cloneTarget);
        for (const key in target) {
            cloneTarget[key] = clone(target[key], map);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```

## 函数柯理化
```js
// 实现柯里化    fn是一个函数
    let curry = (fn) => {
      if (typeof fn !== 'function') {
        return;  //throw Error('No function provided')
      }
      return function curriedFn(...args) {
        if (args.length < fn.length) {
          return function (...nextArgs) {
            return curriedFn.apply(this, [...args, ...nextArgs]);
          }
        }
        return fn.apply(this, args)
      }
    }
    function multiFn1(a, b, c) {
      return a * b * c
    }
    function multiFn2(a, b, c) {
      return a + b + c
    }
    // 参数的长度是固定的
    var multi1 = curry(multiFn1);
    var multi2 = curry(multiFn2);
    console.log(multi1(2)(3)(4)); // multi1 就是curriedFn
    console.log(multi1(2, 3, 4))
    console.log(multi1(2)(3, 4))
    console.log(multi1(2, 3)(4))
    
    console.log(multi2(2)(3)(4)); // multi2 就是curryfn
    console.log(multi2(2, 3, 4))
    console.log(multi2(2)(3, 4))
    console.log(multi2(2, 3)(4))
```
