---
title: 动态规划
date: 2021-12-16 11:38:51
permalink: /算法/leetcode/动态规划
categories:
  - 算法
  - LeetCode
  - 动态规划
tags:
  - 算法
  - LeetCode
---
# 动态规划

斐波那契数列、跳台阶、背包问题、打家劫舍、股票题目、子序列(最长递增子序列、最长递增连续子系列、非常经典的编辑距离问题)

#### 动态规划大致的解题步骤：

1. 动态规划: 做状态转移，需要做dp数组，需要非常的了解dp的含义和下标
2. 递推公式非常重要
3. dp数组如何初始化
4. 遍历顺序
5. 打印 dp 数组

#### 状态转移的过程如下（简单示例）：

* 初始情况：dp[0] = nums[0];
* 若 nums[i] > 0，那么 dp[i] = nums[i] + dp[i - 1];
* 若 nums[i] <= 0，那么 dp[i] = nums[i];

## 1、爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶，你有多少种不同的方法可以爬到楼顶呢？

```javascript
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

### 题解：

```javascript
var climbStairs = function(n) {
    const dp = [];
    dp[0] = 1;
    dp[1] = 1;
    for(let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
};

var climbStairs = (n) => {
  let prev = 1;
  let cur = 1;
  for (let i = 2; i < n + 1; i++) {
    let temp = cur;     // 暂存上一次的cur
    cur = prev + cur;   // 当前的cur = 上上次cur + 上一次cur
    prev = temp;        // prev 更新为 上一次的cur
  }
  return cur;
}
```

## 2、最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```javascript
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

输入：nums = [0,1,0,3,2,3]
输出：4
```

### 题解：

```javascript
// dp[i]含义：从 0 到下标为i的序列的 最长递增子序列长度
// 递推公式：遍历到i的时候，再用j从0遍历到i，如果nums[i]>nums[j]，则dp[i] = max(dp[i], dp[j] + 1)
// 遍历dp[i]的时候，更新子序列的最大长度
// dp数组初始化：都初始化为dp[i] = 1
var lengthOfLIS = function(nums) {
    const dp = [1];
    for (let i = 1; i < nums.length; i++){
        dp[i] = 1;
        for (let j = 0; j < i; j++) {
            // nums[i] > nums[j] && (dp[i] = Math.max(dp[i], dp[j] + 1));
            if(nums[i] > nums[j]){
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Math.max(...dp);
}
var lengthOfLIS = (nums) => {
    let dp = Array(nums.length).fill(1);
    let result = 1;

    for(let i = 1; i < nums.length; i++) {
        for(let j = 0; j < i; j++) {
            if(nums[i] > nums[j]) {  // 当nums[i] > nums[j]，则构成一个上升对
                dp[i] = Math.max(dp[i], dp[j]+1);  // 更新dp[i]
            }
        }
        result = Math.max(result, dp[i]); // 更新结果
    }
    return result;
}
```

## 3、打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

```javascript
输入：[1,2,3,1], 输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)，偷窃到的最高金额 = 1 + 3 = 4 。

输入：[2,7,9,3,1], 输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

### 题解：

```javascript
// 思路
// 动态规划方程：dp[n] = MAX( dp[n-1], dp[n-2] + num )
// 由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，
// 要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值
// 举例来说：1 号房间可盗窃最大值为 33 即为 dp[1]=3，2 号房间可盗窃最大值为 44 
// 即为 dp[2]=4，3 号房间自身的值为 22 即为 num=2，
// 那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 55

var rob = function(nums){
    if(nums.length === 0){
        return 0;
    }
    if(nums.length === 1){
        return nums[0];
    }
    let dp = [];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[1], nums[0]);
    for(let i = 2; i < nums.length; i++){
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1];
}
// 优化空间复杂度
var rob = function(nums){
    if(nums.length === 0){
        return 0;
    }
    if(nums.length === 1){
        return nums[0];
    }
    let prev2 = nums[0];
    let prev1 = Math.max(nums[0], nums[1]);
    for(let i = 2; i < nums.length; i++){
        let temp = Math.max(prev1, prev2 + nums[i])
        prev2 = prev1;
        prev1 = temp;
    }
    return prev1;
}
```


## 4、连续子数组的最大值

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)

```javascript
输入: nums = [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

### 题解：

```javascript
// 解法 1：动态规划
// 定义状态数组dp[i]的含义：数组中元素下标为[0, i]的连续子数组最大和。
// 状态转移的过程如下：
// 初始情况：dp[0] = nums[0]
// 若 nums[i] > 0，那么 dp[i] = nums[i] + dp[i - 1]
// 若 nums[i] <= 0，那么 dp[i] = nums[i]
var maxSubArray = function(nums) {
    //let res = nums[0];
    const dp = [];
    dp[0] = nums[0];
    for (let i = 1; i < nums.length; i++) {
        // 每一个数组元素初始化 为对应 dp[i] = nums[i]
        dp[i] = nums[i];
        // 上一个元素的连续和大于 0
        if (dp[i - 1] > 0) {
            dp[i] = dp[i] + dp[i - 1];
        }
        //res = Math.max(res, dp[i]);
    }
    //return res;
    return Math.max(...dp);
};

// 原地进行动态规划
// 在原数组上做修改，用nums[i]来表示dp[i]。所以解法 1 的代码可以优化为：
var maxSubArray1 = function(nums) {
    let res = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if (nums[i - 1] > 0) {
            nums[i] = nums[i] + nums[i - 1];
        }
        res = Math.max(res, nums[i]);
    }
    return res;
};

// 贪心法
// 贪心法的题目比较少见，而且一般都比较难证明。本题的贪心法的思路是：在循环中找到不断找到当前最优的和 sum。
// 注意：sum 是 nums[i] 和 sum + nums[i]中最大的值。这种做法保证了 sum 是一直是针对连续数组算和。
var maxSubArray1 = function(nums) {
    let sum = nums[0];
    let maxSum = nums[0];
    for (let i = 1; i < nums.length; i++) {
        sum = Math.max(nums[i], sum + nums[i]);
        maxSum = Math.max(maxSum, sum);
    }
    return maxSum;
};
```
