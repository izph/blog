{"meta":{"title":"前端点点滴滴","subtitle":"坚持初衷，成为更好的自己","description":"Stick to your original intention and become a better self","author":"zhongph","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2022-07-10T08:46:45.363Z","updated":"2022-07-10T08:46:45.363Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"&#123; name: 'izph' age: 22, gender: '男', profession: 'Front End Developer', experience: '1年', address: '北京市', education: '本科', github: 'https://github.com/izph', blog: 'http://blog.yolo-ui.xyz', email: 'izph@foxmail.com', description: '来自HQU、信息与计算科学（数学方向）、前端开发程序员', skills: [ ['HTML', 'CSS', 'JavaScript', 'ES6'], ['Webpack', 'Git'], ['React', 'Node'] ], devTools: [ ['Visual Studio Code', 'Chrome DevTools'], ] &#125;"},{"title":"categories","date":"2016-09-05T23:41:55.000Z","updated":"2022-06-29T17:04:15.671Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-06-29T17:04:15.722Z","updated":"2022-06-29T17:04:15.722Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"推荐阅读书单","date":"2022-07-10T09:02:31.490Z","updated":"2022-07-10T09:02:31.490Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"JavaScript高级程序设计（第4版） 学习JavaScript数据结构与算法（第3版）"},{"title":"pageName","date":"2022-07-03T16:35:17.000Z","updated":"2022-07-03T08:35:17.141Z","comments":true,"path":"pageName/index.html","permalink":"http://example.com/pageName/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-29T17:04:15.723Z","updated":"2022-06-29T17:04:15.723Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-29T17:04:15.726Z","updated":"2022-06-29T17:04:15.726Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【React源码】React的设计理念","slug":"front_end/react-idea","date":"2022-05-14T08:15:20.000Z","updated":"2022-07-25T14:33:42.286Z","comments":true,"path":"2022/05/14/front_end/react-idea/","link":"","permalink":"http://example.com/2022/05/14/front_end/react-idea/","excerpt":"","text":"React简介 React 是用 JavaScript 构建快速响应的大型 Web 应用程序的前端框架，其设计理念就是快速响应。 React 吸收了函数式编程中代数效应的思想。从数据结构来讲，React 大量使用了链表，在调度阶段使用了小顶堆，并且使用了许多的闭包。 什么因素制约了 React 快速响应？什么因素导致应用不流畅呢？可能是因为进行了大量的计算，或者是因为当前网络状况不佳，正在等待请求的返回才能进一步操作导致不能快速响应等，可以说是计算能力和网络延迟的原因，制约了React快速响应，最终可归结为CPU的瓶颈和IO的瓶颈。 Reeact 为了践行快速响应的设计理念，是如何解决CPU和IO的瓶颈？ 主流的浏览器刷新频率为60Hz，也就是说每16.6ms（1000ms/60Hz=16.6ms）浏览器刷新一次。在这16.6ms过程中，会依次执行JS脚本、样式布局、样式绘制。如果JS脚本的执行时间超过了16.6ms，那么这一帧就没有时间留给样式布局、样式绘制。浏览器就会掉帧，表现形式就是浏览器的滚动不流畅、在输入框输入的字符不能及时的响应在页面上。对于这种情况，一般采用防抖（一段输入只会触发一次更新）和节流（限制触发更新的频率）来优化，本质上来说，这两个都是限制我们触发更新的频率，来减少掉帧的可能性，但是这是治标不治本的办法。随着我们输入的字符越来越多，我们每一次更新所需要的时间，都超过了浏览器一帧的时间时，那么使用防抖和节流也会造成浏览器的掉帧，那么有没有解决的办法呢？React给出的办法是将同步的更新改为异步更新。 简单来说，React 和浏览器做了一个约定，将自己一帧的时间预留给 React，React 利用这一部分时间来完成自己的工作，如果某个工作需要的时间特别长，超出了这个预留时间，React 会中断自己的工作，并将控制权交给浏览器，等到下一帧，浏览器给到自己预留的那部分时间到来之后，再继续之前被中断的工作，这样浏览器在每一帧都会有时间执行样式布局与样式绘制，这样就有可能减少掉帧的可能性。 所以，当采用了异步更新的形式，即使是更新了大量的节点，这样 CPU 密集型操作，React 也能有效的减少掉帧的可能性。 React是如何解决IO的瓶颈呢？ 比如需要等待数据请求的结果返回，才能做出进一步的响应的场景下，用户才能感知到快速响应呢？将人机交互的研究结果整合到真实的UI中，研究表明，在屏幕之间切换时显示过多的中间加载状态会使切换的速度变慢。对于UI交互来说，延迟显示中间加载的状态能让用户感觉更流畅。 React为了解决IO的瓶颈，以实现快速响应的理念，React更逐步在框架的层面实现异步可中断的更新机制，不管是CPU的瓶颈，还是IO的瓶颈，最重要的是实现一套异步的更新机制。 React设计理念的总结React设计理念是快速响应，制约快速响应的因素是CPU瓶颈与IO瓶颈，解决办法是实现异步可中断更新。 React架构React 从 v15 升级到 v16 后重构了整个架构。 React15 老架构React15架构分为两部分，分别是决定渲染什么组件（Reconciler 协调器）、将组件渲染到视图中（Renderer 渲染器）。对应于 Reconciler 协调器和 Renderer 渲染器，老的架构无法实现中断更新，需要新的 React16 架构，才能实现异步可中断更新。 Reconciler（协调器） 在 React 中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。 每当有更新发生时，Reconciler会做如下工作： 直接调用函数组件或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM 将虚拟 DOM 和上次更新时的虚拟 DOM 对比 通过对比找出本次更新中变化的虚拟 DOM 通知 Renderer（渲染器）将变化的虚拟 DOM 渲染到页面上 协调器负责决定本次更新有什么组件需要渲染，diff 算法就是发生在协调器中。在 diff 算法中，会将上一次更新的虚拟 DOM 与本次更新的 DOM 做一个对比，最终只有变化的部分会被渲染到视图中，diff 算法的官方名称是 reconcile，就是协调的意思，这也是协调器的由来。经过 diff 算法判定为本次需要更新的 虚拟DOM，会交给渲染器，渲染到视图中，不同的渲染器会将组件渲染到不同的宿主环境视图中。 Render（渲染器）在每次更新发生时，Renderer（渲染器）接到 Reconciler（协调器）通知，将变化的组件渲染在当前宿主环境。 ReactDOM 渲染器，渲染到浏览器； ReactNative 渲染器，渲染App原生组件； ReactTest 渲染器，渲染出纯JS对象用于测试； ReactArt 渲染器，渲染出Canvas、SVG。 React15架构的缺点采用递归执行更新，更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了浏览器间隔刷新一帧的时间（16.6ms），页面的交互就会出现卡顿。 React16 新架构（新的React架构） 由于更新是异步可中断的，在新的架构中，新增了一个模块来管理这些异步更新，每一个更新会被赋予一个优先级，高优先级的更新会被更快的调度。这个模块的被称为Scheduler（调度器）。 React16新的架构： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Scheduler（调度器）Scheduler（调度器）工作原理对于老的架构，更新会直接被 Reconciler（协调器）处理。在新的架构中，更新首先会被 Scheduler（调度器）处理，调度器会调度这些更新的优先级，更高优先级的更新会优先进入 Reconciler（协调器），在协调器正在执行 diff 算法时，如果此时产生了一个更高优先级的更新，那么正在协调器的协调的更新会被中断，由于调度器与协调器都是在内存中工作，不会执行具体的视图操作。即使有中断发生，用户也不会看到更新不完全的视图。当某次更新中，完成了在协调器的工作时，协调器会通知渲染器，本次更新有哪些组件，需要执行对应的视图操作，由渲染器来分别执行这些视图操作。对应我们常见的ReactDOM来说，这些视图操作包含了 DOM 节点的增删改查操作。当高优先级的更新最终完成了渲染，协调器又会调度新一轮的调度。 diff 算法的目的是创建一颗虚拟 DOM 树，每一个视图上存在的节点，都有一个虚拟 DOM 节点与其对应，被更新的节点会被打上Update标记（flags），最终协调器会将打了标记的虚拟 DOM 交给渲染器。 渲染器接收到通知后，会查看有哪些被打记号的虚拟DOM，被标记为Update的虚拟 DOM 节点对应的真实DOM会被渲染器执行更新DOM的操作。通过调度器、协调器、渲染器互相配合，React新的架构实现了异步可中断的更新。 Reconciler（协调器）当我们开启了Concurrent模式后（React18），更新工作中会调用workLoopConcurrent方法，从递归变成了可以中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。 function workLoopConcurrent() &#123; // workInProgress是当前fiber节点 while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; workInProgress = performUnitOfWork(workInProgress); &#125; &#125; React 协调器（Reconciler）的新架构FiberReact 践行代数效应，那代数效应与Fiber架构有什么联系吗？代数效应是函数式编程中的概念，用于将副作用从函数调用中分离，使得函数的关注点保持纯粹。 为了演示代数效应，虚构的语法 perform、handle、resume。执行 getTotalPicNum 函数，perform 语法会被 try handle 捕获，在 handle 处理 case。 resume with num会回到 getPicNum 函数调用栈，再中断执行完任务，回到之前的getTotalPicNum调用栈后，会继续执行接下来return num1 + num2的工作。 参考代数效应// 异步可中断更新原理 function getTotalPicNum(user1, user2) &#123; const num1 = getPicNum(user1); const num2 = getPicNum(user2); return num1 + num2; &#125; function getPicNum(name)&#123; const picNum = perform name; return picNum; &#125; function run()&#123; try &#123; getTotalPicNum('SouthStar', 'Nanxing'); &#125; handle (who) &#123; switch (who) &#123; case 'SouthStar': resume with 123; case 'Nanxing': resume with 12; default: resume with 0; &#125; &#125; &#125; run() 代数效应与React关系：Hooks。比如useState的值如何保存在函数组件，我们不太需要关注，这个由 React 处理。还有就是请求数据的写法如果是同步的，至于如何异步的请求数据，中间的加载状态是如何展示的，这完全是交由 React 来处理。 Fiber 就是利用了代数效应的中断、恢复，来完成了异步可中断的更新。 Fiber 的中文名是纤程，与进程(Process)、线程(Thread)、协程(Coroutine)同为操作系统的程序的执行过程，纤程可以理解为协程的一种实现，在JS中协程已经有了一种实现，就是 generator。 React团队为什么不直接使用generator来实现异步的更新，而是自己去实现一套 Fiber 纤程呢？ generator和async&#x2F;await一样，具有传染性，当一个函数成为generator函数后，这个函数调用链上的其他函数也会受到影响。 设计Fiber架构的目的是：更新可以中断并继续，更新可以拥有不同的优先级，高优先级的更新可以打断低优先级的更新 使用generator可以达到更新可以中断并继续的目的，但是不能实现不同的优先级的更新，所有React团队决定重头实现一套Fiber架构。 Fiber架构Fiber的含义Fiber和JSX都可以理解为一种数据结构，在React16新架构中，Fiber节点就是虚拟DOM。Fiber包含三层含义： 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler，stack就是调用栈。React16的协调器Reconciler是基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element（React组件），保存了该组件的类型（函数组件&#x2F;类组件&#x2F;原生组件…）、对应的DOM节点等信息，这是的Fiber节点也就是我们所说的虚拟DOM。举个例子，有一个 App 组件，当首次调用ReactDOM.render时，会创建整个应用的根节点FiberRootNode，我们是可以多次调用ReactDOM.render，将不同的应用挂载到不同的应用节点下，每个应用都有自己的根RootFiber节点。在一个页面中，可以有多个RootFiber，但是只能有一个FiberRootNode来管理这些RootFiber。 Fiber的结构function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) &#123; // 作为静态数据结构的属性 this.tag = tag; // 组件的类型，如function组件、class组件、DOM对应的Fiber节点（原生） this.key = key; // 我们常用的key属性 // 大部分情况elementType与type是一致的。在某些情况下，FunctionComponent被React.memo包裹时，它的elementType与type不同。 this.elementType = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.type = null; // Fiber对应的真实DOM节点，对于HostComponent，指真实的DOM节点， this.stateNode = null; // 用于连接其他Fiber节点形成Fiber树 this.return = null; this.child = null; this.sibling = null; // 对于多个同级Fiber节点，代表它们插入DOM的位置索引 this.index = 0; this.ref = null; // 常用的ref属性 // 作为动态的工作单元的属性，保存本次更新造成的状态改变相关信息 this.pendingProps = pendingProps; this.memoizedProps = null; // 存放属性的 增删改 // 存在updateQueue时，会调用markUpdate，为workInProgress的flags 标记为Update this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // HostComponent的副作用是增删查改，对应FunctionComponent使用了useEffect、useLayoutEffect this.flags = NoEffect; // 带有effect与副作用相关，标记flag的 fiber节点与fiber节点之间的 通过链表连接 this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // lanes属性与调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber this.alternate = null; &#125; Fiber节点的连接 每个Fiber节点有个对应的React element，多个Fiber节点是如何连接形成树呢？靠如下三个属性： // 指向父级Fiber节点 this.return = null; // 指向第一个子Fiber节点 this.child = null; // 指向右边第一个兄弟Fiber节点 this.sibling = null; 组件结构如下： function App() &#123; return ( &lt;div> title &lt;span>标题&lt;/span> &lt;/div> ) &#125; 对应的Fiber树结构： 为什么父级指针叫做return而不是parent或者father呢？这是因为React15的stack Reconciler以递归的形式工作，当从根节点执行递归操作时，首先会从根节点递归向下到子节点，再从子节点一路向上归到根节点，所以在这个递归阶段，函数处理完子节点后，会返回它的父节点。在Fiber Reconciler使用遍历的形式使用可中断的递归，也复用了这种思想。这就是为什么采用return指向父节点。 RootFiber采用stateNode指向FiberRootNode 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作、要执行的副作用（需要被删除&#x2F;被插入页面中&#x2F;被更新…）。 Fiber架构的工作原理双缓存Fiber架构使用双缓存的一种机制 React如何利用双缓存更新页面？当首次调用ReactDOM.render时，会创建整个应用的根节点FiberRootNode（源码中叫fiberRoot），每次调用ReactDOM.render，都会常见当前应用的根节点rootFiber，其中FiberRootNode.current指向rootFiber（fiberRootNode.current &#x3D; rootFiber;），由于在首次渲染页面之前，页面是空白的，所以rootFiber没有子节点（页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点，即current Fiber树为空）。接下来进入首屏渲染的逻辑，不管是首屏渲染还是调用this.setState，或者是useState的setXXX方法创建的更新，都会从根节点rootFiber创建一颗fiber树，首先创建根节点的rootFiber节点，这两棵树中都存在着rootFiber节点，会用alternate属性连接，方便两个fiber直接共用一些属性，接下来采用深度优先遍历模拟递归的方式创建整颗fiber树. 现在我们拥有两颗Fiber树，左边代表页面内容的fiber树，称为current Fiber树。右侧由于触发了更新，在内存中构建的fiber树，称为workInProgress Fiber树，它是根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树。当workInProgress Fiber树完成了渲染（即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后），此时FiberRootNode.current指向了workInProgress Fiber树的根节点rootFiber，于是workInProgress Fiber树的根节点rootFiber就变成了current Fiber树，FiberRootNode.current指向更新后的rootFiber。 接下来，我们点击p标签，触发一次更新，每次触发更新都会重新创建一颗workInProgress Fiber树。 可以将 current Fiber树的节点称为 current节点，此时 current 的 rootFiber的alternate属性已经指向了一个 rootFiber，所以在创建 workInProgress Fiber树 时会基于这个 rootFiber来创建。在本次更新中，除了rootFiber，APP 与 p 都有对应的current Fiber 存在（alternate指向该fiber在另一次更新时对应的fiber），这种将current Fiber 与本次更新返回的 JSX结构做对比，生成 workInProgress Fiber的过程，就是diff算法。所有首屏渲染与更新最大的区别在于：在创建Fiber树的过程中 是否有diff算法。 current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。 currentFiber.alternate === workInProgressFiber; workInProgressFiber.alternate === currentFiber; 当workInProgress Fiber树最终完成了渲染，FiberRootNode.current指向了workInProgress Fiber树的根节点，此时它就变成了current Fiber树。 React首屏渲染具体执行流程 调度阶段当首次调用ReactDOM.render时，会创建整个应用的根节点FiberRootNode，FiberRootNode方法就是创建整个FiberRootNode createHostRootFiber createFiber，它的参数tag为3由 createHostRootFiber中调用createFiber传入 协调阶段 scheduleUpdateOnFiber，调度这次更新，当调度成功后，我们会执行这次更新performSyncWorkOnRoot，也就是说从根节点开始这次更新 创建 workInProgress Fiber树 可以类比为递归的流程，beginWork为递过程，completeWork为归过程。 renderRootSync就是协调器的执行（render阶段），与它同级的commitRoot代表了这次渲染器的工作入口（commit阶段） 渲染器的工作入流程：将变化的节点渲染到视图上，before mutation阶段（渲染前），mutation阶段（渲染中），layout阶段（渲染后） JSXJSX和Fiber节点是同一个东西么，它们的关系？React Component、React Element是同一个东西么，他们和JSX有什么关系？ babel@babel&#x2F;plugin-transform-react-jsx将jsx // &lt;div>1&lt;/div> 编译后 React.createElement(\"div\", null, \"1\"); React.createElement既然JSX会被编译为React.createElement，让我们看看他做了什么： export function createElement(type, config, children) &#123; let propName; const props = &#123;&#125;; // 定义一些字段，key、ref是我们经常使用的 let key = null; // 作为保留属性传递 let ref = null; // 作为保留属性传递 let self = null; // __self作为保留属性传递 let source = null; // __source作为保留属性传递 if (config != null) &#123; // 将 config 处理后赋值给 props // ...省略 &#125; const childrenLength = arguments.length - 2; // 处理 children，会被赋值给props.children // ...省略 // ...省略 // 处理 defaultProps Resolve default props // defaultProps来自于React.createElement第一次参数type if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, ); &#125; const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; // 标记这是个 React Element $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, _owner: owner, &#125;; return element; &#125;; React.createElement最终会调用ReactElement方法返回一个包含组件数据的对象，该对象有个参数$$typeof: REACT_ELEMENT_TYPE标记了该对象是个React Element。 所以调用React.createElement返回的对象就是React Element么？ React提供了验证合法React Element的全局API React.isValidElement (opens new window)，我们看下他的实现： export function isValidElement(object) &#123; return ( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE ); &#125; 可以看到，$$typeof === REACT_ELEMENT_TYPE的非null对象就是一个合法的React Element。换言之，在React中，所有JSX在运行时的返回结果（即React.createElement()的返回值&#x2F;调用结果）都是React Element。 JSX与 Fiber的关系：创建Fiber节点的依据就是 组件返回的JSX对象，JSX是一种描述当前组件内容的数据结构。在更新时，依据存在了一颗current Fiber树，所以在生成 workInProgress Fiber树 时，将组件返回的JSX对象，与这个组件对应的 current Fiber节点做对比，根据对比的结果生成workInProgress Fiber树。这就是JSX与 Fiber的关系，JSX最终会被编译为 React.createElement方法的执行。理论上来说，只要改变React.createElement的方法，就能改变页面最终的渲染结果。 REACT_DEVTOOLS_GLOBAL_HOOK__REACT_DEVTOOLS_GLOBAL_HOOK__对象含有一个renderers，渲染器，急速React-DOM。 参考 React理念 React15架构 React16架构 Fiber架构的实现原理 Fiber架构的工作原理","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"React+Mobx6.0","slug":"front_end/react-mobx6","date":"2022-04-16T18:05:10.000Z","updated":"2022-07-07T16:32:29.036Z","comments":true,"path":"2022/04/17/front_end/react-mobx6/","link":"","permalink":"http://example.com/2022/04/17/front_end/react-mobx6/","excerpt":"","text":"mobx入门 在 Mobx6 中不推荐使用装饰器语法，因为它不是 ES 标准 mobx：mobx 核心库 mobx-react-lite：仅支持函数组件 mobx-react：既支持函数组件也支持类组件 下载 npm install mobx@6.5.0 mobx-react-lite@3.3.0 mobx核心概念 observable state：被 Mobx 跟踪的状态。 action：允许修改状态的方法，在严格模式下只有 action 方法被允许修改状态。 computed：根据应用程序状态派生的新值，计算值。 mobx 每次都是修改的同一个状态对象，基于响应式代理，也就是 Object.defineProperty 代理 get、set 的处理，get 时把依赖收集起来，set 修改时通知所有的依赖做更新。 mobx基础实践 Mobx官方文档 React+Mobx6从入门到实践 查看mobx的proxy对象的数据import &#123; toJS &#125; from \"mobx\"; console.log(toJS(user.name)); 持久化存储mobx-persist-store解决页面刷新的时候数据会丢失的情况 mobx-persist-store文档 makePersistable实践import &#123; makeAutoObservable, action, toJS &#125; from \"mobx\"; import &#123; makePersistable, isHydrated &#125; from \"mobx-persist-store\"; // 引入相关api // import localForage from \"localforage\"; // localforage前端数据存储 class User &#123; token: string; constructor() &#123; // 自动将已经存在的对象属性并且使得它们可观察，makeAutoObservable 不能被用于带有super的类或子类。 makeAutoObservable(this, &#123;&#125;, &#123; autoBind: true &#125;); // 数据持久化存储，在构造函数内使用 makePersistable makePersistable(this, &#123; // 保存的name，用于在storage中的名称标识，只要不和storage中其他名称重复就可以 name: \"userInfo\", // 注意：不写在这里面的字段将不会被保存，刷新页面也将丢失：get字段例外。get数据会在数据返回后再自动计算 properties: [\"token\"], // 保存的位置：看自己的业务情况选择，可以是localStorage，sessionstorage // localForage, window.localStorage storage: window.localStorage, // 还有一些其他配置参数，例如数据过期时间 expireIn: 86400000, // 以毫秒为单位，一天过期 removeOnExpiration: true, // 到期删除 stringify: false, // 是否转化成json字符串 &#125;).then(action((persistStore) => &#123; // persist完成的回调，在这里可以执行一些拿到数据后需要执行的操作，如果在页面上要判断是否成persist，使用isHydrated console.log(persistStore.isHydrated); &#125;)) &#125; // 注意这个字段的使用：在页面useEffect的时候，如果你没有添加依赖数组（初始化执行） // 那么你可能拿不到computed计算的数据（原因是这时候还没有persist结束）所以这个属性还是比较重要的 // 因为它可以在页面上做判断，当页面load完成，get数据计算完成之后，isHydrated会置为true get isHydrated() &#123; return isHydrated(this); &#125; /** * computed */ get token() &#123; return this.token; &#125; /** * action */ setToken(val) &#123; this.token = val || \"\"; &#125; &#125; export default new User(); 使用持久数据 useEffect(() => &#123; if (user.isHydrated) &#123; // ... 这个时候就可以拿到user里缓存的值 &#125; return () => &#123; // ... &#125; // eslint-disable-next-line &#125;, [user.isHydrated]) Redux和Mobx的区别 Mobx是学习成本低，比较简单，自由度更高（可直接修改状态）；Redux写起来有点繁琐，创建store，编写reducer，触发action等等。 Mobx比较推荐面向对象编程的写法；Redux则是推荐函数式编程，如reducer就是一个纯函数。 Mobx中的数据可读可写，并且不一定需要 action 修改状态，可直接修改状态；Redux是单一数据源，State 是只读的。 参考：Redux和Mobx的区别","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"如何搭建一个通用的基础组件库","slug":"engineering/component-library","date":"2022-03-29T20:39:18.000Z","updated":"2022-07-10T09:18:13.112Z","comments":true,"path":"2022/03/30/engineering/component-library/","link":"","permalink":"http://example.com/2022/03/30/engineering/component-library/","excerpt":"","text":"前言作为一名前端程序员，一直以来，我都只是停留在会使用各种优秀的组件库，包括开源和公司内部自研的，从来没有了解过这些组件库是如何开发的。直到现在，自己参考了多个开源组件库，由浅入深，尝试去实现一个简单的组件库，学习和探索组件库设计以及开发思路。 技术选择经过查阅资料，觉得dumi非常的合适。dumi是专门为组件开发场景而生的文档工具，开箱即用，支持TypeScript 和 Markdown，可以将更多的精力集中在组件开发上，核心技术栈为：React + TypeScript + less + dumi 环境准备安装初始化项目$ mkdir project-name &amp;&amp; cd project-name # 创建空目录 组件开发脚手架$ npx @umijs/create-dumi-lib --site # 初始化一个站点模式的组件库开发脚手架 # or $ yarn create @umijs/dumi-lib --site 目录结构说明 运行 执行 npm install，安装依赖。 执行 npm run start 或 npx dumi dev ，开始调试组件或编写文档，预览效果如下图： 组件的开发全局样式搭建新建src/style文件夹，放在全局的样式文件。其中theme文件下放通用的基础样式，global.less中引用style/inde.less的样式，dumi默认引入全局样式global.less。 定义基础样式 基础色彩样式，primary、default、success、warning、danger、info； 字体样式，默认font-family、默认font-size(1rem)、默认font-weight(400)、字体颜色、h1-h6(h6 默认是 1rem)； 超链接样式(默认primary，无下划线)； line-height(行高默认是字体的1.5倍大小)； body(字体大小是1rem、背景白色、字体淡黑色)； border边框(宽度1px、颜色@gray-300、radius是0.25rem)； 盒子阴影(@box-shadow: 0 0.5rem 1rem rgba(@black, 0.15))； 约定单个组件的文件结构以button组件为例，其中src/button/style/index.less为单个组件的内部样式文件，需要在src/style/index.less中引入，目录结构如下： 组件的开发步骤组件正确的开发流程：组件属性的分析 -&gt; 组件的开发 -&gt; (上生产环境需要组件测试) -&gt; 组件的使用说明文档 组件的分析：去定义一些接口或者类型别名，接口是用来描述props，声明组件的时候通过泛型传入； 组件的开发：不同的组件有不同的实现方式，相似的组件可以复用，编写组件基础样式； 组件的使用说明：描述一些需要通过props传入组件的属性，方便定制不同场景； Button按钮类型声明类型声明在src/button/interface.ts文件中写入，设置不同按钮的大小、按钮的主题类型、按钮的原生类型等 // 按钮大小 export type ButtonSize = 'lg' | 'md' | 'sm'; // 按钮的主题类型 export type ButtonType = 'primary' | 'default' | 'danger' | 'link' | 'info' | 'dashed' | 'warning'; // 按钮的原生类型 export type ButtonHTMLTypes = 'submit' | 'button' | 'reset'; export interface BaseButtonProps &#123; className?: string; /** 按钮禁用 */ disabled?: boolean; /** 按钮大小 */ size?: ButtonSize; /** 按钮类型 */ type?: ButtonType; /** 按钮children */ children: React.ReactNode; /** type为link时的url */ href?: string; &#125; // button 和 a链接 的原生属性太多了，可以直接把全部属性加上 // 从哪里可以找到button所有的props？react已经提供好的 // 合并交叉类型 type NativeButtonProps = &#123; htmlType?: ButtonHTMLTypes; target?: string; onClick?: React.MouseEventHandler&lt;HTMLElement>; &#125; &amp; BaseButtonProps &amp; Omit&lt;React.ButtonHTMLAttributes&lt;HTMLElement>, 'type'>; // ButtonHTMLAttributes&lt;HTMLElement> 所有button属性 type AnchorButtonProps = &#123; href?: string; onClick?: React.MouseEventHandler&lt;HTMLElement>; &#125; &amp; BaseButtonProps &amp; Omit&lt;React.AnchorHTMLAttributes&lt;HTMLElement>, 'type'>; // AnchorHTMLAttributes&lt;HTMLElement> 所有a标签属性 // Partial&lt;T> 将类型的属性变成可选，只支持处理第一层的属性 export type ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps>; Button按钮实现在src/button/index.tsx写入核心代码，需要考虑padding的大小、lineHeight高度、color颜色、textAlien文字居中、box-shadow盒子阴影，disabled时的特殊样式，鼠标的cursor的变化。 使用button标签和a标签实现； Button Size的大小其实就是padding控制，font-size不同、border的不同； Button Type是变化background-color、border-color、字体颜色color； 添加不同的状态：hover之后要颜色发生一定的变化，focus颜色变化，disabled颜色也发生变化(cursor: not-allowed和opacity: .65)。import React from 'react'; import classNames from 'classnames'; import &#123; ButtonProps &#125; from './interface'; const Button: React.FC&lt;ButtonProps> = (props) => &#123; // className用户自定义的 const &#123; type, className, disabled, size, children, href, ...restProps &#125; = props; // yolo-btn yolo-btn-lg yolo-btn-primary // 因为我们的key是变化的，所有用[`$&#123; &#125;`] const classes = classNames('yolo-btn', className, &#123; [`yolo-btn-$&#123;type&#125;`]: type, [`yolo-btn-$&#123;size&#125;`]: size, disabled: type === 'link' &amp;&amp; disabled, &#125;); if (type === 'link' &amp;&amp; href) &#123; return ( &lt;a className=&#123;classes&#125; href=&#123;href&#125; &#123;...restProps&#125;> &#123;children&#125; &lt;/a> ); &#125; else &#123; return ( &lt;button className=&#123;classes&#125; disabled=&#123;disabled&#125; &#123;...restProps&#125;> &#123;children&#125; &lt;/button> ); &#125; &#125;; Button.defaultProps = &#123; disabled: false, type: 'default', &#125;; export default Button; Button使用说明src/button/index.md 按钮的类型按钮分为七种类型 type，默认是 default。 default | primary | info | warning | danger | dashed | link import React from 'react'; import &#123; Button &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;div id=\"button-demo-display-type\"> &lt;Button type=\"default\">default&lt;/Button> &lt;Button type=\"primary\">primary&lt;/Button> &lt;Button type=\"info\">info&lt;/Button> &lt;Button type=\"warning\">warning&lt;/Button> &lt;Button type=\"danger\">danger&lt;/Button> &lt;Button type=\"dashed\">dashed&lt;/Button> &lt;Button type=\"link\" href=\"https://github.com/izph\"> link &lt;/Button> &lt;/div> ); &#125;; 按钮尺寸尺寸 size分为 lg | md | sm，即大、中、小，默认的尺寸是中。 import React from 'react'; import &#123; Button &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;div id=\"button-demo-display-size\"> &lt;Button size=\"lg\" type=\"primary\"> Large &lt;/Button> &lt;Button size=\"md\" type=\"danger\"> Medium &lt;/Button> &lt;Button size=\"sm\" type=\"warning\"> Small &lt;/Button> &lt;/div> ); &#125;; 按钮的禁用状态添加 disabled属性即可让按钮处于禁用状态，同时按钮样式也会改变。 import React from 'react'; import &#123; Button &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;div id=\"button-demo-display-size\"> &lt;Button type=\"primary\" disabled> primary &lt;/Button> &lt;Button type=\"danger\" disabled> danger &lt;/Button> &lt;Button disabled>default&lt;/Button> &lt;Button type=\"link\" disabled> link &lt;/Button> &lt;/div> ); &#125;; API通过设置 Button的属性来产生不同的按钮样式，按钮的属性说明如下： 属性 说明 类型 默认值 type 设置按钮类型 default、primary、info、 warning、danger、dashed、link default size 设置按钮大小 lg、md、sm，非必填 md disabled 按钮禁用状态 boolean false href 点击跳转的地址，指定此属性 button的行为和 a 链接一致 string - onClick 点击按钮时的回调 (event) =&gt; void - Button文档预览 Progress进度条类型声明类型声明在src/progress/interface.ts文件中写入，设置进度条主题颜色的类型、进度条组件的类型ProgressProps。percent代表当前进度条的百分比，strokeHeight设置高度，showText是否显示百分比数字。 import React from 'react'; export type ProgressThemeProps = | 'primary' | 'secondary' | 'success' | 'info' | 'warning' | 'danger' | 'light' | 'dark'; export interface ProgressProps &#123; /* 百分比 */ percent: number; /* 设置高度 */ strokeHeight?: number; /* 是否显示百分比文字 */ showText?: boolean; /* 用户自定义样式 */ style?: React.CSSProperties; /* 进度条主题颜色 */ theme?: ProgressThemeProps; &#125; Progress进度条实现在src/progress/index.tsx写入核心代码，根据传入的数字，来控制一个进度条长度；最外面有一个灰色progress-outer，它的高度可以配置，progress-outer内有一个子元素progress-inner，通过该元素的width来显示当前进度颜色，这个宽度是继承父元素progress-outer的，并悬浮到progress-outer上；通过在progress-inner设置flex布局，flex-end表示子项目从后往前排列，设置百分比数字显示在进度条右边，百分比数字也是支持显示和隐藏。 // progress/index.tsx import React, &#123; FC &#125; from 'react'; import &#123; ProgressProps &#125; from './interface'; /* percent: number 百分比 strokeHeight: number 高度 showText: boolean 是否显示百分比数字 theme: string 进度条主题色 style: React.CSSProperties 用户自定义样式 */ const Progress: FC&lt;ProgressProps> = (&#123; percent, strokeHeight, showText, style, theme, ...restProps &#125;) => &#123; return ( &lt;div className=\"yolo-progress\" style=&#123;style&#125; &#123;...restProps&#125;> &#123;/* 灰色最外层 */&#125; &lt;div className=\"yolo-progress-outer\" style=&#123;&#123; height: `$&#123;strokeHeight&#125;px` &#125;&#125;> &lt;div className=&#123;`yolo-progress-inner color-$&#123;theme&#125;`&#125; style=&#123;&#123; width: `$&#123;percent&#125;%` &#125;&#125;> &#123;showText &amp;&amp; &lt;span className=\"inner-text\">&#123;`$&#123;percent&#125;%`&#125;&lt;/span>&#125; &lt;/div> &lt;/div> &lt;/div> ); &#125;; /* 初始化默认值 */ Progress.defaultProps = &#123; strokeHeight: 15, showText: true, theme: 'primary', &#125;; export default Progress; Progress进度条说明文档src/progress/index.md 基本使用基本样式分为 7 种，默认类型为 primary。 primary | secondary | success | info | warning | danger | dark import React from 'react'; import &#123; Progress &#125; from 'yolo-ui'; export default () => ( &lt;div> &lt;Progress percent=&#123;20&#125; /> &lt;br /> &lt;Progress theme=\"secondary\" percent=&#123;30&#125; /> &lt;br /> &lt;Progress theme=\"success\" percent=&#123;40&#125; /> &lt;br /> &lt;Progress theme=\"info\" percent=&#123;50&#125; /> &lt;br /> &lt;Progress theme=\"warning\" percent=&#123;60&#125; /> &lt;br /> &lt;Progress theme=\"danger\" percent=&#123;70&#125; /> &lt;br /> &lt;Progress theme=\"dark\" percent=&#123;80&#125; /> &lt;br /> &lt;Progress theme=\"primary\" percent=&#123;100&#125; /> &lt;/div> ); 自定义高度import React from 'react'; import &#123; Progress &#125; from 'yolo-ui'; export default () => ( &lt;div> &lt;Progress percent=&#123;20&#125; strokeHeight=&#123;15&#125; /> &lt;br /> &lt;Progress theme=\"success\" percent=&#123;40&#125; strokeHeight=&#123;20&#125; /> &lt;br /> &lt;Progress theme=\"warning\" percent=&#123;60&#125; strokeHeight=&#123;30&#125; /> &lt;br /> &lt;Progress theme=\"danger\" percent=&#123;70&#125; strokeHeight=&#123;40&#125; /> &lt;/div> ); 是否显示百分比文字通过设置 showText属性。 import React from 'react'; import &#123; Progress &#125; from 'yolo-ui'; export default () => ( &lt;div> &lt;Progress percent=&#123;30&#125; showText=&#123;false&#125; /> &lt;br /> &lt;Progress theme=\"success\" percent=&#123;40&#125; strokeHeight=&#123;20&#125; showText=&#123;true&#125; /> &lt;br /> &lt;Progress theme=\"warning\" percent=&#123;60&#125; strokeHeight=&#123;30&#125; showText=&#123;true&#125; /> &lt;/div> ); API 属性 说明 类型 默认值 theme 主题颜色 primary | secondary | success | info | warning | danger | dark，非必填 primary percent 百分比 number - strokeHeight 进度条高度 number - showText 是否显示百分比文字 boolean true style 自定义样式 React.CSSProperties - Progress文档预览 Switch开关类型声明类型声明在src/switch/interface.ts文件中写入，checked属性是最开始是否被选中，disabled是否可以被禁用，onText开启状态的文本，offText关闭状态的文本，size是组件的尺寸大小，theme组件的颜色，onChange是状态切换时执行的回调函数。 import React from 'react'; export type SwitchSize = 'default' | 'sm'; export type SwitchChangeEventHandler = ( checked: boolean, event: React.MouseEvent&lt;HTMLButtonElement> | React.KeyboardEvent&lt;HTMLButtonElement>, ) => void; export interface SwitchProps &#123; /* 用户自定义样式 */ style?: React.CSSProperties; /** 是否被选中 */ checked?: boolean; /* 用户自定义类名 */ className?: string; /** 组件的尺寸 */ size?: SwitchSize; /** 是否被禁用 */ disabled?: boolean; /** 开启状态的文本 */ onText?: string; /** 关闭状态的文本 */ offText?: string; /** 状态切换时的回调 */ onChange?: SwitchChangeEventHandler; &#125; Switch开关实现在src/switch/index.tsx写入核心代码，基于button标签实现的，它有两个子元素div和span。div是一个白色的滑块，使用绝对定位，通过计算left值实现左右的切换，例如点击的时候，滑块的left值是left: calc(100% - 20px);，通过calc计算出的，这就是左右滑动的核心。同时还需要考虑background-color和background-image的优先级问题，最后span标签用来显示文本。 // switch/index.tsx import React, &#123; useState &#125; from 'react'; import classNames from 'classnames'; import &#123; SwitchProps &#125; from './interface'; /** * switch * @param &#123;checked&#125; bool 是否被选中 * @param &#123;disabled&#125; bool 是否被禁用 * @param &#123;onText&#125; string 开启状态的文本 * @param &#123;offText&#125; string 关闭状态的文本 * @param &#123;onChange&#125; func 状态切换时的回调 * @param &#123;size&#125; string Switch组件的尺寸大小 * @param &#123;theme&#125; string 组件的颜色 */ const Switch: React.FC&lt;SwitchProps> = (props) => &#123; const &#123; size, checked, disabled, onText, offText, onChange, className, style, ...restProps &#125; = props; /** * 设置初始背景色 */ const defaultStyle = &#123; ...style, backgroundColor: style?.backgroundColor || '#0099ff' &#125; const [isChecked, setChecked] = useState&lt;boolean>(!!checked); const classes = classNames('yolo-switch', className, &#123; 'yolo-switch-checked': !!isChecked, 'yolo-switch-disabled': disabled, [`yolo-switch-$&#123;size&#125;`]: size, &#125;); const handleClick = (e: React.MouseEvent&lt;HTMLButtonElement>) => &#123; if (!disabled) &#123; onChange &amp;&amp; onChange(!isChecked, e); setChecked(!isChecked); &#125; &#125;; return ( &lt;button type=\"button\" className=&#123;classes&#125; onClick=&#123;handleClick&#125; style=&#123;defaultStyle&#125; &#123;...restProps&#125; > &lt;div className=\"yolo-switch-handle\">&lt;/div> &lt;span className=\"yolo-switch-inner\">&#123;isChecked ? onText : offText&#125;&lt;/span> &lt;/button> ); &#125;; export default Switch; Switch说明文档src/switch/index.md 基本使用import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch checked /> &lt;br /> &lt;br /> &lt;Switch/> &lt;/> ); &#125;; 禁止使用import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch disabled /> &lt;br /> &lt;br /> &lt;Switch disabled checked /> &lt;/> ); &#125;; 定制主题颜色import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch checked style=&#123;&#123; backgroundColor: 'green'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'red'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'yellow'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'pink'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'blue'&#125;&#125;/> &lt;/> ); &#125;; 组件尺寸import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch checked size=\"sm\" /> &lt;br /> &lt;br /> &lt;Switch checked /> &lt;/> ); &#125;; 开关内容import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch onText=&#123;'开'&#125; offText=&#123;'关'&#125; onChange=&#123;(checked, e) => &#123; console.log(checked, e); &#125;&#125; checked /> &lt;/> ); &#125;; API 参数 说明 类型 默认值 style 自定义样式，backgroundColor可自定义颜色 string #09f checked 是否被选中 boolean false size 开关大学 default | sm - disabled 是否被禁用 boolean false onText 开启状态的文本 string | ReactNode - offText 关闭状态的文本 string | ReactNode - onChange 选中值发生变化时触发 function(checked: boolean, event: Event) - Switch文档预览 代码打包输出和发布组件库的入口文件 组件库的入口文件为 src/index.ts 组件库的全局样式文件为 src/style/index.less或者 src/global.less，两者都可以用来全局样式的提取。 组件的打包在根目录新建tsconfig.build.json文件&#123; \"compilerOptions\": &#123; \"outDir\": \"dist\", // 编译之后的存放路径 \"module\": \"ESNext\", \"target\": \"ES5\", // 指定编译之后的目标版本 \"declaration\": true, // 为每一个js文件生成 .d.ts类型声明文件 \"jsx\": \"react\", \"moduleResolution\": \"node\", // classic 和 Node \"allowSyntheticDefaultImports\": true // true 支持 defalut 引入的方式 &#125;, \"include\": [\"src/\"], \"exclude\": [\"src/**/style\", \"src/**/*.md\"] &#125; 在package.json文件中添加命令分别安装lessc和rimraf依赖，lessc将less转化为css，rimraf用来删除dist目录。 &#123; \"scripts\": &#123; \"clean\": \"rimraf ./dist\", \"build:lib\": \"npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css\", \"build-ts\": \"tsc -p tsconfig.build.json\", \"build-css\": \"lessc ./src/style/index.less ./dist/index.css\", &#125; &#125; 在执行build-ts发生了很多个报错如下，经过在stackoverflow上查找相关资料得知，是 @types/react-router-dom和 @types/react-router的版本太低了导致了，把这两个依赖升级到最新版本后，就可以正常打包了。 xxx/node_modules/@types/react-router-dom/index.d.ts(59,34): error TS2694: Namespace '\"/node_modules/history/index\"' has no exported member 'LocationState'. 本地测试(npm link) 在yolo-ui的根目录下执行npm link命令，npm link的作用是可以让未发布的npm包，做本地测试，映射脚本； 在yolo-ui-test（create-react-app生成的测试项目）工程下执行npm link yolo-ui； 在yolo-ui-test的package.json中加入yolo-ui依赖。 &#123; \"dependencies\": &#123; \"yolo-ui\": \"^0.1.0\" &#125;, &#125; 分别在 App.tsx和 index.tsx引入组件和组件的样式 // App.tsx import &#123; Button &#125; from 'yolo-ui'; function App() &#123; return ( &lt;div className=\"App\"> &lt;Button type=\"primary\">Hello Yolo&lt;/Button> &lt;/div> ); &#125; export default App; // index.tsx import \"yolo-ui/dist/index.css\"; 测试结果如下，本地测试没问题。 将yolo-ui发布到npm 切换npm的源镜像为npm的原生源 在命令行工具执行npm adduser，填写username、password and email 登录(sign in) 在package.json添加一些必要信息 &#123; \"files\": [ \"dist\" ], // 发布哪些文件到npm // 添加prepublish命令 \"scripts\": &#123; \"clean\": \"rimraf ./dist\", \"build:lib\": \"npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css\", \"build-ts\": \"tsc -p tsconfig.build.json\", \"build-css\": \"lessc ./src/style/index.less ./dist/index.css\", \"prepublish\": \"npm run build:lib\" &#125;, &#125; 执行npm publish即可发布到npm 此外，还可以在peerDependencies中告诉用户，要使用某某依赖需要安装什么依赖，如下：要使用yolo-ui库，需要安装react和react-dom的16.8.0版本以上。当npm i yolo-ui时，peerDependencies里面的依赖不会被安装，会有一个日志输出，npm warning会提示用户需要安装react和react-dom的依赖。 // package.json &#123; \"peerDependencies\": &#123; \"react\": \"≥16.8.0\", \"react-dom\": \"≥16.8.0\" &#125;, &#125; yolo-ui静态文档上传至阿里云服务器购买服务器本人买的是阿里云服务器 远程登录服务器桌面(windows) 在window桌面上按 win + R，输入 mstsc，进入远程桌面连接 如果没有添加windows凭据的，先在 控制面板-&gt;凭据管理器-&gt;windows凭据里添加服务器的凭据 输入账号和密码即可登录服务器远程桌面 安装node环境 将node的安装包上传到云服务器，并安装，node -v可以查看版本和是否安装成功 启动静态服务器 在根目录下 npm init -y，初始化 package.json文件，新建index.js文件 上传静态文件docs-dist（dumi 打包的产物）到根目录，docs-dist文件内容如下： 安装 koa和 koa-static，用来启动一个静态资源服务器。 在index.js写入代码： const Koa = require('koa'); const path = require('path'); const static = require('koa-static'); const app = new Koa(); // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './docs-dist'; app.use(static( path.join(__dirname, staticPath) )) app.listen(80, () => &#123; console.log('server is running, port is 80'); &#125;) 在根目录下执行 node index.js，开启服务器成功 最后在浏览器地址输入云服务器ip地址即可访问 域名的注册和备案nginx开启静态服务，并配置二级域名访问安装nginx（windows版） 进入nginx官网下载安装包: nginx下载 解压下载完成的nginx压缩包 打开cmd，进入nginx安装包根路径 输入命令nginx -t：检查nginx是否配置成功 输入命令start nginx：启动nginx服务 nginx其他常用命令 修改了配置文件，如nginx.conf，要使修改生效，重启Nginx服务 nginx -s reload 关闭nginx服务 nginx -s quit 强制关闭Nginx服务 nginx -s stop nginx.conf配置文件 nginx的配置在根目录conf文件夹下的nginx.conf文件中 server：代理服务器，可以设定多个代理服务器（每一个server就是一个虚拟服务器），请求进来之后由server的server_name决定该请求访问哪一个服务。 以下是在阿里云服务器nginx配置不同域名，访问不同的静态资源的例子，比如访问home和detial，我们只需要把静态文件分别放到C:/v1/home和C:/v1/detial目录下，即可通过http://home.xxxxx.com和http://detial.xxxxx.com分别访问对应的静态资源。 与此同时，需要在云服务器官网添加记录，二级域名的home和detial的解析设置 server &#123; # 设置监听端口 listen 80; server_name home.xxxxx.com; # 设置url编码格式，解决参数中文乱码问题 charset utf-8; location &#x2F; &#123; root C:&#x2F;v1&#x2F;home; # 设置 root-指定请求资源在服务器上的真实路径，可以写相对路径（相对于nginx安装目录）也可写绝对路径； index index.html index.htm; # 指定访问主页，会在root设定目录下去找，后面可跟多个页面，依次查找，找到一个即返回； &#125; &#125; server &#123; # 设置监听端口 listen 80; server_name detial.xxxxx.com; # 设置url编码格式，解决参数中文乱码问题 charset utf-8; location &#x2F; &#123; root C:&#x2F;v1&#x2F;detial; index index.html index.htm; &#125; &#125; YoloUI预览地址YoloUI官网 参考 dumi官方网站 ant-design arco-design monki-ui 最详细的React组件库搭建总结 Nginx在windows下的安装、运行，以及配置文件讲解","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"Koa 基础开发","slug":"front_end/koa-base","date":"2022-02-20T19:35:10.000Z","updated":"2022-07-22T17:11:59.201Z","comments":true,"path":"2022/02/21/front_end/koa-base/","link":"","permalink":"http://example.com/2022/02/21/front_end/koa-base/","excerpt":"","text":"koa官网文档 koa是一个基于http模块进行封装的框架，koa本身没有内置任何中间件，需要手动下载中间件（约定了中间件的写法），可以用来做服务端接口，也可以做接口的转发和聚合，RPC服务组装、SSR。 koa导出的是一个类，需要通过new 来实例化，koa也是继承了Events模块，性能非常好，代码量少，易于定制，很多框架都是基于koa进行定制开发（egg，thinkjs、midway都是基于koa2）。 基于koa框架的web开发要点ES6语法、异步流程控制、数据库操作、API接口转发、HTTP集成、Koa中间件 koa与express的区别 koa中间件可以对请求和响应同时进行拦截，express只能对请求进行拦截，而且是有顺序的，不能对响应进行拦截。 koa和express都内置了cookies模块、http模块，此外，express还内置了路由、视图模块。相对于express，koa还是比较轻量的。 koa中间件写法 中间件可以分为全局中间件和局部中间件，局部中间件在对应的路由里生效，比如静态资源服务，在特定的路由才执行 中间件是框架的扩展机制，对请求响应过程中加入中间件，应对处理复杂的业务逻辑。挂载在入口文件的中间件，会按照顺序执行。 koa中间件是洋葱模型，跳转的信号是next()，通过compose实现，最终的返回值是一个 function(context, next)。compose([fl, f2,..,fn])转化为了f1(..f(n-1)(fn(noop())) 在koa引入的中间件，需要使用app.use将中间件挂载到app上app.use(async (ctx, next) => &#123; console.log(1) await next() console.log(2) &#125;) app.use(async (ctx, next) => &#123; console.log(3) await next() console.log(4) &#125;) // 输出的结果是1342 koa中间件的工作过程中间件类似一个过滤器，koa中间件的工作大致过程可以分为三部分： 处理请求前先完成一些准备工作。 进行业务逻辑处理或通过next将业务交由下一个中间件处理。 后面的中间件完成处理后会进行回溯，执行处理后的操作。 ctx 参数ctx头部信息 设置头部信息：ctx.header(ctx.headers) 获取头部信息：ctx.get(&#39;key&#39;) ctx.method，获取请求方法 ctx.status或者ctx.response.status，获取状态码和设置状态码 ctx.type，设置Content-Type ctx.response.header &#x3D; ctx.request.header &#x3D; ctx.header ctx.req &#x3D; ctx.res &#x3D; ctx.request &#x3D; ctx.response ctx地址参数koa解析http://127.0.0.1:3000/api/v1/getUser?a=1&amp;b=2#abc地址后，会将返回的结果赋值给ctx对象。 API 示例值 ctx.href（不包括hash） http://127.0.0.1:3000/api/v1/getUser?a=1&amp;b=2 ctx.path &#x2F;api&#x2F;v1&#x2F;getUser ctx.url &#x2F;api&#x2F;v1&#x2F;getUser?a&#x3D;1&amp;b&#x3D;2 ctx.search ?a&#x3D;1&amp;b&#x3D;2 ctx.querystring a&#x3D;1&amp;b&#x3D;2 ctx.query &#123;&quot;a&quot;: &quot;1&quot;,&quot;b&quot;: &quot;2&quot;&#125; ctx.origin http://127.0.0.1:3000 ctx.host 127.0.0.1:3000 ctx.hostname 127.0.0.1 ctx.protocol http ctx.secure（https为true） false 获取不同的参数 参数名称 描述 Express获取方法 Koa获取方法 依赖模块 params 具名参数，比如/users/:id req.params ctx.params Koa需要依赖koa-router内置的ctx.params，而Express中有内置路由，无须依赖 query 查询字符串?a=1&amp;b=2 req.query ctx.query 内置，无须依赖 body 带有body请求的POST类方法，请求体body内容 req.body ctx.request.body Express依赖bodyparser模块，Koa依赖koa-bodyparser模块 koa写入Koa框架本身集成了Cookie的中间件，方法如下，options对象用于配置 ctx.cookies.get(name, [options]) ctx.cookies.set(name, value, [options]) options对象用于配置 maxAge: 一个数字, 表示从 Date.now() 得到的毫秒数, 表示多少毫秒后失效 expires: 一个 Date 对象, 表示 cookie 的到期日期 (默认情况下在会话结束时过期). path: 一个字符串, 表示 cookie 的路径 (默认是&#x2F;). domain: 一个字符串, 指示 cookie 的域 (无默认值). secure: 一个布尔值, 表示 cookie 是否仅通过 HTTPS 发送 (HTTP 下默认为 false, HTTPS 下默认为 true). httpOnly: 一个布尔值, 客户端无法操作cookie (默认为 true). sameSite: 一个布尔值或字符串, 表示该 cookie 是否为 “相同站点” cookie (默认为 false). 可以设置为 ‘strict’, ‘lax’, ‘none’, 或 true (映射为’strict’). signed: 一个布尔值, 表示是否要对 cookie 进行签名 (默认为 false). 此签名密钥用于检测下次接收 cookie 时的篡改. overwrite: 一个布尔值, 表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（无论路径或域）是否在设置此Cookie 时从 Set-Cookie 消息头中过滤掉. cookie的value默认是不能中文，可以使用buffer将中文转化后使用（通用的方法） // 设置signed: true 必须要app.keys = ['xxx'] 设置加密秘钥 // app.keys = ['xxx'] ctx.cookies.set('name', 'value', &#123; // signed: true, httpOnly: true, maxAge: 1000 * 30, // 30秒过期 &#125;); Cookie例子const Koa = require('koa') const app = new Koa() const Router = require('koa-router') const router = new Router() router.get('/setCookie', async (ctx) => &#123; ctx.cookies.set( 'id', '123456', &#123; domain: '127.0.0.1', // cookie所在的domain(域名) expires: new Date('2022-10-01'), // cookie的失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 &#125; ) ctx.body = `设置成功` &#125;) router.get('/getCookie', async (ctx) => &#123; const cookie = ctx.cookies.get('id') console.log(cookie) ctx.body = `cookie为：$&#123;cookie&#125;` &#125;) // 加载路由中间件 app.use(router.routes()) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) koa-router中间件const Koa = require('koa'); const app = new Koa(); const router = require('koa-router')() // 指定路由前缀 // router.prefix('/users') router.get('/', async (ctx, next) => &#123; ctx.body = '&lt;h1>koa-router&lt;/h1>' // 返回HTML // ctx.body = 'koa-router' // 返回 文本 // ctx.body = &#123; a: 1, b: 2&#125; // 返回json // await ctx.render('index', &#123; title: 'hello koa2'&#125;) &#125;) // 将路由挂载到app上 app.use(router.routes()).(router.allowedMethods()); app.listen(8888); ctx.body的工作原理根据body的类型设置对应的Content-Type，根据Content-Type调用res.write，将数据写入浏览器。可以知道，赋予ctx.body不同类型的值时会返回不同的结果： 为ctx.body赋值JSON对象时，服务器会返回JSON接口； 为ctx.body赋值字符串时，服务器会返回 HTML文本； ctx.render是因为添加了koa-views 中间件而绑定到ctx上的，原本的ctx上是没有render函数的。也就是说，我们可以通过中间件在ctx上绑定我们要使用的功能对象方法。 koa-router路由实现原理 本质上就是对ctx.path进行封装。定义路由，路由的路径会被转义成正则表达式，匹配请求，使用中间件进行处理。 koa-router的核心是路由的解析，使用的是path-to-regexp模块（express也使用了该模块），express路由和koa-router路由的区别是中间件的写法不同 匹配请求时，只和路径有关。qureyString参数是不会考虑在内的。比如 router.get('/v1') // GET /v1?name=zhongph 也会匹配上 具名参数，:xxx会被从正则表达式提前处理，具名参数通过ctx.params.xxx获取 router.get('/user/:id', (ctx, next) => &#123; console.log(ctx.params.id) &#125;) 路由也是中间件，可以定义多个中间件，在这个例子里，第一个中间件根据ID查询到的用户，先被绑定到了ctx对象上，然后交给了下一个中间件进行处理。接着，第二个中间件根据第一个中间件产生的ctx.user完成某些内容，最终决定返回何值。 router.get('/users/:id', function (ctx, next)&#123; return User.find0ne (ctx.params.id).then(function (user) &#123; ctx.user = user; return next(); &#125;) &#125;, function (ctx)&#123; console.log(ctx.user); // &#123; id: '001', name:\"zhongph\" &#125; &#125; ) koa-static静态服务静态服务器是通过静态HTTP服务器来提供HTML、JavaScript、CSS文件及图片的托管服务的.Node.js世界里的 koa-static、http-server等模块和常见的Apache、Nginx功能类似。线上通用做法是将静态资源放到CDN上，利用CDN就近访问来提高访问效率。实际开发环境，通过koa-static等模块能快速实现静态服务器功能。 // koa-static实现静态服务器，static 是一个函数，需要传一个静态资源的路径进去 const static = require('koa-static'); const path = require('path'); const Koa = require('koa'); const app = new Koa(); // 静态资源目录static 相对于 入口文件index.js的路径 const staticPath = './static'; // __dirname 是指 当前文件所在的目录 app.use(static(path.join(__dirname, staticPath))) app.listen(4000, (err, res) => &#123; console.log(\"server is running, port is 4000\"); &#125;); koa-static的做法是： 判断请求的文件是否存在，如果存在读取文件返回；如果请求的文件不存在，默认返回当前路径下的index.html 不要把static中间件放到Koa的全局中间件上（如果对于每个请求都要判断一次是不是静态资源，会影响QPS)，最好结合koa-router来处理，按需挂载 （QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准）const staticServer = require('koa-static'); const router = require('koa-router')(); router.get('/public/*', async (ctx, next) => &#123; ctx.url = path.basename(ctx.url) await next() &#125;, staticServer(resolve('./public'), &#123; gzip: true&#125;) ) koa-static的底层实现koa-static的底层使用的是koa-send koa-send原理 根据文件后缀名，进行设置 Content-Type。 以 stream 的形式为 ctx.body 赋值，这种方式比 fs.readFileSync 更高效。if (!ctx.type) &#123; ctx.type = type(path, encodingExt); &#125; ctx.body = fs.createReadStream(path); 其中 ctx.type是根据文件后缀来设置Content-Type的便捷方法，代码如下。// extname 和 basename 是path模块的方法 function type(file, ext)&#123; return ext !== '' ? extname(basename(file, ext)) : extname(file); &#125; 静态服务原理根目录下有static文件夹和index.js，static目录下有index.html文件、image和css文件夹，分别放置对应文件。 const Koa = require('koa') const fs = require('fs') const path = require('path') // 设置一个mime map，设计三种测试类型 const MIMES_MAP = &#123; 'css': 'text/css', 'html': 'text/html', 'jpg': 'image/jpeg' &#125; const app = new Koa() // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' // 解析资源类型 function parseMime(url) &#123; let extName = path.extname(url) extName = extName ? extName.slice(1) : 'unknown' return MIMES_MAP[extName] &#125; app.use(async (ctx) => &#123; // 静态资源目录在本地的绝对路径 let fullStaticPath = path.join(__dirname, staticPath) // 获取静态资源内容，有可能是文件内容，目录，或404 let content = fs.readFileSync(path.join(fullStaticPath, ctx.url), 'binary') // 解析请求内容的类型 let mime = parseMime(ctx.url) // 如果有对应的文件类型，就配置上下文的类型 if (mime) &#123; ctx.type = mime &#125; // 输出静态资源内容 if (mime &amp;&amp; mime.indexOf('image/') >= 0) &#123; // 如果是图片，则用node原生res，输出二进制数据 ctx.res.writeHead(200) ctx.res.write(content, 'binary') ctx.res.end() &#125; else &#123; // 其他则输出文本 ctx.body = content &#125; &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) koa-mountkoa-static不能用来设置请求前缀，如果想实现这个功能，就需要用到koa-mount，koa-mount是一个将中间件挂载到指定路径的Koa中间件，它可以挂载任意koa中间件。koa-mount和koa-static结合，就可以实现和Express一样的静态服务器带有请求前缀的功能，代码如下。 const Koa = require('koa'); const koaStatic = require('koa-static'); const mount = require('koa-mount'); const app = new Koa(); // app.use(koaStatic('.')) // 设置请求前缀 app.use(mount('/static', koaStatic('.')) app.listen (3000); // 访问 http:/127.0.0.1:3000/static/package.json koa-views koa-views是一个koa的动态模板引擎渲染中间件，主要用于简单的前后端不分离的项目。通过控制路由的方式，返回不同的页面。以前的服务端渲染页面，如JSP&#x2F;PHP，就是指模板引擎。 模板引擎采取了一种复用思想，通过定义模板，在使用时和数据一起编译，生成HTML页面，以便浏览器渲染。编译(模板＋数据) = HTML，模板是不可变的，可变的是数据，然而数据是从哪里来的呢? 可以从数据库读取，可以访问接口获得，甚至可以模拟，具体取决于业务场景。 模板推荐：ejs、pug（jade） const views = require('koa-views'); // 通过app.use绑定到app上，实际上是给app对象增加ctx.render方法的绑定 app.use(views(__dirname + '/views', &#123; extension: 'pug' &#125;)) // 模板文件：views/index，相对位置在views目录下 router.get('/', async (ctx, next) => &#123; await ctx.render('index', &#123; title: 'hello koa2'&#125;) // ctx.render渲染模板 &#125;) 这里的ctx.render就是用于渲染模板的方法，它有两个参数。 index: 模板，采用相对路径，对应的是views目录下的index.pug。 JSON对象: 需要传入到模板内的数据。 ctx.render 执行的操作： 通过文件读取 index.pug 模板。 使用 pug 模板引擎编译器将数据和模板内容编译为 HTML 字符串。 将 Content-Type 设置为 text&#x2F;html。 将 statusCode 状态码设置为200。 通过 http模块 底层的 res.write 和 res.end 方法将 HTML 字符串写入浏览器 模板引擎模板引擎的用途：用于动态渲染页面，与cli结合，作为模板使用 ejs 语句的需要有 &lt;% %&gt; （尖括号和百分号） 如果需要填入变量，需要在&lt;%添加一个等号，&lt;%&#x3D; &lt;ul> &lt;% user.forEach(function(user)&#123; %> &lt;li> &lt;%= user.name %>&lt;/li> &lt;% &#125;) %> &lt;/ul> pug （安装npm i -s pug）pug的基本使用：在这段模板定义代码里，if语句首先判断user对象是否存在，如果存在就显示&lt;h2&gt;标签，并把user.name作为变量嵌入&lt;h2&gt;标签的显示内容里。 //- user.pug if user h2= user.name pug的编译：使用 pug-cli 或 pug-server 可以自动将模板文件编译为HTML文件，并提供HTTP静态服务。此外，在线转化工具 html2jade，它可以将已有的HTML 代码转换为pug模板，非常的使用。 使用模板引擎（pug）时要注意： 引用公共模块时使用include。实现父子布局继承时使用extends。 定义布局模板时使用Layout，布局留空时使用block。缩进时使用Tab键而非空格。 不管有没有属性，标签和value之间都要有空格。 可以通过预编译来提高模板执行效率。 编译pug const pug = require('pug'); const fs = require('fs'); // 通过fs.readFileSync读取模板文件 // 当读取到的内容通过 toString 转化为字符串 const user_pug_str = fs.readFileSync('./user.pug').toString(); // pug.render方法进行编译，编译后的结果是HTML代码 var user_html = pug.render(user_pug_str, &#123; user: &#123; name: 'yolo' &#125; &#125;) console.log(user_html) // 编译结果 &lt;h2>yolo&lt;/h2> for循环显示列表 //- list.pug ul each item in users li= item.name pug模板引擎规则 标签属性 p#root.container //- 等价于 p(id='root', class='container') //- &lt;p id='root' class='container'>&lt;/p> 标签内容value，标签与内容之间有空格 p this is a tag //- &lt;p>this is a tag&lt;/p> 层级嵌套原理：利用缩进来判断包含关系。缩进方式有两种：使用空格和使用Tab建（推荐Tab键） &lt;ul class=\"parent\"> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;/ul> //- pug写法 ul.parent li 1 li 2 li 3 变量 //- 代码里等号，表示后面接的是变量，子类extends继承该布局时，name变量在子页面里也可以使用 p= name //- 插写法 p #&#123; name &#125; //- 不转义代码 !&#123; html &#125; !&#123; \"&lt;script>&lt;/script>\" &#125; if和each //- user.pug if user h2= user.name //- list.pug index是下标 ul each item, index in users li= item.name 布局 //- extends指明了当前pug页面需要继承哪个layout布局 extends ../layout //- 实现block模块，名字必须和layout里一致 block left_content block main_content 内嵌sctipt代码，script后面的点 .必须要有 script. function test()&#123;&#125; koa-compose可以将多个中间件合并成一个中间件 const compose= require('koa-compose') module.exports = (ctx, next) => &#123; return compose([ (ctx,next) => &#123; //中间件 return next() &#125; (ctx, next) => &#123; //中间件 return next() &#125; ])(ctx, next) &#125; koa-bodyparserkoa-bodyparser中默认只支持JSON、form两种格式的解析，其他类型的解析需要在enableTypes中配置，如&#39;text/plain&#39;配置为text。 const bodyparser = require('koa-bodyparser') // 将bodyparser挂载到app上 app.use(bodyparser( // 配置更多的类型 enableTypes: ['json', 'form', 'text'] )) // 访问 body参数 ctx.request.body // 如果post请求后面拼接了参数， 也可以通过ctx.query获取 @koa&#x2F;cors跨域问题 // 安装 @koa/cors 或者 koa2-cors（很久没有更新） // npm i koa2-cors const cors = require('@koa/cors') // https://www.npmjs.com/package/@koa/cors // 这里cors中间件一定要写在路由之前 app.use(cors()); app.use(router.routes(), router.allowedMethods()) @koa-multer（文件上传模块）文件上传有两种方式: 调用CDN的 SDK将文件直接从前端上传到CDN上； 采用常规上传方式，先将文件上传到Node.js服务器，再由 Node.js服务器转存到CDN； 二者的差别在于是否需要通过服务器对文件进行定制，如果没有这样的需求，直接上传就是很不错的方式。 @koa-multer是一个非常便于使用的文件上传模块，使用@koa-multer可以解析body中的流，并将其保存成文件。@koa-multer不会处理multipart&#x2F;form-data以外的任何表单 @koa&#x2F;multer文件上传 const Koa = require('koa') const Router = require('koa-router') const route = new Router() const multer = require('@koa/multer') const path = require('path') //上传⽂件存放路径、及⽂件命名 const storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, path.join(__dirname ,'/public')) &#125;, filename: function (req, file, cb) &#123; let type = file.originalname.split('.')[1] cb(null, `$&#123;file.fieldname&#125;-$&#123;Date.now().toString(16)&#125;.$&#123;type&#125;`) &#125; &#125;) //⽂件上传限制 const limits = &#123; fields: 10, // ⾮⽂件字段的数量 fileSize: 500 * 1024, //⽂件⼤⼩单位 b files: 1 // ⽂件数量 &#125; const upload = multer(&#123;storage,limits&#125;) // 在路由中，可通过 ctx.file 获取上传完毕的⽂件信息，多⽂件上传可通过 ctx.files 获取 route.post('/user/file', async (ctx,next)=>&#123; // file名字前后端要一致 let err = await upload.single('file')(ctx, next) .then(res=>res) .catch(err=>err) if(err)&#123; ctx.body = &#123; code:0, msg : err.message &#125; &#125;else&#123; ctx.body = &#123; code:1, data:ctx.file &#125; &#125; &#125;) &#125;) app.use(router.routes()).use(router.allowedMethods()) app.listen(3000) 文件上传koa-body和koa-send 后端逻辑const Koa = require('koa') const path = require('path') const fs = require('fs') const static = require('koa-static') const Router = require('koa-router') // koa文件上传用到的 中间件 const koaBody = require('koa-body'); // koa文件 下载 用到的 中间件 const send = require('koa-send'); const app = new Koa() const router = new Router() const staticPath = './static' app.use(koaBody(&#123; multipart: true, formidable: &#123; maxFileSize: 200 * 1024 * 1024 // 设置上传文件大小最大限制，默认2M &#125; &#125;)); // 静态服务器 app.use(static( path.join(__dirname, staticPath) )) app.use(router.routes()) router.post('/upload', async (ctx) => &#123; // 获取文件对象 const file = ctx.request.files.file // 读取文件内容 const data = fs.readFileSync(file.path); // 保存到服务端 fs.writeFileSync(path.join(__dirname, file.name), data); ctx.body = &#123; message: '上传成功！' &#125;; &#125;) router.get('/download/:name', async (ctx) => &#123; const name = ctx.params.name; const path = `$&#123;name&#125;`; ctx.attachment(path); await send(ctx, path); &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) 在koa中发起请求（node-fetch和axios）node-fetch node-fetch// npm i --save-dev node-fetch const fetch = require('node-fetch') fetch('http://127.0.0.1:3000/users/post', &#123; method: 'POST', body: JSON.stringify(&#123; username: 'yourUsername', password: 'yourPassword' &#125;), headers:&#123; 'Content-Type': 'application/json' &#125; &#125;).then(function(res) &#123; return res.json(); &#125;.then(function (json)&#123; console.log(json) &#125; 前端上传文件例子&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>上传&lt;/title> &lt;/head> &lt;body> &lt;input type=\"file\" /> &lt;button>点击上传&lt;/button> &lt;/body> &lt;script> document.querySelector('button').onclick = function () &#123; // 这里会获取一个 files 数组对象 因为是单文件上传取第一个即可 let file = document.querySelector('input').files[0]; let xhr = new XMLHttpRequest(); xhr.open('post', '/upload', true); xhr.onload = function () &#123; let res = JSON.parse(xhr.responseText); console.log(res); &#125; let form = new FormData(); form.append('file', file); // 对应 key value xhr.send(form); &#125; &lt;/script> &lt;/html> API访问鉴权：JSON Web Tokens(JWT)直接使用原始的JWT进行鉴权 客户端申请令牌时，使用jwt.sign进行签名，并将签名结果返回客户端； 签名体(payload）会包含用户的必要信息，以便通过 jwt.verify进行校验时能获得该信息，作为后面的查询依据； 当API请求携带令牌时，需要先使用jwt.verify进行校验，成功后才能根据用户信息查询并返回数据。 const jwt = require('jsonwebtoken'); const secret = 'secretxxx'; var token = jwti.sign(&#123; data: &#123; user_id: 100000, username: 'yolo', user_email:'yolo.com' &#125;, secret, &#123; expiresIn: '1h'&#125;); &#125;) // 获取令牌信息 // 检查PoST的信息、URL查询参数、头部信息 const token = ctx.request.body.token || ctx.query.token || ctx.headers['x-access-token'] // 验证 try&#123; var decoded = jwt.verify(token, secret) console.log(decoded); &#125;catch (err) &#123; &#125; 使用koa-jwt模块const jwt = require('koa-jwt'); router.get('/api', jwt(&#123; secret: 'secretXXX'&#125;), (ctx, next) => &#123; &#125;) koa-etag（ETag处理）ETag 是前端缓存优化的重要部分。ETag 在服务器端生成后，客户端将通过If-Match或If-None-Match条件判断请求来验证资源是否被修改，其中比较常用的是If-None-Match。如果资源没有被修改则返回304状态码，如果被修改则返回正常值。一般的静态 HTTP服务器都会根据文件内容来判断文件是否被修改，进而决定是否需要给客户端返回新内容。在Koa里，我们需要使用koa-conditional-get和 koa-etag插件来提供ETag 功能，示例如下。 这里定义的变量etag就是在Koa中用于生成ETag 的中间件。 ETag缓存是通过conditional-get拦截才能生效的。 koa-conditional-get 一定要放在koa-etag 前面。 const conditional = require('koa-conditional-get'); const etag = require('koa-etag'); t机市用 // etag模块 通常和 conditional-get 模块一起使用 app.use(conditional()); app.use(etag()); koa-session(会话session)koa-session + ioredis app.js入口文件const Koa = require('koa'); const fs = require('fs'); const Router = require('koa-router') const bodyParser = require('koa-bodyparser') const session = require('koa-session'); const Store = require('./store') // shortid 工具生成id const shortid = require('shortid'); const app = new Koa(); const router = new Router() const redisConfig = &#123; redis: &#123; port: 6379, host: '127.0.0.1', password: '', &#125;, &#125;; const sessionConfig = &#123; // cookie 键名 key: 'koa:session', // 过期时间为一天 maxAge: 86400000, // 不做签名 signed: false, // 提供外部 Store store: new Store(redisConfig), // key 的生成函数 genid: () => shortid.generate(), &#125;; app.use(session(sessionConfig, app)); app.use(bodyParser()); app.use(router.routes()); router.get('/', async (ctx) => &#123; ctx.set(&#123; 'Content-Type': 'text/html' &#125;); ctx.body = fs.readFileSync('./index.html'); &#125;) // 当用户登录时，走这里 router.post('/login', async (ctx) => &#123; const postData = ctx.request.body // 获取用户的提交数据 if (ctx.session.usr) &#123; ctx.body = `欢迎, $&#123;ctx.session.usr&#125;`; &#125; else &#123; ctx.session = postData; ctx.body = '您第一次登录系统'; &#125; &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) store.js// Node const Redis = require('ioredis'); class RedisStore &#123; constructor(redisConfig) &#123; this.redis = new Redis(redisConfig); &#125; // 获取 async get(key) &#123; const data = await this.redis.get(`SESSION:$&#123;key&#125;`); return JSON.parse(data); &#125; // 设置 async set(key, sess, maxAge) &#123; await this.redis.set( `SESSION:$&#123;key&#125;`, JSON.stringify(sess), 'EX', maxAge / 1000 ); &#125; // 销毁 async destroy(key) &#123; return await this.redis.del(`SESSION:$&#123;key&#125;`); &#125; &#125; module.exports = RedisStore; 前端登录逻辑&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>登录&lt;/title> &lt;/head> &lt;body> &lt;div> &lt;label for=\"user\">用户名：&lt;/label> &lt;input type=\"text\" name=\"user\" id=\"user\"> &lt;/div> &lt;div> &lt;label for=\"psd\">密码：&lt;/label> &lt;input type=\"password\" name=\"psd\" id=\"psd\"> &lt;/div> &lt;button type=\"button\" id=\"login\">登录&lt;/button> &lt;h1 id=\"data\">&lt;/h1> &lt;script> const login = document.getElementById('login'); login.addEventListener('click', function (e) &#123; const usr = document.getElementById('user').value; const psd = document.getElementById('psd').value; if (!usr || !psd) &#123; return; &#125; //采用 fetch 发起请求 const req = fetch('http://localhost:4000/login', &#123; method: 'post', body: `usr=$&#123;usr&#125;&amp;psd=$&#123;psd&#125;`, headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125;) req.then(stream => stream.text() ).then(res => &#123; document.getElementById('data').innerText = res; &#125;) &#125;) &lt;/script> &lt;/body> &lt;/html> koa-generic-session + koa-redis(基于redis存储) 依赖Redis，因此需要先启动Redis服务器。 通过ctx.session进行会话信息处理。 TTL是Session Store的超时时间，这个值一般是30min。 const Koa = require('koa') const session = require('koa-generic-session') const RedisStore = require('koa-redis') const app = new Koa() // app.env 默认是 NODE_ENV 或 \"development\" // app.proxyIpHeader 代理 ip 消息头, 默认为 X - Forwarded - For // app.maxIpsCount 从代理 ip 消息头读取的最大 ips, 默认为 0(代表无限) // app.keys 签名的 cookie 密钥数组 app.keys = ['keys', 'keykeys']; //加入全局中间件 app.use(session(&#123; store: new RedisStore(), ttl: 30 * 60 * 1000 // 半小时 &#125;)) // Session Store其实就是将会话存储在不同持久化存储中以后抽象出来的通用层，其基本的存、取和销毁操作如下。 // - get(sid): 根据sid来获取会话信息。 // - set(sid, sess, ttl): 通过sid设置会话信息，ttl指的是会话可存活时间(ms // - destroy(sid): 根据sid销毁会话。 // 在路由中可以直接通过ctx.session对后面的中间件进行操作 app.use (ctx => &#123; switch (ctx, path)&#123; case '/get': ctx.session.user = &#123; name: 'yolo' &#125; ctx.body = ctx.session.user break; case '/remove': ctx.session =null ctx.body = \"removed\" break &#125; app.listen (8080) koa-session例子 后端使用koa-sessionconst Koa = require('koa'); const fs = require('fs'); const Router = require('koa-router'); const bodyParser = require('koa-bodyparser'); const session = require('koa-session'); const app = new Koa(); const router = new Router(); const sessionConfig = &#123; // cookie 键名 key: 'koa:session', // 过期时间为一天 maxAge: 86400000, // maxAge: session 最大存活周期, 单位 ms, 默认一天。 // 不做签名 signed: false, // signed: 默认 true, 会自动给cookie加上一个sha256的签名, 防止篡改和伪造 Cookie 。 // autoCommit: 默认 true, 自动将 session 及 sessionid 提交至 header 返回给客户端。 当触发 manuallyCommit 时失效。 // overwrite: 默认 true, 是否允许重写。 // httpOnly: 默认 true, 防止XSS攻击, 防止恶意脚本代码劫持 session。 // rolling: 默认 false, 每次响应刷新 session 有效期。 // renew: 默认 false, 在 session 过期时刷新有效期。 // secure: 默认 false, 只在 https 中传输。 // sameSite: 默认 null, 不设置 // store: new sessionStore(redis)，外部存储 &#125;; // logger app.use(async (ctx, next) => &#123; await next(); // 响应时间 const rt = ctx.response.get('X-Response-Time'); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`); &#125;); // x-response-time app.use(async (ctx, next) => &#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`); &#125;); app.use(session(sessionConfig, app)); app.use(bodyParser()) app.use(router.routes()) router.get('/', async (ctx) => &#123; ctx.set(&#123; 'Content-Type': 'text/html' &#125;); ctx.body = fs.readFileSync('./index.html'); &#125;) // 当用户登录时，走这里 router.post('/login', async (ctx) => &#123; const postData = ctx.request.body // 获取用户的提交数据 if (ctx.session.usr) &#123; ctx.body = `欢迎, $&#123;ctx.session.usr&#125;`; &#125; else &#123; ctx.session = postData; ctx.body = '您第一次登录系统'; &#125; &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) log4js(日志处理) log4js const log4js = require(\"log4js\"); const logger = log4js.getLogger(); logger.level = \"debug\"; logger.debug(\"Some debug messages\"); 参考 koa官网文档 《Koa开发 入门、进阶与实战》 《Node.js12 实战》 《狼叔卷2》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://example.com/tags/Koa/"}]},{"title":"Node 知识梳理（一）","slug":"front_end/node-base","date":"2022-01-05T22:15:33.000Z","updated":"2022-07-08T14:22:02.526Z","comments":true,"path":"2022/01/06/front_end/node-base/","link":"","permalink":"http://example.com/2022/01/06/front_end/node-base/","excerpt":"","text":"Node 是一个基于谷歌V8引擎的一个JavaScript运行环境（runtime运行时），是服务端的运行环境。 Node 的特点是事件驱动、非阻塞式 I&#x2F;O（input&#x2F;output）、单线程。触发一次事件，执行回调，是事件驱动的一种体现。 Node的使用场景 I&#x2F;O 密集型场景 提供http接口，组装数据 RPC服务，RPC（Remote Procedure Call远程过程调用），RPC服务也是采用的TCP，出名的RPC服务有Google的gRPC、阿里的Dubble 基础工具：构建工具（webpack、vite）、搭建脚手架（cra、vue-cli、umi）等 BFF：接口聚合、转发 Serverless（无服务器架构）：函数即服务，写一个函数就可以实现一个 API 接口给到前端 Microservices（微服务）：小型服务、以独立进程运行、可以使用不同语言 Node.js 架构（node底层原理） Node.js内置模块（标准库）： http、fs、buffer、path、stream。 Node bindings（桥梁）：是JavaScript与 C++ 连接的桥梁，对底层模块进行封装，为内置模块的提供 API 接口。 Node底层模块 V8：Google开源的高性能JavaScript引擎，使用 C++ 开发，并且应用于谷歌浏览器 Libuv：提供Event Loop 事件循环和线程池，提供事件驱动的 I&#x2F;O 库。它是使用 C 和 C++ 语言为 Node.js 所开发的，同时也是 I&#x2F;O 操作的核心部分，例如读取文件和 OS 交互（几乎所有和操作系统打交道的部分离不开libuv的支持） C-ares（异步 DNS 解析库） Low-Level Components：提供了http 解析、OpenSSL、数据压缩（zlib）等功能。 Node EventLoop（事件循环）node中的事件循环的顺序：外部输入数据(incoming) –&gt; 轮询阶段(poll) –&gt; 检查阶段(check)–&gt; 关闭事件回调阶段(close callbacks) –&gt; 定时器检测阶段(timers) –&gt; I&#x2F;O事件回调阶段(I&#x2F;O callbacks) –&gt; 闲置阶段(idle, prepare) –&gt; 轮询阶段(按照该顺序反复运行) 每个阶段都有一个先入先出的队列，这个队列存有要执行的回调函数 ┌───────────────────────────┐ ┌─>│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ I/O callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ Node事件循环各阶段概述绝大部分异步任务都是在timers、poll、check这3个阶段处理的。 timers 这个阶段执行 setTimeout() 和 setInterval() 的回调，并且是由 poll 阶段控制的。 在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行，如果操作系统很忙，那么计时器的回调函数就会被推迟执行 I&#x2F;O callbacks 处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调（执行一些系统操作的回调函数） 闲置阶段：idle（空闲），prepare 仅在内部使用。 poll（轮询阶段）：处理大部分的事件，如看看有没有文件可以读，有没有请求可以处理，检查一下最近的计时器，看看有没有需要过会儿去执行的 callback。poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情 回到 timer 阶段执行回调 执行 I&#x2F;O 回调 并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 check（检查） 执行 setImmediate() 的回调 close callbacks 执行 socket 的 close 事件回调，例如：socket.on(&#39;close&#39;, ...)，如果队列是空的，则跳过 Node 不会一直循环循环，如果发现没什么事儿做，就会停留在 poll（轮询）阶段，大部分事件都在 poll 阶段被处理，如文件、网络请求等 进程和线程 进程 进程可以说是计算机系统进行资源分配和调度的基本单位，启动一个服务、运行一个应用，就是开一个进程，进程是线程的容器。 例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程。在任务管理器查看任务进程，Nodejs JavaScript Runtime 一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。 同一块代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的。 线程 线程是属于进程的，进程可以调用线程去执行一些子任务，一个进程是可以拥有多个线程的。 同一进程中的多条线程可以共享该进程中的全部系统资源。 同一进程中的多个线程有各自的调用栈（call stack），本地存储（thread-local storage)等。 线程可以分为单线程（JavaScript）和多线程（Java）。 单线程 单线程就是一个进程只开一个线程，Javascript 就是属于单线程，程序顺序执行，前面一个执行完之后，后面才可以执行。 在使用单线程编码时不要有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理，适当地使用异步操作。 多线程 多线程就是，一个进程可以开启多线程，Java 就是多线程编程语言的一种，可以有效避免代码阻塞导致的后续请求无法处理。 多线程创建新的线程来切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽。 Node模块机制 Node.js 模块采用Commonjs规范，Node.js的系统模块采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到 binding_cache缓存中。 在 Node.js 中模块加载一般会经历 3 个步骤，路径分析、文件定位、编译执行。按照模块的分类，按照以下顺序进行优先加载： 如果有 ./从当前目录查找，相对路径文件模块 如果没有 ./，先从系统模块，再从node_modules下查找 （nodejs模块系统） 系统缓存：模块被执行之后会进行缓存，首先是先进行缓存加载，判断缓存中是否有值（require.cache查看已缓存的模块，返回值为对象）。因为 Node.js 默认先从缓存中加载模块，一个模块被加载一次之后，就会在缓存中维持一个副本，如果遇到重复加载的模块会直接提取缓存中的副本，也就是说在任何时候每个模块都只在缓存中有一个实例。 系统模块：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了 路径分析、文件定位，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。 文件模块（开发者自己编写的模块）：优先加载 .、..、/ 开头的，如果文件没有加上扩展名，会依次按照 .js、.json、.node 进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在，从性能优化的角度来看待，.json、.node最好还是加上文件的扩展名。 目录做为模块：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个包来处理，Node 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 (&quot;main&quot;: &quot;lib/index.js&quot;) 描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module &#39;lib/index.js&#39; node_modules 目录加载：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录 Node常用模块 模块名称 功能描述 buffer 实现数据缓冲区，Buffer一般用于处理二进制数据，也可以处理字符编码 child_process （实现多进程任务）创建子进程，实现子进程和主进程之间的通信 cluster 可以简化多进程、并行化程序的开发难度，利用多核CPU 实现并行，轻松构建一个用于负载均衡的集群。著名的pm2模块就使用了cluster实现 console 和浏览里的用法一样，比如console.log、console.dir等 crypto 对OpenSSL里的 HMAC、Cipher、Decipher等算法进行加解密封装，一般用户在进行密码处理时都会用到该模块 dns 域名解析，主要API是 lookup和 resolve events 事件处理，EventEmitter的核心功能就是对事件触发和事件监听器功能进行封装 fs 文件系统模块，主要针对目录、文件进行操作，开发中使用极其广泛 http Node.js里使用多的模块，可以非常构建Web应用服务，搭建HTTP服务端和客户端，是Web框架的底层核心库 http2 下一代HTTP协议，在Node.js 8里是需要通过flag开启的体验功能 https HTTPS实现，是HTTP的安全加强版 process全局对象Node.js 中的进程 process 是一个全局对象，无需 require 直接使用（global.process &#x3D; process），process对象是EventEmitter的实例 process.title：终端上显示的标题 process.version：nodejs的版本号 process.versions：nodejs依赖模块的版本信息 process.env：环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息，还可以往process.env上挂载其他常量。 process.nextTick：表示在事件循环（EventLoop）的下一次循环中调用 callback 回调函数，要注意的是它总会在I&#x2F;O操作（比如查询数据）之前先执行 process.pid：获取当前进程id process.ppid：当前进程对应的父进程 process.cwd()：获取当前进程工作目录 process.argv: 返回当前命令行指令参数，是一个数组，process.argv[2] process.execPath：获取当前进程的这个可执行文件的绝对路径 process.exit([code])：终止当前进程并返回给定的 code，默认是0 process.exitCode：可以自定义退出进程时node shell捕获到的状态码（可以自定义退出进程时node shell捕获到的状态码） process.chdir(directory)：改变进程的当前进程的工作目录（该目录必须已存在），若操作失败则抛出异常 process.platform：获取当前进程运行的操作系统平台 process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 process.moduleLoadList：当前进程已加载的模块列表，nodejs模块系统。NativeModule原生模块 process.config：当前nodejs构建时使用的配置信息，可以辅助定位 process.on(&#39;exit&#39;, callback)：当进程将要退出时触发。 ‘exit’的回调结束后，主进程将不再运行 process.on(&#39;SIGINT&#39;, callback)：捕获当前进程接收到的信号 process.abort()：触发node的abort事件，退出当前进程，执行该函数后，后面的代码不执行。 process.kill(pid, [signal])：结束对应某pid的进程并发送一个信号 进程事件：process.on(&#39;uncaughtException&#39;, cb) 捕获异常信息、process.on(&#39;exit&#39;, cb)进程推出监听 三个标准流：process.stdout 标准输出、process.stdin 标准输入、process.stderr 标准错误输出 process.envprocess.env属性返回一个包含用户环境信息的对象。在node环境中，当我们打印process.env时，发现它并没有NODE_ENV这一个属性。实际上，process.env.NODE_ENV是在package.json的scripts命令中注入的，也就是NODE_ENV并不是node自带的，而是由用户定义的，至于为什么叫NODE_ENV，应该是约定成俗的吧。 child_process（创建子进程）Node.js 提供了 child_process 内置模块，用于创建子进程 child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。 child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。 child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I&#x2F;O 重定向和文件查找这样的行为 child_process.fork()：衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。 path主要作用就是处理文件的目录和路径，在前端项目webpack配置文件中经常用到。 path.join()拼接多个路径片段，还原成完整可用路径 path.join('a/b', 'c', 'index.html'); // a/b/c/index.html path.join('/a/b', 'c', 'index.html'); // /a/b/c/index.html path.join('a/b', 'c', '../', 'index.html'); // a/b/index.html path.resove()返回一个绝对路径 path.resove(); // 获取绝对路径 path.resove(__dirname, 'c', 'index.html'); basename()获取路径中基础名称 path.basename(__filename); // test.js // 传入第二个参数如果匹配会省略后缀，不匹配仍旧返回真实的后缀 path.basename(__filename, '.js'); // test path.basename('/a/b/c'); // c path.basename('/a/b/c/'); // c path.extname()获取路径中的扩展名称 path.extname('/src/index.html'); // .html path.parse()解析路径 const obj = path.parse('/src/index.html'); /** * root: / * dir: /src * base: index.html * ext: .html * name: index */ fs(读取文件)events（事件模块） 在 Node.js 中一个很重要的模块 Events（EventEmitter 事件触发器），EventEmitter 本质上就是观察者模式的实现。net、http、fs、stream、process 等模块，express、koa 框架都依赖了Events。 EventEmitter 对象的事件触发 emit 和监听 on 是同步的，事件的回调是异步的。 在 Node.js 的事件机制中主要有三类角色: 事件(Event)、事件发射器(EventEmitter)、事件监听器(Event Listener)。 Event EventEmitter 提供了 on()、once()、removeListener() 等方法来对事件进行监听移除，可同时注册多个同名的事件。其中once(): 当触发多次相同名称事件，通过 once 添加的侦听器只会执行一次。 EventEmitter 会按照监听器注册的顺序同步地调用所有监听器，所以必须确保事件的排序正确。提前触发未监听的事件，不会报错，并且不会执行监听的回调函数。 // 基本使用 const EventEmitter = require('events').EventEmitter; const emitter = new EventEmitter(); emitter.on(\"起床\", function(time) &#123; console.log(`早上 $&#123;time&#125; 开始起床，新的一天加油！`) &#125;); emitter.emit(\"起床\", \"6:00\"); // 在 Koa 中 new 一个 app 对象，通过 app.emit() 触发一个事件，实现在整个系统中进行传递。 const Koa = require('koa'); const app = new Koa(); app.on(\"koa\", function() &#123; console.log(\"在 Koa 中使用 EventEmitter\"); &#125;); app.emit(\"koa\"); // 通过Object.setPrototypeOf() 来实现的继承 function MyEmitter()&#123; EventEmitter.call(this); &#125; Object.setPrototypeOf(MyEmitter.prototype, EventEmitter.prototype); Object.setPrototypeOf(MyEmitter, EventEmitter); 默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告。 但是，并不是所有的事件都要限制 10 个监听器。 emitter.setMaxListeners() 方法可以为指定的 EventEmitter 实例修改限制。 // 操作最大事件监听个数 // 设置同类型事件监听最大个数 EventEmitter.prototype.setMaxListeners = function (count) &#123; this._count = count; &#125; // 获取同类型事件监听最大个数 EventEmitter.prototype.getMaxListeners = function () &#123; return this._count || EventEmitter.defaultMaxListeners; &#125; error事件当EventEmitter 实例出错时，应该触发error事件。如果没有为error事件注册监听器，则当error事件触发时，会抛出错误、打印堆栈跟踪，并退出Node.js进程。 const EventEmitter = require ('events'); class MyEmitter extends EventEmitter &#123;&#125; const myEmitter = new MyEmitter (); // 模拟触发error事件 myEmitter.emit('error', new Error('错误信息')); // 抛出错误 myEmitter.emit('error', (err) => &#123; console.log(err)) &#125;); Buffer（缓冲区） Buffer 用于读取或操作二进制数据流，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来。 如用于操作网络协议、数据库、图片和文件I&#x2F;O 等一些需要大量二进制数据的场景，专门存放二进制数据的缓存区。 Buffer 作为存在于全局对象上，使用时无需 require 引入模块即可使用。 Buffer 在创建时大小已经被确定且是无法调整的，在内存分配这块 Buffer 是由 C++ 层面提供而不是 V8。 Buffer应用场景Buffer的应用场景有以下几种。 在使用net或 http模块来接收网络数据时，可用 Buffer作为数据结构进行传输，即 data事件的参数。 用于大文件的读取和写入。以前fs读取的内容是string，后来都改用Buffer，在大文件读取上，性能和内存有明显优势。 用于字符转码、进制转换。Unicode 编码虽然能满足绝大部分场景，但有时候还是不够的，由于Node.js内置的转换编码并不支持GBK，因此如果要处理编码为GBK的文档，就需要iconv和 iconv-lite来补充一部分，string decoder模块提供了一个 API，用于把 Buffer对象解码成字符串，但会保留编码过的多字节UTF-8与UTF-16字符。 用作数据结构，处理二进制数据，也可以处理字符编码。 Buffer与字符串的传输速度buffer比string快。在 HTTP 传输中传输的是二进制数据，上面例子中的 &#x2F;string 接口直接返回的字符串，这时候 HTTP 在传输之前会先将字符串转换为 Buffer 类型，以二进制数据传输，通过流（Stream）的方式一点点返回到客户端。但是直接返回 Buffer 类型，则少了每次的转换操作，对于性能也是有提升的。在一些 Web 应用中，对于静态数据可以预先转为 Buffer 进行传输，可以有效减少 CPU 的重复使用（重复的字符串转 Buffer 操作）。 buffer模块与Buffer的关系Buffer是全局global上的一个引用，指向的其实是buffer.Buffer const buffer = require('buffer'); console.log(buffer.Buffer === Buffer); //true 创建Buffer Buffer.from()，第一个参数是内容，第二个是按什么格式转。Buffer.from不支持传入数字，传入数字可以采用传入数组的，存入的一组数据最好是：全部落在0到255区间 或者全部落在-128到127，这是因为不同的数字读取时应该调用不同的方法。Buffer.from(1234); // throw new errors.TypeError const buf = Buffer.from([1, 2, 3, 4]); console.log(buf); // &lt;Buffer 01 02 03 04> 显示的是16进制的 Buffer.alloc()，第一个参数是长度，第二个具体buffer内容const b2 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区 console.log(b2); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00> // 尝试分配一个大小为 2048 的 Buffer 对象 Buffer.alloc(2 * 1024) // 打印buffer，将每个字符串对应的ASCII码的十进制，转化为16进制的，比如 H 'H'.charCodeAt()// ASCII码：'72' 'H'.charCodeAt().toString(16) // '72'的16进制 '48' Buffer 字符编码通过使用字符编码，可实现 Buffer 实例与 JavaScript 字符串之间的相互转换。如果不传递 encoding 默认按照 UTF-8 格式转换存储 &#39;ascii&#39;仅适用于 7 位 ASCII 数据，此编码速度很快，如果设置则会剥离高位。 &#39;utf8&#39;多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8。 &#39;base64&#39;Base64 编码。。 &#39;binary&#39;一种将 Buffer 编码成单字节编码字符串的方法。 &#39;hex&#39;将每个字节编码成两个十六进制的字符。const buf = Buffer.from('hello world', 'utf8'); console.log(buf.toString('hex')); // 68656c6c6f20776f726c64 console.log(buf.toString('utf8')); // hello world 字符串与 Buffer 类型互转字符串转 Buffer（将字符串数据写入缓冲区）const b3 = Buffer.from('123456789', 'utf8'); console.log(b3) // &lt;Buffer 31 32 33 34 35 36 37 38 39> console.log(b3.length) // 9 Buffer 转换为字符串（从缓冲区读取string数据）使用 buf.toString([encoding], [start], [end]) 方法，默认编码仍为 UTF-8 const b3 = Buffer.from('123456789', 'utf8'); console.log(b3.toString()) // 123456789 console.log(b3.toString('utf8', 0, 5)) // 1234 将buffer转换成JSON对象buf.toJSON()，返回一个JSON对象。当字符串化一个buffer实例是，JSON.stringify()会隐式地调用该toJSON()。 const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); const json = JSON.stringify(buf); // 输出: &#123; \"type\": \"Buffer\", \"data\": [ 1,2,3,4,5] &#125; console.log(json); const copy = JSON.parse(json,(key, value) =>&#123; return value &amp;&amp; value.type === 'Buffer' ? Buffer.from(value.data) :value; &#125;); // 输出:&lt;Buffer 01 02 03 04 05> console.log(copy); buffer缓冲区的合并Buffer.concat(list[, totalLength]) list &lt;Buffer[]&gt; 要连接的 Buffer。 totalLength &lt;integer&gt; 连接时list中Buffer 实例的总长度，如果未提供 totalLength，则从 list 中的 Buffer 实例通过相加其长度来计算 返回: &lt;Buffer&gt; const buf1 = Buffer.alloc(10); const buf2 = Buffer.alloc(14); const buf3 = Buffer.alloc(18); const totalLength = buf1.length + buf2.length + buf3.length; console.log(totalLength); // 打印: 42 const bufA = Buffer.concat([buf1, buf2, buf3], totalLength); console.log(bufA); // 打印: &lt;Buffer 00 00 00 00 ...> console.log(bufA.length); // 打印: 42 缓冲区的拷贝Buffer.copy(buf) 缓冲区的比较Buffer.compare(buf1, buf2) 缓冲区的裁剪 buf.slice([start[, end]]) 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切 转换过程中为什么出现乱码？字符串中有中文，一个中文在UTF-8下占用3个字节。转成buffer后，再从buffer转成字符串时，如果字符被截断则容易出现乱码。 const buf = Buffer.from('前端开发'); console.log(buf); // &lt;Buffer e5 89 8d e7 ab af e5 bc 80 e5 8f 91> console.log(buf.length); // 12，一个中文在UTF-8下占用3个字节 console.log(buf.toString('UTF-8', 0, 8)); // 前端� Stream（流）Stream在 Node.js 中继承自EventEmitter，它有4种基本流类型。 Readable: 可读操作类型，可以产出数据，这些数据可以被传送到其他流中，只需要调用pipe方法即可。 Writable: 可写操作类型，只能流进不能流出。 Duplex: 可读可写操作类型（net.Socket）。 Transform: 转换类型，可以写入数据，然后读出结果。 node.js创建的流都是运作在字符串和buffer上的。Stream作为读写方法是最好的。可写流和可读流都会在内部的缓冲区中存储数据，可以分别使用 writable.writableBuffer 或 readable.readableBuffer 来获取。 流中的缓冲区 可写流和可读流都会在内部的缓冲区中存储数据，可以 writable.writableBuffer 或 readable.readableBuffer 来获取。 可缓冲的数据大小取决于传入流构造函数的 highWaterMark 选项。对于普通的流，highWaterMark 指定了字节的总数。对于对象模式的流，highWaterMark 指定了对象的总数。 当调用 stream.push(chunk) 时，数据会缓冲在可读流中。如果流的消费者没有调用 stream.read()，则数据会保留在内部队列中直到被消费。 一旦内部的可读缓冲的总大小达到 highWaterMark 指定的或值时，流会停止从底层资源读取数据，直到当前缓冲的数据被消贺（也就是说，流会停止调用内部的用于填充可读缓冲的 readable._read())。 当调用 writable.write(chunk）时，数据会被缓冲在可写流中。当内部的缓冲区的总大小小于 highWaterMark 设置的阈值时，调用 writable.write() 会返回true。一旦内部缓冲的大小达到或超过 highWaterMark 时，则会返回false。 因为双工流和转换流都是可读又可写的，所以它们各自维护着两个相互独立的内部缓冲区用于读取和写入，这使得它们在维护数据流时，读取和写入两边可以各自独立地运作。例如，net.Socket实例是双工流，它的可读端可以消费从socket接收的数据，而可写端则可以将数据写入到socket。因为数据写入到socket的速度可能比接收数据的速度快或慢，所以在读写两端独立地进行操作（或缓冲）就显得很重要了。 const fs = require('fs'); var source = fs.readFileSync('/path/to/source', (encoding: 'utf8')); fs.writeFileSync('/path/to/dest', source); // 等价于 // pipe是用来传递 上一个流的输出 并将其作为 下一个流的输入的链式方法。 fs.createReadstream('/path/to/source').pipe(fs.createWriteStream('/path/to/dest')); 可读流Node. js可读流是对提供数据的来源的一种抽象。所有可读流都实现了stream.Readable类定义的接口。可读流常见的例子包括客户端的HTTP响应、服务器的HTTP请求、fs的读取流、zlib流、crypto流、TCP socket、子进程 stdout 与 stderr、process.stdin。 stream.Readable类事件 close 事件close 事件在流被关闭时触发。表明不会再触发其他事件，也不会再发生操作。不是所有可读流都会触发close事件。如果使用 emitClose 选项创建可读流，则它将始终发出close事件。 data 事件data事件是在流将数据块传送给消费者后触发。对于非对象模式的流，数据块可以是字符串或 Buffer。对于对象模式的流，数据块可以是除了 null 的任何 JavaScript 值。当调用 readable.pipe()、readable.resume() 或绑定监听器到 data 事件时，流会转换到流动模式。当调用 readable.read() 且有数据块返回时，也会触发data 事件。如果使用 readable.setEncoding() 为流指定了默认的字符编码，则监听器回调传入的数据为字符串，否则传入的数据为 Buffer。 end 事件end 事件只有在数据被完全消费掉后才会触发。要想触发该事件，可以将流转换到流动模式，或反复调用 stream.read() 直到数据被消费完。 error 事件error事件通常是在当流因底层内部出错而不能产生数据，或推送无效的数据块时触发，监听器回调将传递一个 Error对象。 pause 事件调用 stream.pause() 并且 readsFlowing 不为 false 时，会发出 pause 事件。 readable 事件readable 事件在当流中有数据可供读取时触发。 const readable = getReadableStreamSomehow(); readable.on('readable', function()&#123; let data; // 有数据可读 while(data = this.read())&#123; console.log(data); &#125; &#125;) 当到达流数据的尽头时，readable 事件也会触发，但是在 end 事件之前触发。readable 事件表明流有新的动态，要么有新的数据，要么到达流的尽头。对于前者，stream.read() 会返回可用的数据。对于后者，stream.read() 会返回null。 stream.Readable类方法1.destroyreadable.destroy([error])方法用于销毁流，并触发error事件和close事件。调用后，可读流将释放所有的内部资源，且忽视后续的 push() 调用。实现流时不应该重写这个方法，而是重写 readable._destroy()。 2.isPausedreadable.isPaused() 方法用于返回可读流当前的操作状态。主要用于 readable.pipe() 底层的机制，大多数情况下无须直接使用该方法。 pause 与 resumereadable.pause() 方法使流动模式的流停止触发data事件，并切换到流动模式。任何可用的数据都会保留在内部缓存中。相对的，readable.resume() 将被暂停的可读流恢复触发data事件，并将流切换到流动模式，在readable事件使用不生效。 pipereadable.pipe(destination[, options])方法用于绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。 将可读流的所有数据通过管道推送到write-data.txt文件：const fs = require('fs'); const readable = fs.createReadStream('data.txt'); const writable = fs.createWriteStream('write-data.txt'); // readable的所有数据都推送到'write-data.txt' readable.pipe(writable); 可以在单个可读流上绑定多个可写流readable.pipe(writable1).pipe(writable2); 默认情况下，当来源可读流触发end事件时，目标可写流也会调用stream.end()结束写入。若要禁用这种默认行为，end选项应设为 false，这样目标流就会保持打开。reader.pipe (writer, &#123; end: false &#125;); reader.on ('end', () => &#123; writer.end ('结束'); &#125; 如果可读流发生错误，目标可写流不会自动关闭，需要手动关闭所有流以避免内存泄漏。process.stderr 和 process.stdout 可写的流在 Node.js 进程退出之前永远不会关闭。 read readable.read([size])方法用于从内部缓冲拉取并返回数据。其中，size指定要读取的数据的字节数。如果没有指定size参数，则返回内部缓冲中的所有数据。该方法如果没有可读的数据，则返回null。默认情况下，readable.read()返回的数据是Buffer对象，除非使用readable.setEncoding()指定字符编码或流处于对象模式。如果可读的数据不足size个字节，则返回内部缓冲剩余的数据，如果流已经结束则返回null。 readable.read()应该只对处于暂停模式的可读流调用。在流动模式中，readable.read()会自动调用直到内部缓冲的数据完全耗尽。 如果readable.read()返回一个数据块，则data事件也会触发。 end事件触发后再调用stream.read([size])会返回null，不会抛出错误。 const fs = require('fs'); const readable = fs.createReadStream('data.txt'); // 设置字符编码 readable.setEncoding('utf-8'); // 读取数据 readable.on('readable', () => &#123; let chunk; while (null !== (chunk = readable.read(10))) &#123; console.log(`接收到 $&#123;chunk.length&#125; 字节的数据`); console.log(`接收到的数据是： $&#123;chunk&#125;`); &#125; &#125;); readable.on('end', () => &#123; console.log('结束'); &#125;); 上述示例中，使用readable.read()处理数据时，while循环是必需的。只有在readable.read()返回null之后，才会发出readable事件; readable.setEncoding()用于设置字符编码。默认情况下没有设置字符编码，流数据返回的是 Buffer对象。如果设置了字符编码，则流数据返回指定编码的字符串。例如，本例中调用readable.setEncoding(&#39;utf-8&#39;)会将数据解析为UTF-8数据，并返回字符串。如果调用readable.setEncoding(hex)则会将数据编码成十六进制字符串。 readable.unpipe([destination])解绑之前使用 stream.pipe() 绑定的可写流。如果没有指定目标可写流，则解绑所有管道，如果指定了目标可写流但它没有建立管道，则不起作用。const fs = require('fs'); const readable = fs.createReadStream('data.txt'); const writable = fs.createWriteStream('write-data.txt'); // readable的所有数据都推送到'write-data.txt' readable.pipe(writable); setTimeout(() => &#123; console.log('停止写入数据'); readable.unpipe(writable); console.log('手动关闭文件流'); writable.end(); &#125;, 3); 两种读取模式流动模式或者暂停模式 可读流运作于流动模式(flowing)或暂停模式(paused)两种模式之一。 在流动模式中，数据自动从底层系统读取，并通过EventEmitter 接口的事件尽口能快地被提供给应用程序。 在暂停模式中，必须显式调用stream.read()读取数据块。所有可读流都开始于暂停模式，可以通过以下方式切换到流动模式。 添加data事件句柄。 调用stream.resume()。·调用stream.pipe()。可读流可以通过以下方式切换回暂停模式。 如果没有管道目标，则调用stream.pause()。 如果有管道目标，则移除所有管道目标。调用stream.unpipe()可以移除多个管道目标。 只有提供了消费或忽略数据的机制后，可读流才会产生数据。如果消费的机制被禁用或移除，则可读流会停止产生数据。 为了向后兼容，移除data事件句柄不会自动地暂停流。如果有管道目标，一旦目标变为drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。 如果可读流切换到流动模式，且没有可用的“消费者”来处理数据，则数据将会丢失。例如，当调用readable.resume() 时，没有监听data事件或data事件句柄已移除。 添加readable事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。如果 readable 事件句柄被移除，且存在data事件句柄，则流会再次开始流动。 可写流可写流是对数据要被写入的目的地的一种抽象。所有可写流都实现了stream.Writable类定义的接口。可写流常见的例子包括客户端的HTTP请求、服务器的HTTP响应、fs的写入流、zlib流、crypto流、TCP socket、子进程stdin、process.stdout、process.stderr。上面的一些例子事实上是实现了可写流接口的双工流。 stream.Writable类事件stream.Writable类定义了如下事件。 close事件当流及其任何底层资源（如文件描述符）已关闭时，将发出close事件。该事件表明不会发出更多事件，也不会进一步计算。如果使用emitClose选项创建可写流，它将始终发出close事件。 drain事件如果对stream.write(chunk)的调用返回false，则在适合继续将数据写入流时将发出drain事件。 error事件如果在写入管道数据时发生错误，则会发出error事件。调用时，监听器回调会传递一个Error参数。发出error事件时，流不会关闭。 finish事件调用stream.end()方法后会发出finish事件，并且所有数据都已刷新到底层系统。 const fs = require('fs'); const writable = fs.createWriteStream('write-data.txt'); for (let i = 0; i &lt; 10; i++) &#123; writable.write(`写入 #$&#123;i&#125;!\\n`); &#125; writable.end('写入结尾\\n'); writable.on('finish', () => &#123; console.log('写入已完成'); &#125;) pipe事件在可读流上调用stream.pipe()方法时会发出pipe事件，并将此可写流添加到其目标集。 unpipe事件当在可读流上调用stream.unpipe()时触发。当可读流通过管道流向可写流发生错误时，也会触发unpipe事件。 stream.Writable类方法 corkwritable.cork()方法用于强制把所有写入的数据都缓冲到内存中。当调用stream.uncork()或stream.end()时，缓冲的数据才会被输出。 当写入大量小块数据到流时，内部缓冲可能失效，从而导致性能下降，writable.cork()主要用于避免这种情况。对于这种情况，实现了writable._writev()的流可以用更优的方式对写入的数据进行缓冲。 destroywritable.destroy([error])方法用于销毁流。在调用该方法之后，可写流已结束，随后对write()或end()的调用都将导致ERR_STREAM_DESTROYED错误。如果数据在关闭之前应该刷新，则应使用end()方法而不是destroy()方法，或者在销毁流之前等待drain事件。实现者不应该重写此方法，而是实现writable._destroy()。 end调用writable.end([chunk][, encoding][, callback])方法表示不再将数据写入Writable。该方法的参数如下。 chunk&lt;string&gt;|&lt;Buffer&gt;|&lt;Uint8Array&gt;/&lt;any&gt;:要 写入的可选数据。对于不在对象模式下运行的流，块必须是字符串、Buffer 或 Uint8Array。对于对象模式流，块可以是除null 之外的任何JavaScript 值。 encoding&lt;string&gt;: 如果设置了编码，则 chunk 是一个字符串。 callback&lt;Function&gt;: 流完成时的可选回调。 调用writable.end()方法表示不再将数据写入Writable。可选的块和编码参数允许在关闭流之前立即写入最后一个额外的数据块。如果提供，则附加可选回调函数作为finish事件的监听器。 调用stream.end()后调用stream.write()方法将引发错误。 setDefaultEncodingwritable.setDefaultEncoding(encoding)为可写流设置默认的编码。 uncorkwritable.uncork()方法用于将调用stream.cork()后缓冲的所有数据输出到目标。当使用writable.cork() 和 writable.uncork() 来管理流的写入缓冲时，建议使用 process.nextTick() 来延迟调用 writable.uncork()。通过这种方式，可以对单个Node.js事件循环中调用的所有 writable.write() 进行批处理。 stream.cork (); stream.write ('一些'); stream.write('数据'); process.nextTick(()=> stream.uncork()); 如果一个流上多次调用 writable.cork()，则必须调用同样次数的 writable.uncork() 才能输出缓冲的数据。 stream.cork(); stream.write ('一些' ); stream.cork(); stream.write('数据'); process.nextTick(()=> &#123; stream.uncork (); //数据不会被输出,直到第二次调用uncork() stream.uncork(); &#125;); writewritable.write(chunk[, encoding][, callback]) 写入数据到流，并在数据被完全处理之后调用callback。如果发生错误，则callback可能被调用也可能不被调用。为了可靠地检测错误，可以为error事件添加监听器。该方法的参数如下。 chunk&lt;string&gt;|&lt;Buffer&gt;|&lt;Uint8Array&gt;|&lt;any&gt;: 要写入的数据。对于非对象模式的流，chunk 必须是字符串、Buffer 或 Uint8Array。对于对象模式的流，chunk 可以除null外的是任何 JavaScript 值。 encoding&lt;string&gt;: 如果chunk是字符串，则指定字符编码。 callback&lt;Function&gt;: 当数据块被输出到目标后的回调函数。 writable.write(): 写入数据到流，并在数据被完全处理之后调用callback。如果发生错误，则callback可能被调用也可能不被调用。为了可靠地检测错误，可以为error事件添加监听器。 在接收了chunk后，如果内部的缓冲小于创建流时配置的highWaterMark, 则返回true。如果返回false，则应该停止向流写入数据，直到drain事件被触发。 当流还未被排空时，调用write()会缓冲chunk，并返回false。一旦所有当前缓冲的数据块都被排空了(被操作系统接收并传输)，则触发drain事件。建议一旦write()返回false，则不再写入任何数据块，直到drain事件被触发。当流还未被排空时，也是可以调用write()， Node.js 会缓冲所有被写入的数据块，直到达到最大内存占用，这时它会无条件中止，甚至在它中止之前，高内存占用将会导致垃圾回收器的性能变差和RSS变高(即使内存不再需要，通常也不会被释放回系统)。如果远程的另一端没有读取数据，TCP的socket 可能永远也不会排空，所以写入到一一个不会排空的socket可能会导致产生远程可利用的漏洞。 对于Transform，写入数据到一一个不会排空的流尤其成问题，因为Transform流默认会被暂停，直到它们被pipe或者添加了 data 或readable 事件句柄。 如果要被写入的数据可以根据需要生成或取得，建议将逻辑封装为一一个可读流并且使用stream.pipe()。 如果要优先调用 write()，则可以使用 drain 事件来防止背压与避免内存问题。 双工流与转换流双工流（Duplex）是同时实现了Readable和 Writable接口的流。双工括TCP socket、zlib流、crypto流。转换流（Transform）是一种双工流，但它的输出与输入是相关联的。与双工流一样，转换流也同时实现了 Readable 和 Writable 接口。转换流的例子包括 zlib流和 crypto 流。 实现双工流双工流同时实现了可读流和可写流，如TCP socket连接。因为JavaScript不支持多重继承，所以使用stream.Duplex类来实现双工流（而不是使用stream.Readable类和stream.Writable类)。stream.Duplex类的原型继承自stream.Readable和寄生自stream.Writable，但是instanceof对这两个基础类都可用，因为重写了 stream.Writable 的Symbol.hasInstance。自定义的双工流必须调用new stream.Duplex([options])构造函数并实现 readable._read() 和 writable._write() 方法。以下是示例。 const &#123; Duplex &#125; = require('stream'); class MyDuplex extends Duplex &#123; constructor(options)&#123; super(options); // ... &#125; &#125; 双工流的例子封装了一个可读可写的底层资源对象 const &#123; Duplex &#125; = require('stream'); const kSource = Symbol('source'); class MyDuplex extends Duplex &#123; constructor(source, options) &#123; super(options); this[kSource] = source; &#125; _write(chunk, encoding, callback) &#123; // 底层资源只处理字符串。 if (Buffer.isBuffer(chunk))&#123; chunk = chunk.toString(); &#125; this[kSource].writeSomeData(chunk); callback(); &#125; _read(size) &#123; this[kSource].fetchSomeData(size, (data, encoding) => &#123; this.push(Buffer.from(data, encoding)); &#125;); &#125; &#125; net模块在nodejs中，net模块用于创建基于流的TCP或IPC的服务器与客户端。net主要包含两个部分： net.Server: TCP Server，内部通过socket来实现与客户端的通信。 net.Socket: TCP&#x2F;本地socket的Node版实现，它实现了全双工的stream接口，可以用来构建TCP客户端。 const net = require('net'); 创建TCP服务器 net.Server类创建TCP或IPC服务器 net.Server支持如下事件： listening事件: 当服务被绑定后调用server.listen()方法后触发。 connection事件: 当一个新的connection建立的时候触发，回调参数为socket连接对象。 close事件：当TCP服务器关闭的时候触发，回调函数没有参数。 error事件: 当TCP服务器出现错误的时候触发，回调函数的参数为err对象。例如，监听了已经被占用的端口号。 创建TCP服务器示例const net = require('net'); const server = net.createServer((socket) => &#123; socket.end('goodbye\\n'); &#125;).on('error', (err) => &#123; // 处理错误 throw err; &#125;); server.on('close', () => &#123; console.log('服务器接收到close事件'); &#125;) // socket对象，对象可以与客户端进行通信 server.on('connection', (socket) => &#123; console.log('服务器接收到connection事件') &#125;) server.on('listening', () => &#123; console.log('服务器接收到listening事件') &#125;) // 随机获取未绑定的端口 server.listen(() => &#123; console.log('服务器启动，占用端口：', server.address()); &#125;); 当创建了一个TCP服务器后，可以通过 server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有: port: TCP服务器监听的端口号。 family: 说明TCP服务器监听的地址是IPv6还是IPv4。 address: TCP服务器监听的地址。/** * 查看服务器监听的地址 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP服务器 */ var server = net.createServer(function (socket) &#123; console.log('someone connects'); &#125;) /* 获取地址信息 */ server.listen(8000, function () &#123; /* 获取地址信息，得到的是一个json &#123; address: '::', family: 'IPv6', port: 8000 &#125; */ var address = server.address(); /* TCP服务器监听的端口号 */ console.log(\"the port of server is\" + address.port); /* TCP服务器监听的地址 */ console.log(\"the address of server is\" + address.address); /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */ console.log(\"the family of server is\" + address.family); &#125;) 创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接，例如:/** * 连接服务器的客户端数量 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP服务器 */ var server = net.createServer(function (socket) &#123; console.log('someone connects'); /* 设置最大连接数量 */ server.maxConnections = 3; server.getConnections(function (err, count) &#123; console.log(\"the count of client is \" + count); &#125;) &#125;) /* 获取监听端口 */ server.listen(8000, function () &#123; console.log(\"Creat server on http://127.0.0.1:8000/\"); &#125;) 服务器和客户端之间的通信：socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据。/** * 连接服务器的客户端数量 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP服务器 */ var server = net.createServer(function(socket)&#123; /* 获取地址信息 */ var address = server.address(); var message = \"the server address is\"+JSON.stringify(address); /* 发送数据 */ socket.write(message,function()&#123; var writeSize = socket.bytesWritten; console.log(message + \"has send\"); console.log(\"the size of message is\"+writeSize); &#125;) /* 监听data事件，每次接收到数据的时候触发data事件 */ socket.on('data',function(data)&#123; console.log(data.toString()); var readSize = socket.bytesRead; console.log(\"the size of data is\"+readSize); &#125;) &#125;) /* 获取地址信息 */ server.listen(8000,function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\"); &#125;) server.listen监听链接listen()方法是异步的。当服务器开始监听时，会触发listening事件。最后一个参数callback将被添加为listening事件的监听器。 当且仅当在第一次调用server.listen()或调用server.close()期间出现错误时，才能再次调用server.listen()方法。 监听时最常见的错误之一是EADDRINUSE, 这说明该地址正被另一个服务器所使用。处理此问题的一种方法是在一段时间后重试。 server.on('error', function(e)&#123; if(e.code === 'EADDRINUSE')&#123; console.log('地址正被使用，重试中。。。') setTimeout(()=>&#123; server.close(); server.listen(PORT, HOST) &#125;, 1000) &#125; &#125;) server.listen(options[, callback])方法中的options参数支持如下属性 port&lt;number&gt;: 端口号。 host&lt;string&gt;: 主机。 path&lt;string&gt;: 如果指定了port，将被忽略。 backlog&lt;number&gt;。如果exclusive为 false，则集群将使用相同的底层句柄，从而允许共享连接处理。当exclusive为 true时，不共享句柄，并且尝试端口共享会导致错误。监听专用端口的示例如下。 exclusive&lt;boolean&gt;: 默认值是false。 readableAll&lt;boolean&gt;: 对于IPC服务器，使管道对所有用户都可读，默认值是false。 writableAll&lt;boolean&gt;: 对于IPC服务器，管道可以为所有用户写入，默认值是false。 创建Socket对象发送和接受数据const net = require('net'); const server = net.createServer(); server.on('error', (err) => &#123; // 处理错误 throw err; &#125;); server.on('close', () => &#123; console.log('服务器接收到close事件'); &#125;) server.on('connection', (socket) => &#123; console.log('服务器接收到connection事件'); socket.setEncoding('utf8'); socket.write('welcome!'); // 发送数据 socket.on('data', (data) => &#123; console.log('服务器接收到的数据为：' + data); // 如果收到c字符，就终止连接 if (data == 'c') &#123; socket.write('bye!'); socket.end(); // 关闭socket // 如果收到k字符，就关闭服务器 &#125; else if (data == 'k') &#123; socket.write('bye!'); socket.end(); // 关闭socket server.close();// 关闭服务器 &#125; else &#123; socket.write(data); &#125; &#125;) &#125;) server.on('listening', () => &#123; console.log('服务器接收到listening事件'); &#125;) // 绑定到端口 server.listen(8888, () => &#123; console.log('服务器启动，端口：8888'); &#125;); 在上述示例中，socket.write() 方法用于将数据写入 Socket发送; socket通过data事件，可以监听来自客户端写入的数据(接收)。在上述示例中，会将接收到的数据，再通过 socket.write() 方法发送回客户端。 关闭TCP服务器：TCP服务器通过 socket.end() 终止客户端的连接，也可以通过 server.close() 方法来将整个TCP服务器关闭。当TCP服务器关闭时，会监听到close事件。 构建TCP客户端可以用net.Socket构建TCP客户端，实现TCP客户端和TCP服务器的通信。 /** * 构建TCP客户端 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP客户端 */ var client = net.Socket(); /* 设置连接的服务器 创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。*/ client.connect(8000, '127.0.0.1', function () &#123; console.log(\"connect the server\"); /* 向服务器发送数据 */ client.write(\"message from client\"); &#125;) /* 监听服务器传来的data数据 */ client.on(\"data\", function (data) &#123; console.log(\"the data of server is \" + data.toString()); &#125;) /* 监听end事件 */ client.on(\"end\", function () &#123; console.log(\"data end\"); &#125;) net.Socket连接相关的API有: socket.connect(): 有3种不同的参数，用于不同的场景。 socket.setTimeout(): 用来进行连接超时设置。 socket.setKeepAlive(): 用来设置长连接。 socket.destroy( )、socket.destroyed: 当错误发生时，用来销毁socket，确保这个socket上不会再有其他的IO操作。 net.Socket涉及的事件: data: 当收到另一侧传来的数据时触发。 connect: 当连接建立时触发。 close: 当连接断开时触发。如果是因为传输错误导致的连接断开，参数就为error。 end: 当连接另一侧发送了FIN包的时候触发。默认情况下(allowHalfOpen &#x3D;&#x3D; false)，socket会完成自我销毁操作。但也可以把allowHalfOpen设置为true，这样就可以继续往socket里写数据。当然，最后需要手动调用socket.end()。 error: 当有错误发生时就会触发，参数为error。 timeout: 示用户socket已经超时，需要手动关闭连接。 drain: 当写缓存空了的时候触发。 lookup: 当域名解析完成时触发。 httphttp.Server类是继承自net.Server，有很多net.Server的方法和事件。 net、http、dgram模块分别用来实现TCP、HTTP、UDP的通信。http为应用层模块，主要按照特定协议编解码数据; net为传输层模块，主要负责传输编码后的应用层数据; https是一个综合模块（涵盖了http&#x2F;tIs&#x2F;crypto等)，主要用于确保数据安全性。 const http = require('http'); const hostname = '127.0.0.1'; const port = 8080; const server = http.createServer((req, res) => &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n'); // 用于完成发送请求 &#125;); server.listen(port, hostname, () => &#123; console.log(`服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/`); &#125;); http.Server事件 close事件：服务器关闭时触发close事件 connection事件：建立新的TCP流是会发出connection事件 request事件：每次有请求时都会发出request事件。注意，在HTTP Keep-Alive连接的情况下每个连接可能会有多个请求。 http.requset发送请求const http = require ('http'); const req = http.request(&#123; host: '127.0.0.1', port: 8080, method: 'POST' // 默认是GET，POST、PUT、DELETE &#125;, (res) => &#123; res.resume(); res.on('end', () => &#123; console.log ('请求完成!');&#125;); &#125;); http请求对象和响应对象HTTP请求对象和响应对象在 Node.js中是被定义在 http.ClientRequest和http.ServerResponse类中的。 http.ClientRequesthttp.ClientRequest对象由http.request()内部创建并返回。它表示正在进行的请求，且其请求头已进入队列。请求头仍然可以使用 getHeader(name) 返回请求头的值 removeHeader(name) 改变。 实际的请求头将与第一个数据块一起发送，或者当调用request.end()时发送。 要获得响应，则为请求对象添加response事件监听器。当接收到响应头时，将会从请求对象触发response事件。response事件执行时有一个参数，该参数是http.IncomingMessage的实例。 在response事件期间，可以添加监听器到响应对象，如监听data事件。 如果没有添加response事件处理函数，则响应将被完全丢弃。如果添加了response事件处理函数，则必须消费完响应对象中的数据，每当有readable事件时，会调用response.read()，或添加 data事件处理函数，或调用.resume()方法。在消费完数据之前，不会触发end事件。此外，在读取数据之前，它将占用内存，最终可能导致进程内存不足的错误。 http.ServerResponse类http.ServerResponse对象由HTTP服务器在内部创建，而不是由用户创建。它作为第二个参数传给request事件。ServerResponse继承自Stream。 close事件：表示底层链接已经终止 finish事件：在响应发送后触发。 response.end()方法response.end([data][, encoding][, callback])方法用于向服务器发出信号，表示已发送所有响应标头和正文，该服务器应该考虑此消息已完成。必须在每个响应上调用response.end() 方法。 如果指定了data，则它实际上类似于先调用response.write(data, encoding)方法，接着调用response.end()方法。如果指定了callback，则在响应流完成时将调用它。 response.setHeader(name, value)：设置响应头。 response.getHeaderNames()：返回已经设置的响应头属性数组。 response.getHeaders()：返回已经设置的响应头，以key-vale表示。 REST ful风格 若要在服务器上创建资源，应该使用POST方法。 若要检索某个资源，应该使用GET方法。 若要更新或添加资源，应该使用PUT方法。 若要删除某个资源，应该使用DELETE方法。 npmnpm全称node package manager即node包管理器。 查看当前项目的所有NPM脚本命令，可以使用不带任何参数的npm run命令: npm run npm 脚本的原理相对简单，每当执行npm run时，会自动新建一个Shell，在该Shell 中执行指定的脚本命令。 因此，只要是Shell (一般是Bash)可以运行的命令，就可以写在 NPM脚本里面。需要注意的是，npm run新建的 Shell 会将当前目录的node_modules.bin子目录加入PATH变量，命令执行结束后，再将PATH 变量恢复。也就是说，当前目录的node_modules&#x2F;.bin子目录里面的所有脚本都可以直接用脚本名调用，而不必加上路径。例如，当前项目的依赖里面有Mocha，只需要直接写mocha test即可: \"script\": &#123; \"test\" : \"mocha test\" &#125; // 而不需要写成: \"script\": &#123; \"test\" :\"./node_modules/.bin/mocha test\" &#125; 由于NPM脚本的唯一要求是可以在Shell 中执行，因此它不一定是Node脚本，任何可执行文件都可以写在script中。 安装的局部开发依赖如果有命令，会在node_modules&#x2F;.bin目录创建软连接，package.json是可以读取到依赖下.bin目录下的命令，可以在package.json直接使用该命令。 package.jsonpackage.json可以手动编写，也可以使用npm init命令自动生成，它描述了项目使用到的模块，项目名称（必填）、版本号（必填）、许可、关键词。 Name: 包名。 Version: 包的版本号，语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。 Description: 包的描述。 Homepage: 包的官网地址。 Author: 包的作者姓名。 Contributors: 包的其他贡献者姓名。 Dependencies: 依赖包列表，指定了项目运行所依赖的模块。如果依赖包没有安装，npm就会自动将依赖包安装在node_module目录下。 devDependencies: 指定项目开发所需要的模块。 repository: 包代码存放的地方的类型，可以是Git或Svn，Git可在GitHub 上。 main: main字段指定了程序的主入口文件, require(‘moduleName’)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。 keywords: 关键字。 scripts: 指定了运行脚本命令的npm命令行缩写，比如 start 指定了运行npm run start时所要执行的命令。 bin: 用来指定各个内部命令对应的可执行文件的位置。 config: 用于添加命令行的环境变量。 npm命令# 更新模块： npm update module # 查看安装的模块： npm list -g # 查看全局安装的模块 npm list # 查看本地安装的模块 # 查看某个模块的信息 npm list koa # 查看命令详细帮助 npm help # 查看包的安装路径 npm root [-g] # 清除npm本地缓存 npm cache clean WebSocketWebSocket 提供了一个真正的全双工连接，它可用于客户机和服务器之间的双向通信，客户端和服务器可以随意向对方发送数据。 该方案的优点是属于HTML5标准，已经被大多数浏览器支持，而且是真正的全双工，性能比较好。其缺点是实现起来相对比较复杂，需要对ws协议专门处理。 使用ws创建WebSocket服务器Node.js原生API并未提供 WebSocket的支持，因此，需要安装第三方包才能使用WebSocket 功能。 // npm i ws const WebSocket = require('ws'); const server = new WebSocket.Server(&#123; port: 8080 &#125;); WebSocket.Server(options[, callback]）方法中的options对象支持如下参数。 host&lt;String&gt;: 绑定服务器的主机名。 port&lt;Number&gt;: 绑定服务器的端口。 backlog&lt;Number&gt;: 挂起连接队列的最大长度。 server: 预先创建的Node.js HTTP&#x2F;S服务器。 verifyClient&lt;Function&gt;: 可用于验证传入连接的函数。 handleProtocols&lt;Function&gt;: 可用于处理WebSocket子协议的函数。 path&lt;String&gt;: 仅接受与此路径匹配的连接。 noServer&lt;Boolean&gt;: 不启用服务器模式。 clientTracking&lt;Boolean&gt;: 指定是否跟踪客户端。 perMessageDeflate: 启用&#x2F;禁用消息压缩。 maxPayload&lt;Number&gt;: 允许的最大消息大小(以字节为单位)。 ws事件 ws监听事件：connection。只要有WebSocket连接到该服务器，就能触发connection事件。 如果想获知所有的已连接的客户端信息，则可以使用server.clients数据集。该数据集存储了所有已连接的客户端。 发送和接收数据ws通过websocket.send()方法发送数据，通过监听message事件来接受数据。 发送数据websocket.send(data[, options][, callback])方法可以用来发送数据。data参数就是用来发送的数据。options对象的属性可以有以下几种。 compress: 用于指定数据是否需要压缩。默认是true。 binary: 用于指定数据是否通过二进制传送。默认是自动检测。 mask: 用于指定是否应遮罩数据。当WebSocket不是服务器客户端时，默认认为true。 fin: 用于指定数据是否为消息的最后一个片段，默认为true。 发送ping和pong在消息通信中, ping-pong是一种验证客户端和服务器是否正常连接的简单机制。当客户端给服务器发送ping消息时，如果服务器能够正常响应pong消息，则说明客户端和服务器之间的通信是正常的。反之亦然，如果服务器想验证客户端的连接是否正常，也可以给客户端发送ping消息。ws提供了一种快捷的方式来发送ping消息和pong消息。 websocket.ping([data[, mask]][, callback]) websocket.pong([data[, mask]][, callback]) 接收数据ws通过message事件来接收数据 准备状态ws 中的 WebSocket类具有以下4种准备状态。 CONNECTING: 值为0，表示连接还没有打开。 OPEN: 值为1，表示连接已打开，可以通信了。 CLOSING: 值为2，表示连接正在关闭。 CLOSED: 值为2，表示连接已关闭。需要注意的是，当通过 WebSocket对象进行通信时，状态必须是OPEN。 关闭WebSocket服务器可以通过server.close()来关闭服务器，并通过close事件监听服务器的关闭。 ws例子 服务端const WebSocket = require('ws'); const WebSocketServer = WebSocket.Server; const wss = new WebSocketServer(&#123; port: 3000 &#125;); wss.on('connection', function (ws) &#123; console.log(`[SERVER] connection()`); ws.on('message', function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); setTimeout(() => &#123; ws.send(`What's your name?`, (err) => &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;, 1000); &#125;) &#125;); console.log('ws server started at port 3000...'); 客户端（浏览器）// client test: let count = 0; let ws = new WebSocket('ws://localhost:3000/ws/chat'); ws.on('open', function () &#123; console.log(`[CLIENT] open()`); ws.send('Hello!'); &#125;); ws.on('message', function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`); count++; if (count > 3) &#123; ws.send('Goodbye!'); ws.close(); &#125; else &#123; setTimeout(() => &#123; ws.send(`Hello, I'm Mr No.$&#123;count&#125;!`); &#125;, 1000); &#125; &#125;); WebSocket 协议本身不要求同源策略（Same-Origin Policy)，也就是某个地址为 http://a.com的网页可以通过 WebSocket连接到ws://b.com。但是，浏览器会发送 Origin 的 HTTP 头给服务器，服务器可以根据 Origin 拒绝这个 WebSocket 请求。所以，是否要求同源要看服务器端如何检查。 MySQL基本操作# 显示已有的数据库 show databases; # 创建数据库 CREATE DATABASES data_name; # nodejs_book # 使用数据库 use data_name; # 建表 mysql> CREATE TABLE t_user ( user_id BIGINT NOT NULL, username VARCHAR(20)); # 查看表 show TABLES; # 显示表的结构 mysql> DESCRIBE t_user; # 往表中加入记录 mysql> insert into t_user values(1, 'yolo'); 使用node.js操作mysql使用mysql或者mysql2模块 实现简单的查询 mysql.createConnection()用于创建一个连接; connection.connect()方法用于建立连接; connection.query()方法用于执行查询，第一个参数就是待执行的SQL语句; connection.end()用于关闭连接。 const mysql = require('mysql'); // 连接信息 const connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '123456', database: 'nodejs_book' &#125;); // 建立连接 /// connection.connect(); connection.connect(function (err) &#123; if (err) &#123; console.error('error connecting: ' + err.stack); return; &#125; console.log('connected as id ' + connection.threadId); &#125;); // 执行查询 connection.query('SELECT * FROM t_user', function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('SELECT result is: ', results); &#125;); // 关闭连接 ///connection.end(); ///connection.destroy(); connection.end(function (err) &#123; if (err) &#123; console.error('error end: ' + err.stack); return; &#125; console.log('end connection'); &#125;); mysql模块连接选项 参数 描述 host 主机地址,默认是localhost user 用户名 password 密码 port 端口号，默认是3306 database 数据库名 charset 连接字符集（默认:&#39;UTF8_GENERAL_CI&#39;，注意字符集的字母都要大写) localA ddress 此IP用于TCP连接（可选) socketPath 连接到unix域路径，当使用host和port时会被忽略 timezone 时区，默认是&#39;local&#39; connectTimeout 连接超时，单位为毫秒。默认为不限制 stringifyObjects 是否序列化对象 typeCast 是否将列值转换为本地JavaScript类型值。默认为true queryFormat 自定义query语句格式化方法 supportBigNumbers 数据库支持bigint或decimal类型列时，需要设此option为true。默认为false bigNumberStrings supportBigNumbers和bigNumberStrings启用，强制bigint或decimal列以JavaScript字符串类型返回。默认为false dateStrings 强制timestamp、datetime、data类型以字符串类型返回，而不是JavaScript Date类型。默认为false debug 开启调试。默认为false multipleStatements 是否允许一个query中有多个MySQL语句。默认为false flags 用于修改连接标志 ssl 使用ssl参数或一个包含ssl配置文件名称的字符串 mysql模块CRUD// 执行查询 connection.query('SELECT * FROM t_user', function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('SELECT result is: ', results); &#125;); // 插入数据 // 其中，在SQL语句中，通过“?”占位符的方式将参数对象data进行传入。 var data = &#123; user_id: 2, username: 'waylau' &#125;; connection.query('INSERT INTO t_user SET ?', data, function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('INSERT result is: ', results); &#125;); // 更新数据 // 通过“?\"占位符的方式将参数对象进行传入。所不同的是，参数对象是一个数组。 connection.query('UPDATE t_user SET username = ? WHERE user_id = ?', ['Way Lau', 2], function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('UPDATE result is: ', results); &#125;); // 执行查询 // 同样也是通过“?占位符的方式将参数对象进行传入。所不同的是，参数对象是一个数值（用户ID)。 connection.query('SELECT * FROM t_user', function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('SELECT result is: ', results); &#125;); mysql连接池建议将连接池的pool.getConnection封装一下，实现复用 const express = require('express'); const app = express(); const port = 8080; const bodyParser = require('body-parser');//用于req. const URL = '/api/users'; const mysql = require('mysql'); // 连接信息. // 使用连接池 const pool = mysql.createPool(&#123; connectionLimit: 4, // 连接数限制 host: 'localhost', user: 'root', password: '123456', database: 'nodejs_book' &#125;); app.use(bodyParser.json()); // 获取所有用户列表API app.get(URL + '/', function (req, res) &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户ID let name = req.query.name; console.log('User name is: ', name); if (name == null) &#123; // 执行查询 connection.query('SELECT * FROM t_user', function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125; else &#123; // 执行查询 connection.query('SELECT * FROM t_user where username = ?', name, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印查询结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125; &#125;); &#125;); // 获取指定ID的用户API app.get(URL + '/:id', function (req, res) &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户ID let id = req.params.id; console.log('User id is: ', id); // 执行查询 connection.query('SELECT * FROM t_user where user_id = ?', id, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 取第一个，转为JSON返回 res.json(results[0]).end(); &#125;); &#125;); &#125;); // 创建用户信息API app.post(URL + '/', (req, res) => &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户信息 let username = req.body.username; console.log('User is: ', username); // 执行查询 connection.query('INSERT INTO t_user (username) VALUES (?)', username, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125;); &#125;); // 更新用户信息API app.put(URL + '/', (req, res) => &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户信息 let user_id = req.body.user_id; let username = req.body.username; console.log('User id is: ', user_id); console.log('User name is: ', username); // 执行查询 connection.query('UPDATE t_user SET username = ? WHERE user_id = ? ', [username, user_id], function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125;); &#125;); // 删除指定ID的用户API app.delete(URL + '/:id', (req, res) => &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户ID let id = req.params.id; console.log('User id is: ', id); // 执行查询 connection.query('DELETE FROM t_user WHERE user_id = ? ', id, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125;); &#125;); app.listen(port, () => console.log(`Server listening on port $&#123;port&#125;!`)); RedisRedis是一个高性能的key-vale缓存数据库 Redis支持主从同步，可以从主服务器向任意数量的从服务器上同步数据，从服务器可以是关联其他从服务器的主服务器。这使得 Redis可执行单层树复制，存盘可以有意无意地对数据进行写操作。由于完全实现了发布&#x2F;订阅机制，使得从数据库在任何地方进行数据同步时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 Redis不仅仅是简单的key-value存储，更是一个data strutures server（数据结构服务器)，用来支持不同的数值类型。在key-value中，value不仅仅局限于string类型，它可以是更复杂的数据结构。 二进制安全的string。 List: 一个链表，链表中的元素按照插入顺序排列。 Set: string 集合，集合中的元素是唯一的，没有排序。 Sorted set: 与Set类似，但是每一个string 元素关联一个浮点数值，这个数值被称为Score。元素总是通过它们的Score进行排序，所以不像Set那样可以获取一段范围的元素（例如，获取前10个，或者后10个)。 Hash: 指由关联值字段构成的 Map。字段和值都是string。 Bit array（或者简单称为Bitmap): 像位数值一样通过特别的命令处理字符串，可以设置和清除单独的bit，统计所有bit集合中为1的数量，查找第一个设置或没有设置的bit等。 HyperLogLogs: 这是一个概率统计用的数据结构，可以用来估计一个集合的基数。对于所有的例子，我们都使用redis-cli工具来演示。这是一个简单但非常有用的命令行工具，可以用来给Redis Server 发送命令。 Redis超时Redis超时是 Redis的一个特性之一，这个特性可以用在任何一种值类型中。可以给一个key设置一个超时时间，这个超时时间就是有限的生存时间。当生存时间过去，这个key就会自动被销毁。 在设置超时时间时，可以使用秒或毫秒。 超时时间一般总是1ms。 超时信息会被复制，并持久化到磁盘中。当Redis服务器停止时(这意味着Redis将保存key 的超时时间)。 node.js操作redis使用redis模块操作redis redis.createClient()用于创建客户端。 client.set()方法设置单个值。 client.hset()方法用于设置多个字段。 client.hkeys()方法用于返回所有的字段。 client.get()和client.hgetall()方法都用于获取key 所对应的值。 client.quit()用于关闭连接。 const redis = require(\"redis\"); // 创建客户端 const client = redis.createClient(6379, '127.0.0.1'); // 如果没有密码，则不需要这一步 client.auth(123456) // // 错误处理 client.on(\"error\", function (err) &#123; console.log(\"Error \" + err); &#125;); client.on('connect', function()&#123; // 设值 client.set(\"hello\", \"this is a value\"); // 把存储对象改成JSON对象 程序将会报错，因为Redis 中存储的是字符串对象 client.set('test', &#123; user_name: 'yolo', age: 18&#125;) // 重写toString 即可方法: // object.prototype.tostring = function ()&#123; // return JSON.stringify(this); // &#125;; &#125;) // 设值 client.set(\"书名\", \"《Node.js企业级应用开发实战》\", redis.print); // 同个key不同的字段 client.hset(\"柳伟卫的Spring三剑客\", \"第一剑\", \"《Spring Boot 企业级应用开发实战》\", redis.print); client.hset(\"柳伟卫的Spring三剑客\", \"第二剑\", \"《Spring Cloud 微服务架构开发实战》\", redis.print); client.hset([\"柳伟卫的Spring三剑客\", \"第三剑\", \"《Spring 5 开发大全》\"], redis.print); // 返回所有的字段 client.hkeys(\"柳伟卫的Spring三剑客\", function (err, replies) &#123; console.log(\"柳伟卫的Spring三剑客共\" + replies.length + \"本:\"); // 遍历所有的字段 replies.forEach(function (reply, i) &#123; console.log(\" \" + i + \": \" + reply); &#125;); &#125;); // 获取key所对应的值 client.get(\"书名\", function (err, reply) &#123; console.log(reply); &#125;); // 获取key所对应的值 client.hgetall(\"柳伟卫的Spring三剑客\", function (err, reply) &#123; console.log(reply); // 退出 client.quit(); &#125;); // 清除数据 client.del('key') 异常处理 使用process.on(&#39;uncaughtException&#39;, function(err)&#123;&#125;)就不会造成接口崩溃了，可惜的是，很多应用在开发时都没有做这样的基本处理，因此都出现了问题，捕获那些咱没有 try-catch 的异常错误。// 相对于异常来说，内存泄漏也是一个不能忽视的严重问题，而process.on('uncaughtException')的做法很难保证不造成内存的泄漏。 // 所以当捕获到异常时，显式地手动杀掉进程并重启Node进程，既可以保证释放内存，又保证了服务后续的正常可用。 process.on ('uncaughtException', (e)=>&#123; console.error('process error is:', e.message); process.exit(1); restartServer(); //重启服务 &#125;); try&#x2F;catch&#x2F;finally，当我们去读取文件遇到异常时，抛出的异常会被try&#x2F;catch捕获，当前的线程就不会英文异常而意外结束了。 async&#x2F;await和promise是无法捕获异步代码的异常的，如下例子，无法捕获setTimeout异步代码里的异常new Promise((resolve, reject) =>&#123; setTimeout(() => &#123; throw new Error('error'); &#125;, 100); &#125;).then(() =>&#123; // 一些逻辑代码 &#125;).catch ((e) =>&#123; console.log('能进来说明可以处理异常信息了'); console.log(e); &#125;); fs.readFile('test.txt', function(err, data)&#123; try&#123; if(err) throw err; // ... &#125;catch(e)&#123; console.log(e) &#125;finally&#123; &#125; &#125;) nodejs里约定，同步的代码才能捕获异常，异步的代码不能直接使用try、catch 先看同步代码可以捕获的异常const testFunc = function() &#123; return new Promise((resolve, reject) => &#123; throw new Error('error'); &#125;); &#125;; async function testAsync() &#123; try &#123; await testFunc(); &#125; catch (e) &#123; console.log('能进来，说明异常能处理'); console.log(e); &#125; &#125; testAsync(); 异步代码无法捕获异常const testFunc = function() &#123; setTimeout(() => &#123; console.log(1111); return new Promise((resolve, reject) => &#123; throw new Error('error'); &#125;); &#125;, 100); &#125;; async function testAsync() &#123; try &#123; await testFunc(); &#125; catch (e) &#123; console.log('能进来，说明异常能处理'); console.log(e); &#125; &#125; testAsync(); 进程崩溃时重启进程因异常退出是很常见的事，当遇到崩溃退出的时候，重启就可以了。负责进程崩溃应用自动重启的模块有： forever模块，forever处理crash事件，再开启新的node进程（很少用了，基本都用pm2模块） pm2模块，支持所有的forever的功能，功能强大，比如0秒切换。 npm i pm2 -g pm2 start app.js 大集群：多台机器为了应对大流量，需要多台机器进行集群处理，因此可以通过负载均衡策略将流量分发到各个机器上，通过消除单点故障提升应用系统的可用性。常见的集群处理方式是使用Nginx或HAProxy。 参考 Node.js的底层原理 Node.js 技术架构 .env 文件原理 Node.js子进程 NodeJS中的事件（EventEmitter 书栈网node.js教程 《Node.js12 实战》 《Node.js 企业级应用开发实战》 《狼叔卷1》 《狼叔卷2》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"}]},{"title":"TypeScript 知识汇总","slug":"front_end/typescript","date":"2021-12-27T18:32:14.000Z","updated":"2022-07-08T14:26:34.275Z","comments":true,"path":"2021/12/28/front_end/typescript/","link":"","permalink":"http://example.com/2021/12/28/front_end/typescript/","excerpt":"","text":"TypeScript 基本使用 2021 typescript史上最强学习入门文章 如何优雅地在 React 中使用TypeScript React 中完美运用 TypeScript 工具类型PartialPartial&lt;T&gt; 将类型的属性变成可选，只支持处理第一层的属性 type Partial&lt;T> = &#123; [key in keyof T]?: T[key] &#125; DeepPartialDeepPartial&lt;T&gt; 将类型的属性变成可选，只支持多层的属性 type DeepPartial&lt;T> = &#123; [key in keyof T]?: T[key] extends object ? DeepPartial&lt;T[key]> : T[key] &#125; RequiredRequired&lt;T&gt;将类型的属性变成必选 type Required&lt;T> = &#123; [key in keyof T]-?: T[key] &#125; ReadonlyReadonly&lt;T&gt; 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。只对一级的属性做限制不能修改，如果是引用类型，还是可以修改的。 type Readonly&lt;T> = &#123; readonly [key in keyof T]: T[key] &#125; Pick（挑选）Pick 从某个类型中挑出一些属性出来 type Pick&lt;T, K extends keyof T> = &#123; [key in K]: T[key] &#125; Record（转化）Record&lt;K extends keyof any, T&gt; 的作用是将 K 中所有的属性的值转化为 T 类型。 type Record&lt;K extends keyof any, T> = &#123; [key in K]: T &#125; interface PageInfo &#123; title: string; &#125; type Page = \"home\" | \"about\" | \"contact\"; const x: Record&lt;Page, PageInfo> = &#123; about: &#123; title: \"about\" &#125;, contact: &#123; title: \"contact\" &#125;, home: &#123; title: \"home\" &#125;, &#125;; Exclude（移除）Exclude&lt;T, U&gt; 的作用是将某个类型中属于另一个的类型移除掉。如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型。最终实现的效果就是将 T 中某些属于 U 的类型移除掉。 type Exclude&lt;T, U> = T extends U ? never : T; // 例子 type T0 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\" type T1 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\" type T2 = Exclude&lt;string | number | (() => void), Function>; // string | number Extract（公共）Extract&lt;T, U&gt; 的作用是从 T 中提取出 U，提取公共部分。 type Extract&lt;T, U> = T extends U ? T : never; type T0 = Extract&lt;\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\" type T1 = Extract&lt;string | number | (() => void), Function>; // () =>void Omit（差集）Omit&lt;T, K extends keyof any&gt; 的作用是使用 T 类型中除了 K 类型的所有属性，来构造一个新的类型。 type Omit&lt;T, K extends keyof any> = Pick&lt;T, Exclude&lt;keyof T, K>>; interface Todo &#123; title: string; description: string; completed: boolean; &#125; type TodoPreview = Omit&lt;Todo, \"description\">; const todo: TodoPreview = &#123; title: \"Clean room\", completed: false, &#125;; NonNullableNonNullable&lt;T&gt; 的作用是用来过滤类型中的 null 及 undefined 类型。 type NonNullable&lt;T> = T extends null|undefined ? never : T type T0 = NonNullable&lt;string | number | undefined>; // string | number type T1 = NonNullable&lt;string[] | null | undefined>; // string[] ParametersParameters&lt;T&gt;的作用是用于获得函数的参数类型组成的元组类型。 type Parameters&lt;T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never; type A = Parameters&lt;() =>void>; // [] type B = Parameters&lt;typeof Array.isArray>; // [any] type C = Parameters&lt;typeof parseInt>; // [string, (number | undefined)?] type D = Parameters&lt;typeof Math.max>; // number[] ReturnType获取函数的返回值的类型 type ReturnType&lt;T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any; type E = ReturnType&lt;() => string> // E的类型是string tsconfig.json介绍tsconfig.json 是 TypeScript 编译的相关配置，用于描述将TS转化为JS代码的配置文件，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。 生成tsconfig.js文件：tsc --init 查看更多配置和使用说名: tsc -h 应当将tsc作为类型检查工具，而不是编译项目的工具，代码编译的工作应该交给babel、webpack等工具 tsconfig.json 重要字段 files，设置需要编译的单个文件的列表； // 只编译 src下的 index.ts文件 &#123; \"files\": [\"src/index.ts\"] &#125; include，设置需要进行编译的文件或者目录，支持路径模式匹配；include和files会合并 // 编译src所有的ts文件 // 支持通配符，只编译src下的一级目录的ts文件，如\"src/*\"，二级文件 \"src/*/*\" &#123; \"include\": [\"src\"] &#125; exclude，排除不需要进行编译的文件，支持路径模式匹配（排除）；默认排除node_modules下的所有文件、排除所有声明文件(xxx.d.ts)，只对include字段有排除效果，对file字段无影响。 // 排除src/lib的文件编译 &#123; \"include\": [\"src/lib\"] &#125; extends，导入或者继承其他tsconfig配置 // 导入当前目录下的tsconfig.base.json里的配置，但是导入的配置容易被覆盖（在tsconfig.json可以覆盖导入的配置） &#123; \"extends\": \"./tsconfig.base.json\" &#125; compileOnSave: true, 保存文件时自动触发tsc编译文件（VScode不支持这个配置），一般来说，代码编译过程会通过webpack等打包构建工具，并且使用热更新，因此一般不需要配置该项。 compilerOptions，设置与编译流程相关的选项。 如果ts.config文件为空，则会按照默认是编译当前目录下的所有ts文件。 compilerOptions 选项&#123; \"compilerOptions\": &#123; \"tsBuildInfoFile\": './buildFile', // 指定编译后的文件放在哪里 /* 基本选项 */ \"target\": \"es5\", // 指定编译后ECMAScript目标版本: 要将ts编译成js哪个版本的语法，'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制只能引用当前目录下的ts文件. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": &#123;&#125;, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 &#125; &#125; TypeScript 面试 TypeScript 面试题 TypeScript 面试题及答案","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"React Hooks 总结","slug":"front_end/reacthooks","date":"2021-07-14T12:02:11.000Z","updated":"2022-07-10T09:29:39.454Z","comments":true,"path":"2021/07/14/front_end/reacthooks/","link":"","permalink":"http://example.com/2021/07/14/front_end/reacthooks/","excerpt":"","text":"为什么要设计Hooks，Hooks有什么优势？ 解决了 Class 组件存在的一些代码冗余、难以逻辑复用的问题，替代了高阶组件的负担，能够让代码更加容易理解和维护。 让函数组件拥有类组件的一些特性，内部状态（useState）和类似 class 组件的生命周期（useEffect）。 函数组件和类组件本质的区别是？ Class组件，底层只需要实例化一次，实例中保存了组件的 state 状态。对于每一次更新只需要调用 render 方法以及对应的生命周期就可以了。 Function组件，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量会重新声明。React 对函数组件的调用，是采用直接执行函数的方式，而不是通过new的方式。 使用Hooks需要注意的地方 只在 function 组件和自定义 hooks 中使用 hooks。 不能将 hooks 放在循环、条件语句或者嵌套方法内执行，原因是 react 是根据 hooks 出现顺序来记录对应状态的。 useStateuseState基本使用useState的参数可以是任意的值，也可以是一个函数，函数的返回值作为其初始值。 const [count, setCount] = useState(initialState) const [state, setState] = useState(() => &#123; // 初始化initialState return initialState; &#125;) useState 返回值为一个数组，数组的第一个参数为我们需要使用的 state，第二个参数为更新state的函数 setCount(0) // 需要获取上一个state的值 setCount(prevCount => prevCount + 1) // state为对象时 setState(prevState => (&#123; ...prevState, attr: 'value' &#125;)) // state为数组时 setArr((arr) => &#123; arr.push(5) return [...arr] &#125;) useState为什么返回的是一个数组而不是一个对象？简单来说，数组解构是有顺序的，开发者可自定义名称，对象解构是根据对象的key解构。 useState的实现原理 第一次渲染时候，根据 useState 顺序，逐个声明 state 并且将其放入全局 Array 中。每次声明 state，都要将 count 增加 1。 更新 state，触发再次渲染的时候，count 被重置为 0。按照 useState 的声明顺序，依次拿出最新的 state 的值，视图更新。 const stateArr = []; // 多个状态，保存在一个全局容器 Array 中 let count = 0; function useState(initialState) &#123; const curCount = count; stateArr[curCount] = stateArr[curCount] || initialState; // 检查是否渲染过 function dispatch(newState) &#123; stateArr[curCount] = newState; render(); // 调用函数组件的render方法 &#125; ++count; // update: count return [stateArr[curCount], dispatch]; &#125; useEffectuseEffect(effect, deps); 第一个参数为 effect 副作用函数，副作用函数返回值是一个回调函数returnFunction，这个回调函数不只是会在组件销毁时执行，而且是每次 Effect 重新执行之前都会先执行returnFunction，用于清理上一次 effect 的执行结果。 每次组件 render 完成后，会根据deps里的依赖，是否要执行 effect 第二个参数 deps 依赖的不同情况 没有依赖项，则每次 render 后都会重新执行，如果存在returnFunction则先执行returnFunction，再触发 effect（componentDidUpdate） 空数组作为依赖项，则只在第一次 render 后执行，对应到 Class 组件就是 componentDidMount returnFunction 用于在组件销毁的时候做一些清理的操作，比如移除事件的监听、定时器的清除（componentWillUnmount） 依赖项中定义的变量一般是会在回调函数中用到的，否则声明依赖项其实是没有意义的。 React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。（deps为非原始类型时，每次渲染都会发生改变） 不要把 effect 写成一个 async 函数，useEffect 中约定 Effect 函数要么没有返回值，要么返回一个函数， async 函数会隐式地返回一个 Promise，直接违反了这一约定，会造成不可预测的结果。 useEffect的实现原理在 useEffect 的第二个参数中，我们可以指定一个数组，如果下次渲染时，数组中的元素没变，那么就不会触发这个副作用 // 利用 Array + Count 的思路，不包括销毁副作用功能的 useEffect 的实现 const allDeps = []; let effectCount = 0; function useEffect(callback, deps) &#123; if (!allDeps[effectCount]) &#123; // 初次渲染：赋值 + 调用回调函数 allDeps[effectCount] = deps; ++effectCount; callback(); return; &#125; const currEffectCount = effectCount; const rawDeps = allDeps[currEffectCount]; // 检测依赖项是否发生变化，发生变化需要重新render const isChanged = rawDeps.some( (dep, index) => dep !== deps[index] ); if (isChanged) &#123; callback(); &#125; ++effectCount; &#125; function render() &#123; ReactDOM.render(&lt;App />, document.getElementById(\"root\")); effectCount = 0; // 注意将 effectCount 重置为0 &#125; useLayoutEffectuseLayoutEffect(effect, deps); useLayoutEffect 与 useEffect 使用方法一样，只是执行回调函数的时机不同。useLayoutEffect在浏览器执行绘制之前执行（会阻碍浏览器 paint，慎用），只有当我们需要进行DOM的操作时才使用该函数。 useLayoutEffect(() => &#123; console.log('useLayoutEffect————2') return () => &#123; console.log('组件卸载了：useLayoutEffect————1') &#125; &#125;, [deps]) useEffect(() => &#123; console.log('useEffect————4') return () => &#123; console.log('组件卸载了：useEffect————3') &#125; &#125;, [deps]) // 监听的状态发生改变时： useLayoutEffect返回的函数（1） ——> useLayoutEffect（2） ——> useEffect返回的函数（3） ——> useEffect（4） useMemo 第一个参数为一个回调函数，该函数返回一个缓存的值 第一个参数为依赖项，依赖的值发生变化时，回调函数才会重新计算缓存数据 这样避免在每次重新渲染时都进行复杂的数据计算 function Counter(&#123; countA, countB&#125;) &#123; const sum = useMemo(() => &#123; // ... 只有当countA 或 countB变化时才重新计算count return countA + countB; &#125;, [countA, countB]); return ( &lt;div>&#123;sum&#125;&lt;/div> ) &#125; useMemo的实现原理function useMemo(fn, deps)&#123; return useCallback(fn(), deps) &#125; momo上个例子中，只要父组件render方法执行，Counter函数依旧会触发重新渲染，要让函数不执行，在最外层加上memo const Counter = memo((&#123; countA, countB&#125;) => &#123; const sum = useMemo(() => &#123; // ... 只有当countA 或 countB变化时才重新计算count return countA + countB; &#125;, [countA, countB]); return ( &lt;div>&#123;sum&#125;&lt;/div> ) &#125;) useCallback useCallback 的用法和 useMemo 类似，只有依赖项发生变化的时候，才需要重新创建一个回调函数，这样就保证了组件不会创建重复的回调函数。 接收这个回调函数作为属性的组件，也不会频繁地需要重新渲染。 useCallback(fn, deps) 等同于 useMemo(() =&gt; fn, deps) // 这样， function Counter() &#123; const [count, setCount] = useState(0); const handleIncrement = useCallback(() => setCount(count + 1), [count]); // ... return &lt;button onClick=&#123;handleIncrement&#125;>+&lt;/button> &#125; useCallback实现原理let memoizedState = null function useCallback(callback, deps) &#123; const nextDeps = (deps !== undefined ) &amp;&amp; (deps !== null) ? deps : [callback] const prevState = memoizedState; if (prevState !== null) &#123; const prevDeps = prevState[1] if (areHookdepsEqual(nextDeps, prevDeps)) &#123; return prevState[0] &#125; &#125; memoizedState = [callback, nextDeps] return callback &#125; useRef 组件的引用：返回一个可变的 ref 对象，该对象下面有一个 current 属性指向被引用对象的实例，当做 ref 正常使用时，和 createRef 效果一样。 useRef 返回的 ref 对象在组件的整个生命周期内保持不变，useRef 每次都会返回相同的引用，createRef 每次渲染都会重新创建 ref import &#123; React, useRef, createRef&#125; from 'react' const App = () => &#123; const inputElement = createRef() const flieElement = useRef(); if (!inputElement.current) &#123; console.log('inputElement') // 函数重新执行时，每一次都打印 &#125; if (!flieElement.current) &#123; console.log('flieElement') // 只打印第一次 &#125; // flieElement.current.click() 上传文件 // inputElement.current.focus() 聚焦 return ( &lt;> &lt;input type='text' ref=&#123;inputElement&#125; /> &lt;input type='flie' ref=&#123;flieElement&#125; /> &lt;/> ) &#125; useRef 可以拿到最新的值， current 指向初始化为传入的参数，可以存放任何变量 const refVal = useRef(value); // refVal.current => value const [count, setCount] = useState(value) const newCount = useRef() new.current = count useImperativeHandle useImperativeHandle 一般和 forwardRef 一起使用的，减少暴露给父组件的属性 forwardRef的作用是：引用父组件的 ref 实例，成为子组件的一个参数，可以引用父组件的 ref 绑定到子组件自身的节点上。它有两个参数，第一个是父组件传递的 props，第二个就是 ref 的引用 forwardRef((props, ref) => &#123; // 父组件传来的 ref return ( &lt;input ref=&#123;ref&#125;>&lt;/input> ) &#125;) useImperativeHandle 有三个参数： 第一个参数，接收一个通过 forwardRef 引用父组件的 ref 实例。 第二个参数一个回调函数，返回一个对象，对象里面存储需要暴露给父组件的属性或方法。 第三个参数为一个可选参数，该参数是一个依赖项数组deps。 function Example(props, ref) &#123; const inputRef = useRef() useImperativeHandle(ref, () => (&#123; // 父组件可以通过this.xxx.current.focus的方式使用子组件传递出去的focus方法 focus: () => &#123; inputRef.current.focus() &#125; &#125;)) return &lt;input ref=&#123;inputRef&#125; /> &#125; export default forwardRef(Example) // 父组件 class App extends Component &#123; constructor(props)&#123; super(props) this.inputRef = createRef() &#125; render() &#123; return ( &lt;> &lt;Example ref=&#123;this.inputRef&#125;/> &lt;button onClick=&#123;() => &#123;this.inputRef.current.focus()&#125;&#125;>Click&lt;/button> &lt;/> ) &#125; useReducer useReducer是useState 的一种替代方案，它接收三个参数，第一个参数为一个 reducer 函数，第二个参数是reducer的初始值，第三个参数为可选参数，值为一个函数，可以用来惰性提供初始状态。 reducer 函数接受两个参数一个是 state 另一个是 action ，用法原理和 redux 中的 reducer const [state, dispatch] = useReducer(reducer, initialArg, init) function init(initialCount) &#123; return &#123;count: initialCount&#125;; &#125; function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; case 'reset': return init(action.payload); default: throw new Error(); &#125; &#125; function Counter(&#123;initialCount&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;> Count: &#123;state.count&#125; &lt;button onClick=&#123;() => dispatch(&#123;type: 'reset', payload: initialCount&#125;)&#125; > Reset &lt;/button> &lt;button onClick=&#123;() => dispatch(&#123;type: 'increment'&#125;)&#125;>+&lt;/button> &lt;button onClick=&#123;() => dispatch(&#123;type: 'decrement'&#125;)&#125;>-&lt;/button> &lt;/> ); &#125; function render () &#123; ReactDOM.render(&lt;Counter initialCount=&#123;0&#125; />, document.getElementById('root')); &#125; useContext 定义全局状态，当这个 Context 的数据发生变化时，使用这个数据的组件就能够自动刷新 React 的开发中，我们很少会使用 Context 来做太多数据的共享，Context 更多的是提供了一个强大的机制，让 React 应用具备定义全局的响应式数据的能力。主要是用来实现 Theme(主题)、Language (多语)等功能 const globalContext = React.createContext() function App()&#123; return ( &lt;globalContext.Provider value=&#123;'light'&#125;> &lt;Count /> &lt;/globalContext.Provider> ) &#125; function Count(props) &#123; const context = useContext(globalContext) return ( &lt;div> &#123;context&#125; // light &lt;/div> ) &#125; 参考 React Hooks 使用总结 useEffect 完整指南 React Hooks 原理","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【webpack】手写loader和plugin","slug":"engineering/loader-and-plugin","date":"2021-03-24T12:10:21.000Z","updated":"2022-07-08T17:48:18.429Z","comments":true,"path":"2021/03/24/engineering/loader-and-plugin/","link":"","permalink":"http://example.com/2021/03/24/engineering/loader-and-plugin/","excerpt":"","text":"loader loader的作用：loader可以看成为一个转换器，将非js&#x2F;json的文件转化为可执行的JS字符串。 loader本质上是一个函数，上一个loader处理完source之后会把处理结果传给下一个loader来处理。 loader执行的顺序是在use数组内从右到左（从后往前） Compose(webpack采用的函数组合)：compose = (f, g) =&gt; (...args) =&gt; f(g(...args)) 手写清除console的loader参考文档: 手写清除console的loader 手写loader源码// 路径 /loaders/console-loader/index.js /** * 手写清除console的loader * 参考：https://juejin.cn/post/7038413043084034062 * loader实际上就是一个函数，但他不能是一个箭头函数，因为它需要继承webpack的this。 * 多个loader是从右向左调用，上一个loader将结果返回给下一个loader使用 * 输入输出都是字符串或者二进制数据，在loader函数中直接返回数字类型，会报错 */ // webpack5 已经可以通过this.query直接获取loader的options配置，所以不需要利用loader-utils工具获取 // webpack5 内置了terser-webpack-plugin，如果使用的是webpack5，同时需要自定义配置，那么仍需要安装terser-webpack-plugin // uglifyjs-webpack-plugin只支持ES5，terser-webpack-plugin支持ES6，压缩js，清除console前缀的语句 // source：表示当前要处理的内容 const reg = /(console.log()(.*)())/g; // Webpack5在loader的上下文中，会带有内置的this.getOptions方法 function ConsoleLoader(source) &#123; const &#123; data &#125; = this.query; console.log('data', data) // 通过正则表达式将当前处理内容中的console替换为空字符串 source = source.replace(reg, \"\") // 再把处理好的内容return出去，坚守输入输出都是字符串的原则，并可达到链式调用的目的供下一个loader处理 return source; &#125; module.exports = ConsoleLoader; 在webpack.config.js中使用该loaderconst path = require('path'); module.exports = &#123; mode: 'development', entry: path.join(__dirname, 'src/index.js'), output: &#123; path: path.join(__dirname, 'dist'), filename: 'index.js', &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: &#123; // path.resolve(__dirname, 'loaders/console-loader/index.js') loader: 'console-loader', options: &#123; data: \"console-loader\" &#125; &#125; &#125; ] &#125;, resolveLoader: &#123; modules: ['node_modules', path.resolve(__dirname, 'loaders')] &#125; &#125; pluginplugins是增强webpack功能，打包输出js文件（bundle）的一个优化，作用于整个构建过程。可以理解为任何loader没办法做的事情，都可以用plugins去完成。 手写一个md转成html的plugin如何创建 Plugin参考：手把手带你入门WebpackPlugin const pluginName = 'md-to-html-plugin'; class MdToHtmlPlugin &#123; apply(compiler) &#123; // 代表开始读取 records 之前执行 compiler.hooks.emit.tap(pluginName, (compilation) => &#123; console.log(\"webpack 构建过程开始！\"); // _assets 打包的资源详情 const _assets = compilation.assets; &#125;); &#125; &#125; compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例； webpack会提供一个apply方法，接受一个编译器compiler，编译的时候都是在apply里执行，是执行具体的插件方法。 apply 方法的入参注入了一个 compiler 实例，compiler 实例是 Webpack 的支柱引擎，代表了 CLI 和 Node API 传递的所有配置项。 compiler会有钩子hooks，钩子hooks会有一个发布器emit（类似node的EmitterEvent发布订阅）tap第一个参数是插件的名字，第二个参数是回调函数，回调函数的参数是一个compilation。 compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 compilation 将被创建。compilation 对象也提供了很多事件回调供插件做扩展。通过 compilation 也能读取到 Compiler 对象。Compilation 上的assets可以用于文件写入，可以将资源设置到compilation.assets对象上。 Hook 上还暴露了 3 个方法供使用，分别是 tap、tapAsync 和 tapPromise。这三个方法用于定义如何执行 Hook，比如 tap 表示注册同步 Hook，tapAsync 代表 callback 方式注册异步 hook，而 tapPromise 代表 Promise 方式注册异步 Hook。 常见Complier Hooks参考: webpack Hook type 调用 run AsyncSeriesHook 开始读取 records 之前 compile SyncHook 一个新的编译 (compilation) 创建之后 emit AsyncSeriesHook 生成资源到 output 目录之前 done SyncHook 编译 (compilation) 完成 实现MdToHtmlPlugin1、创建MdToHtmlPlugin在根目录下创建plugin文件夹，在plugin下新建md-to-html-plugin文件夹，并在该文件夹下新建index.js入口文件，compiler.js文件，constant.js声明常量文件，util.js公共方法文件，template.html模板文件 index.js文件const &#123; readFileSync &#125; = require('fs'); const &#123; resolve, dirname, join &#125; = require('path'); const &#123; compileHTML &#125; = require('./compiler'); const &#123; TEMPLATE_MARK, PLUGIN_NAME &#125; = require('./constant'); class MdToHtmlPlugin &#123; constructor(&#123; template, filename &#125;) &#123; // 没传template if (!template) &#123; throw new Error('Please input the markdown template file'); &#125; this.template = template; // 没传filename 默认为 index.html this.filename = filename ? filename : 'index.html'; &#125; apply(compiler) &#123; // tap第一个参数是插件的名字，第二个参数是回调函数，回调函数的参数是一个compilation compiler.hooks.emit.tap(PLUGIN_NAME, (compilation) => &#123; // _assets 打包的资源详情 const _assets = compilation.assets; // fs的api readFileSync 同步读取文件 readFile是异步的 const templateContent = readFileSync(this.template, 'utf-8'); // 目录文件，编码方式 // 将templateContent（md文件的内容） 变为数组 const templateContentArr = templateContent.split('\\n'); // 核心方法： 将数组内容 编译为 html标签 const &#123; htmlStr, staticSource &#125; = compileHTML(templateContentArr); // 找到当前目录下的template.html const templateHtml = readFileSync(resolve(__dirname, \"template.html\"), 'utf-8'); // 将template.html的模板字符串替换 const fileHtml = templateHtml.replace(TEMPLATE_MARK, htmlStr); // _assets增加资源，this.filename 就是_assets的一个属性 _assets[this.filename] = &#123; // source不是一个普通的函数，它会把放到_assets[this.filename]对象中 // 将资源放到我们定义filename的html文件中 source() &#123; return fileHtml; &#125;, // 资源的长度 size() &#123; return fileHtml.length; &#125; &#125; // 处理静态文件 if (staticSource &amp;&amp; staticSource.length > 0) &#123; // 获取md文件所在的目录 const tplDirName = dirname(this.template); staticSource.map((staticItem) => &#123; const &#123; filename, staticPath &#125; = staticItem; // 拼接md文件引用的静态资源路径 const staticsourcepath = join(tplDirName, staticPath); // 读取静态资源 const statics = readFileSync(staticsourcepath); // _assets增加资源 _assets[`$&#123;filename&#125;`] = &#123; source() &#123; return statics; &#125;, size() &#123; return statics.length; &#125; &#125; &#125;) &#125; &#125;) &#125; &#125; module.exports = MdToHtmlPlugin; index.js中做了哪些事件？ 读取md文件，用到了node内置模块fs的方法，将md内容存到为数组中； 将数组传入编译文件compiler的compileHTML中进行编译，返回html字符串和静态资源的路径，htmlStr如下： 读取template模板html文件，将文件内的模板替换为htmlStr 最后把html文件和静态资源放到_assets中，交由webpack处理 2、compiler模板编译文件// compiler.js const &#123; guid &#125; = require('./util'); const &#123; basename &#125; = require('path'); const &#123; REG_MARK, REG_TITLE, REG_ORDER, REG_DISORDER, REG_LINK, REG_IMG, TAGTYPE_SIMPLE, TAGTYPE_NESTING, REG_LINK_STYLE &#125; = require('./constant'); function createTree(tplArr) &#123; // 存放结果 let htmlTree = &#123;&#125;; // 上一个标识符 let lastMark = ''; let uid = 0; // 字符串相关的东西最好不要做封装，老老实实的写最好，不同的标签有不同的处理方法 tplArr.forEach((tplItem) => &#123; // 去掉\\r回车的影响 tplItem = tplItem.replace(/\\r/, ''); // 正则 const matched_mark = tplItem.match(REG_MARK); const matched_link = tplItem.match(REG_LINK); const matched_img = tplItem.match(REG_IMG); // 匹配到md语法，不为空 if (matched_mark) &#123; // matched_mark[1]就是去掉空格的 md标识 const mark = matched_mark[1]; // input就是匹配到的md语法，input: '# h1标题\\r' const input = matched_mark['input']; // 匹配到#号的 if (REG_TITLE.test(mark)) &#123; // 根据#号的个数 判断是h几 const tag = `h$&#123;mark.length&#125;`; //将'# h1标题\\r'中的'# '干掉，最终得到'h1标题\\r' const tagContent = input.replace(REG_MARK, '') // REG_TITLE.test(lastMark) if ((lastMark === mark)) &#123; htmlTree[tag].children = [...htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`], `&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; else &#123; lastMark = mark; uid = guid(); htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`] = &#123; type: TAGTYPE_SIMPLE, children: [`&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125; // 无序列表 if (REG_DISORDER.test(mark)) &#123; //将'- ul第一项\\r'中的'- '干掉，最终得到'ul第一项\\r' const tagContent = input.replace(REG_MARK, ''); const tag = `li`; // 上一个是不是`-` if (REG_DISORDER.test(lastMark)) &#123; // '- ul第i项\\r' 放到一起 htmlTree[`ul-$&#123;uid&#125;`].children = [...htmlTree[`ul-$&#123;uid&#125;`].children, `&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; else &#123; uid = guid(); lastMark = mark; // 加一个随机后缀key htmlTree[`ul-$&#123;uid&#125;`] = &#123; type: TAGTYPE_NESTING, // 外层需要一个ul children: [`&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125; // 有序列表 是不是以数字开头的，如果是数字开头，没有.呢？ if (REG_ORDER.test(mark)) &#123; const tagContent = input.replace(REG_MARK, ''); const tag = `li`; if (REG_ORDER.test(lastMark)) &#123; htmlTree[`ol-$&#123;uid&#125;`].children = [...htmlTree[`ol-$&#123;uid&#125;`].children, `&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; else &#123; lastMark = mark; uid = guid(); htmlTree[`ol-$&#123;uid&#125;`] = &#123; type: TAGTYPE_NESTING, children: [`&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125; &#125; else if (matched_link) &#123; // 超链接的处理 // '百度' const link_title = matched_link[1]; // 'http://www.baidu.com' const link_href = matched_link[2]; // '[百度](http://www.baidu.com)' const input = matched_link['input']; const tag = `a`; uid = guid(); htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`] = &#123; type: TAGTYPE_SIMPLE, children: [`&lt;$&#123;tag&#125; href=\"$&#123;link_href&#125;\" target=\"_blank\" style=\"$&#123;REG_LINK_STYLE&#125;\">$&#123;link_title&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; else if (matched_img) &#123; // 图片的处理 const tag = `img`; // '图片' const img_title = matched_img[1]; // 'public/testimages.png' const img_src = matched_img[2]; // 'testimages' const img_file = basename(img_src); uid = guid(); htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`] = &#123; type: TAGTYPE_SIMPLE, staticResources: &#123; filename: img_file, staticPath: img_src &#125;, children: [`&lt;$&#123;tag&#125; src=\"./$&#123;img_file&#125;\" alt=\"$&#123;img_title&#125;\">&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125;) return htmlTree; &#125; // 转成树形结构 或者AST function compileHTML(templateContentArr) &#123; // templateContentArr数组内容 // 转成树形结构 const htmlTree = createTree(templateContentArr) // static资源 const staticSource = []; // 拼接结果 let htmlStr = ''; // 保存当前遍历到的 key let currItem; for (let key in htmlTree) &#123; currItem = htmlTree[key]; htmlTree[key]?.staticResources &amp;&amp; staticSource.push(htmlTree[key]?.staticResources) // 等于single，直接拼接 if (currItem.type === TAGTYPE_SIMPLE) &#123; currItem.children.forEach(tag => &#123; htmlStr += tag; &#125;); &#125; else if (currItem.type === TAGTYPE_NESTING) &#123; // 外层要套一个标签的，不能直接拼接 // 获取外层的标签，就是htmlTree的key const outerTag_Start = `&lt;$&#123;key.split('-')[0]&#125;>`; const outerTag_End = `&lt;/$&#123;key.split('-')[0]&#125;>`; let currStr = \"\" + outerTag_Start; currItem.children.forEach(tag => &#123; currStr += tag; &#125;) // 结束标签 currStr += outerTag_End; htmlStr += currStr; &#125; &#125; return &#123; htmlStr, staticSource &#125;; &#125; module.exports = &#123; compileHTML &#125; compiler做了什么？ compileHTML方法中，调用createTree方法将数组转化为树形结构，htmlTree如下： createTree的作用 遍历数组，匹配不同的md标识符，如 #号代表标题，(num.)代表有序列表，(-)代表无序列表，![]()代表图片标识等，对不同的标识做不同的处理，如果是列表，需要在外层嵌套ul、ol。匹配md标识，用到了正则表达式。 如果是超链接，则设置a标签，设置a标签默认样式，href属性。 如果是图片，则设置img标签，获取图片的路径，设置src、alt等属性。 最后返回htmlTree 遍历htmlTree的所有value，如果是simple类型，则直接拼接结果，如果是nesting类型，则需要在外面嵌套ol、ul 最后返回处理结果htmlStr、staticSource。 3、其他文件说明constant.js// 以空字符串开头，以空格结尾，找到里边的所有字符 const REG_MARK = /^(.+?)\\s/; // 以#号开头的，最终转化成h标签，有可能是1个、2个、3个。。。 const REG_TITLE = /^\\#/; // 以数字开头 有序列表 const REG_ORDER = /^\\d/; // 以-开头的 最终转化成li const REG_DISORDER = /^\\-/; // 匹配 []() 超链接 const REG_LINK = /^\\[(.+?)\\]\\((.+?)\\)$/; // 匹配 []() 超链接 const REG_IMG = /^\\!\\[(.+?)\\]\\((.+?)\\)$/; // 简单类型 const TAGTYPE_SIMPLE = 'simple'; // 需要嵌套包裹 const TAGTYPE_NESTING = 'nesting'; // 超链接默认样式 const REG_LINK_STYLE = `color: #3489fd;font-weight: 500;text-decoration: none;` // 需要替换 模板html文件里的字符串 const TEMPLATE_MARK = '&lt;!--templateString-->'; // 插件名称 const PLUGIN_NAME = 'md-to-html-plugin'; module.exports = &#123; REG_MARK, REG_TITLE, REG_ORDER, REG_DISORDER, REG_LINK, REG_IMG, TAGTYPE_SIMPLE, TAGTYPE_NESTING, REG_LINK_STYLE, TEMPLATE_MARK, PLUGIN_NAME &#125; template.html util.js// 生成uid function guid() &#123; let res = \"\"; for (let i = 1; i &lt;= 8; i++) &#123; let n = Math.floor(Math.random() * 16.0).toString(16); res += n; &#125; return res; &#125; module.exports = &#123; guid &#125; 4、创建webpack.config.js文件在根目录下新建notebook.md，并写入简单的md标记，引入MdToHtmlPlugin插件，配置MdToHtmlPlugin的template和filename const &#123; resolve &#125; = require('path') const MdToHtmlPlugin = require('./plugins/md-to-html-plugin'); const config = &#123; // 模式 mode: \"development\", // 入口文件 entry: resolve(__dirname, 'src/app.js'), output: &#123; path: resolve(__dirname, 'dist'), filename: \"app.js\" &#125;, // 配置自定义插件 plugins: [ new MdToHtmlPlugin(&#123; template: resolve(__dirname, 'notebook.md'), // 我们需要解析的文件 filename: 'notebook.html' // 解析后的文件名 &#125;) ] &#125; module.exports = config; notebook.md文件内容如下： 5、调试和运行 执行 npm run build 在dist文件夹下输出打包后文件 打开notebook.html看结果","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]},{"title":"【webpack】如何成为一名webpack配置工程师","slug":"engineering/webpack-base","date":"2021-02-09T20:33:11.000Z","updated":"2022-07-09T03:02:13.997Z","comments":true,"path":"2021/02/10/engineering/webpack-base/","link":"","permalink":"http://example.com/2021/02/10/engineering/webpack-base/","excerpt":"","text":"Webpack基础为什么需要构建工具，它有什么作用？ 转换ES6语法：ES6语法在前端领域广泛使用，然而很多浏览器对ES6没有提供全面的兼容和支持，所以需要构建工具来对ES6语法进行编译。 转换JSX、vue指令：前端框架React的JSX，VUE指令都是浏览器无法识别的，需要编译转换。 CSS前缀补全，预处理器：经常使用less、sass等预编译语法写样式，需要构建工具做编译转化为CSS。 多媒体资源压缩：经常使用的图片、字体、图标等多媒体资源，需要构建工具对它们进行压缩，减少体积大小。 压缩混淆代码：当前的前端开发都是模块开发，也引入了大量的依赖包，为了让浏览器对代码的加载更快，需要构建工具对代码进行压缩和混淆。 Webpack基础知识 loader作用：webpack仅支持js和json文件，想对其他类型的文件打包需要使用loader，转化成为有效的模块。loader本身是一个函数，接受源文件作为参数，返回转换的结果，loader的执行顺序是从右往左。 plugins作用：plugins是增强webpack功能，是 bundle 的一个优化，干预输出的结果，作用于整个构建过程。可以简单理解为任何loader没办法做的事情，都可以用plugins去完成。 chunk和bundle：chunk是webpack打包过程中依赖，bundle是输出的产物。 基本的配置文件如下：// 为JSON模块使用具名导出，可能需要使用 package.json 中的一些字段 // package.json的 homepage 属性会告诉 webpack 项目的路径需要打包到哪个路径下，如github路径、CDN路径 import pkg from './package.json'; // console.log(pkg.version); const path = require('path'); module.exports = &#123; mode: 'development', // 模式：development、production、none entry: './src/index.js', // 打包入口地址 output: &#123; filename: 'bundle.js', // 输出文件名 path: path.join(__dirname, 'dist') // 输出文件目录 &#125; module: &#123; rules: [ ] &#125;, plugin: [] &#125; mode模式 名称 描述 development 开发模式，打包更加快速 production 生产模式，打包比较慢，会开启 tree-shaking、压缩代码和清除无用代码 none 不开启任何优化选项 development：更快的构建速度、热更新(hot)、快速定位问题(sourcemap ) production: 生产环境下会自动压缩js代码，构建体积小（代码压缩 + tree-shaking）、代码分割、压缩images。 webpack常用指令 webpack默认配置文件是根目录下的webpack.config.js，自定义配置打包文件的命令：webpack --config filename 监听变动并自动打包（文件监听是在发现源码发生变化时，自动重新构建出新的输出文件）： 方式一：在package.json的script命令添加：webpack --watch 方式二：在webpack.config.js中设置watch: true 压缩混淆代码：webpack -p 方便出错时能查阅更详尽的信息：webpack --display-error-details 让编译的输出内容带有进度和颜色：webpack --progress --colors 模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉：webpack-dev-server --hot inline选项会为入口页面添加热加载功能，即代码改变后重新加载页面（刷新浏览器）：webpack-dev-server --inline Webpack的整个生命周期Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口 根据配置中的 entry 找出所有的入口文件 编译模块 从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块被编译后的最终内容以及它们之间的依赖关系 完成模块编译 在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上过程中，在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，并且plugin可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 常见的loaders 名称 描述 babel-loader 转换ES6、ES7等JS新特性语法 css-loader 加载和解析.css文件，不会将样式加载到页面上 style-loader 将处理好的css以style标签形式添加到页面上 postcss-loader 添加CSS3部分属性的浏览器前缀（先添加前缀，再使用css-loader） less-loader 将less文件转换成css ts-loader 将TS转换成JS vue-loader 支持 Vue thread-loader 正常情况下webpack开一个进程打包，thread-loader作用是多进程打包JS和CSS file-loader 解决图片、字体、媒体等资源引入问题，并将资源copy到指定目录，默认为 dist url-loader url-loader内部使用了file-loader，可以设置较小的资源自动base64，多了一个limit的配置 raw-loader raw-loader可以将文件转化成字符串的形式导入 注意：webpack5内置了资源处理模块，file-loader、url-loader和raw-loader都可以不用安装 常见的plugins 名称 描述 HtmlWebpackPlugin 将打包好的bundle如js、css 文件可以自动引入到html中 mini-css-extract-plugin 将CSS从 bunlde文件里提取成一个独立的CSS文件(MiniCssExtractPlugin.loader) TerserPlugin 压缩JS，支持ES6，清除console（webpack5内置） splitchunksplugin 将chunks相同的模块代码提取成公共js CleanWebpackPlugin 自动清空打包目录 copyWebpackPlugin 将文件或者文件夹拷贝到构建的输出目录（webpack5内置） UglifyjsWebpackPlugin 压缩JS ZipWebpackPlugin 将打包出的资源生成一个zip包 基本的webpack配置 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 生成html模板 const MiniCssExtractPlugin = require('mini-css-extract-plugin'); // 将css单独提取 const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); // 压缩css const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin'); // 打包输出前清空文件夹 const path = require('path'); // 通过 process.env.NODE_ENV 获取当前环境 module.exports = &#123; mode: 'development', // production or development or none /** * 单入口entry: './src/js/index.js' * 多入口entry: &#123; key: 'value' &#125; * key可自定义，value是入口文件路径 */ entry: &#123; // 定义应用的入口点 src/app.js，并命名为 main main: path.resolve(__dirname, './src/app.js'), index: './src/js/index.js', // 输出index test: './src/js/test.js', // 输出test &#125;, /** * filename, path * [name].[hash:8].bundle.js、[name].[chunkhash:8].bundle.js * hash字段是根据每次编译compilation的内容计算所得、chunkhash是根据模块内容计算出的hash值 */ output: &#123; // 打包输出的文件名 // name是一个占位符，通过占位符确保文件名称的唯一，一般entry多入口使用占位符区分 filename: 'js/[name].[contenthash:10].js', // 10位hash值, name取原来的文件名 // 定义打包结果的输出位置build目录 path: path.resolve(__dirname, 'build'), // publicPath表示的是打包生成的index.html文件里面引用资源的前缀 // webpack5清除输出目录可用，无需安装clean-webpack-plugin clean: true &#125;, /** * test指定匹配规则 * use指定使用的loader名称 */ module: &#123; // 定义处理源文件的规则，rules 下会按顺序使用匹配的规则 rules: [ &#123; // 遇到 .js 结尾的文件则使用这个规则 test: /\\.js$/, // 忽略 node_modules 目录下的 js 文件 // 在配置 loader 的时候，我们需要更精确的去指定 loader 的作用目录或者需要排除的目录， // 通过使用 include 和 exclude 两个配置项 include: path.join(__dirname, 'src'), // 符合条件的模块进行解析 exclude: /node_modules/, // 排除符合条件的模块，不解析 use: [ /* 开启多线程打包。 进程启动大概为600ms，进程通信也有开销。 只有工作消耗时间比较长，才需要多线程打包 */ &#123; loader: 'thread-loader', options: &#123; workers: 2 // 进程2个 &#125; &#125;, &#123; // 使用 babel-loader 处理 js loader: 'babel-loader', // babel-loader 的一些选项 options: &#123; presets: [ '@babel/preset-env', // 确保 Babel 能够处理 JSX 语法 &#123; // 按需加载 useBuiltIns: 'usage', // 指定core-js版本 corejs: &#123; version: 3 &#125;, // 指定兼容性做到哪个版本浏览器 targets: &#123; chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' &#125; &#125; ], // babel 在转译 js 过程中时间开销比价大，将 babel-loader 的执行结果缓存起来，重新打包的时候，直接读取缓存 // 开启babel缓存, 第二次构建时，会读取之前的缓存, 速度会更快一点 cacheDirectory: true // 启用缓存，缓存位置： node_modules/.cache/babel-loader &#125;, &#125;, ] &#125;, &#123; test: /\\.css$/, /** * css-loader用于处理加载.css文件，并且转换成commonjs对象 * style-loader将样式通过&lt;style>标签插入到head中 */ use: [ // 'style-loader', // 以 style标签 添加到head MiniCssExtractPlugin.loader, // 将js中的css单独提取出来 'css-loader', // 将css文件整合到js文件中 ] &#125;, &#123; // 检测 less 文件 test: /\\.less$/, // 使用了三个 loader，注意执行顺序是数组的倒序 // 也就是先执行 less-loader ，将less转换成css use: [ // 'style-loader', MiniCssExtractPlugin.loader, // 缓存一些性能开销比较大的 loader 的处理结果，缓存位置：node_modules/.cache/cache-loader 'cache-loader', 'css-loader', // 'less-loader' &#123; loader: 'less-loader', options: &#123; sourceMap: true, // 替换某个属性值，如修改antd默认主题色@primary-color，入口文件样式引入@import '~antd/dist/antd.less'; modifyVars: &#123; '@primary-color': '#13c2c2', &#125; &#125; ], &#125;, &#123; // webpack 默认处理不了html中img图片 // 匹配 图片资源 test: /\\.(jpg|png|gif|jpeg)$/, // 通过 url-loader 或者 file-loader 处理图片资源 // url-loader内部使用了file-loader，可以设置较小的资源自动base64 // base64格式的图片 可打包在js中直接使用 loader: 'url-loader', options: &#123; // 图片大小小于8kb，就会被base64处理 // 优点: 减少请求数量（减轻服务器压力） // 缺点：图片体积会更大（文件请求速度更慢） limit: 8 * 1024, // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs // 解析时会出问题：[object Module] // 解决：关闭url-loader的es6模块化，使用commonjs解析 esModule: false, // 给图片进行重命名 // [hash:10]取图片的hash的前10位 // [ext]取文件原来扩展名 name: '[contenthash:10].[ext]', outputPath: 'imgs', &#125; &#125;, &#123; test: /\\.html$/, // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理） loader: 'html-loader' &#125;, // 打包其他资源(除了html/js/css资源以外的资源) &#123; // file-loader处理字体文件 // 排除css/js/html资源 test: /\\.(woff|woff2|ttf|eot|otf)$/, exclude: /\\.(css|js|html|less)$/, loader: 'file-loader', options: &#123; name: '[contenthash:10].[ext]', outputPath: 'media' &#125; &#125;, ], &#125;, plugins: [ // 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS），并配置了页面的 title new HtmlWebpackPlugin(&#123; title: 'Webpack Output', // 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS） template: './src/index.html', // 压缩html代码 minify: &#123; // 移除空格 collapseWhitespace: true, // 移除注释 removeComments: true &#125; &#125;), // 提取js中的css成单独文件 new MiniCssExtractPlugin(&#123; // 对输出的css文件进行重命名，如filename: 'css/built.css'，放到输出目录的css文件夹下 filename: '[name].[hash:8].css' &#125;), // 打包输出前清空文件夹clean-webpack-plugin（webpack5不需要） new CleanWebpackPlugin(), // 压缩css new OptimizeCssAssetsWebpackPlugin(), ], /* 1. 可以将node_modules中代码单独打包一个chunk最终输出（单入口） 2. 自动分析多入口文件的chunk中，有没有公共的文件。如果有会打包成单独一个chunk */ optimization: &#123; splitChunks: &#123; // 解决代码引入的复用问题，不会重复打包多次 chunks: 'all' &#125; &#125;, // 开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器） // 特点：只会在内存中编译打包，不会有任何输出 devServer只能在 开发环境使用，生产环境不需要 devServer: &#123; // 项目构建后路径 contentBase: resolve(__dirname, 'build'), // 启动gzip压缩 compress: true, // 端口号 port: 8888, // 自动打开浏览器 open: true, // 开启HMR功能(webpack优化配置) // 当修改了webpack配置，新配置要想生效，必须重新webpack服务 hot: true // HMR只能在 开发环境使用，生产环境不需要 &#125;, // 拒绝XXX包 被打包进来，再用cdn 引进来(在html中手动通过srcipt标签引入、link引入) // CDN内容分发网络，分布式存放静态资源，缓解服务器压力，就近获取资源，加快访问速度 // 某些包需要用cdn引入进来，就可以使用externals externals: &#123; // 拒绝jQuery被打包进来 jquery: 'jQuery' // jquery: '$' &#125;, devtool: 'eval-source-map' // source-map &#125;; babel（解析ES6、处理jsx） 解析ES6，需要在rules里面匹配js文件，并use: ‘babel-loader’。babel-loader是依赖babel的，需要在根目录创建babel的配置文件.babelrc。 需要安装@babel&#x2F;core、@babel&#x2F;preset-env、babel-loader babel-loader 使用 Babel 加载 ES2015+ 代码并将其转换为 ES5 @babel&#x2F;core Babel 编译的核心包 @babel&#x2F;preset-env Babel 编译的预设，可以理解为 Babel 插件的超集 // .babelrc &#123; // 一系列plugins的集合 \"presets\": [ \"@babel/preset-env\", // 增加ES6的babel preset配置，解析ES6 \"@babel/preset-react\", // 安装该依赖，并增加react的babel preset配置，解析react相关的语法，jsx // @babel/preset-typescript ], // 一个plugins对应一个功能 \"plugins\": [ // 处理 装饰器的使用 [\"@babel/plugin-proposal-decorators\", &#123; legacy: true &#125;], [\"@babel/plugin-proposal-class-properties\", &#123; loose: true &#125;], ] &#125; babel-plugin vs babel-preset（预设）Babel polyfill 常见配置对比 babel存在太多的plugin，实现某种功能，比如ES2015语法兼容时需要用到众多的插件。preset是plugin的集合，将多个plugin合并在一起（预设是插件的集合） 插件plugin和预设preset的执行顺序 plugin先执行，preset后执行 plugin集从前往后执行 preset集从后往前执行 @babel&#x2F;preset-env（官方提供），作用是根据 targets 的配置引入对应插件来实现编译和 polyfill，自动根据 targets 来引入需要的插件 所谓Polyfill就是这样解决API的兼容问题的，抹平差异化 官方给出了两种 polyfill 方案： babel-polyfill：会污染全局适合在业务项目中使用。（Babel7.4.0版本开始，babel&#x2F;polyfill 已经被废弃，推荐直接使用core-js） babel-runtime：不污染全局适合在组件或类库项目中使用。 开启 polyfill 功能要指定它的引入方式，也就是 useBuiltIns。设置为 usage 是在每个模块引入用到的，设置为 entry 是统一在入口处引入 targets 需要的。 polyfill 的实现就是 core-js，需要再指定下 corejs 版本，一般是指定 3 @babel&#x2F;preset-env 会导致多个模块重复注入同样的代码，会污染全局环境。解决这个问题就要使用 @babel&#x2F;plugin-transform-runtime 插件 这样就不会多个模块重复注入同样的实现代码了，而且 core-js 的 api 也不是全局引入了，变成了模块化引入。 这样就解决了 corejs 的重复注入和全局引入 polyfill 的两个问题 @babel&#x2F;plugin-transform-runtime 的功能，把注入的代码和 core-js 全局引入的代码转换成从 @babel&#x2F;runtime-corejs3 中引入的形式 @babel&#x2F;runtime-corejs3 就包含了 helpers、core-js、regenerator 这 3 部分 &#123; presets: [ ['@babel/preset-env', &#123; targets: 'chrome 30', debug: true, useBuiltIns: 'usage', corejs: 3 &#125;] ], plugins: [ ['@babel/plugin-transform-runtime', &#123; corejs: 3 // 插件也是处理 polyfill ，也就同样需要指定 corejs 的版本 &#125;] ] &#125; babel的原理babel是一个JS、JSX、TS 的编译器，能把新语法写的代码转换成目标环境支持的语法的代码 babel工作的三个步骤 解析：将源码解析为AST（词法解析和语法解析） 转换：旧AST转换成为新的AST（应用插件&#x2F;预设中，对AST节点增删改查的操作） 生成：根据AST生成源码（深度优先遍历AST生成转译后的源码） @bable&#x2F;core 内核@bable&#x2F;core类似一个调度器，并不直接实现功能细节，而是调度各模块插件去实现相关功能 @babel&#x2F;core的功能可以简单概况为 向外读取配置 &#x3D;&gt; 向内调度插件模块协同工作 &#x3D;&gt; 向外输出转译后的源码。详细版本如下： 加载配置文件，读取所需使用的插件、预处理器等等 调用@babel&#x2F;parser进行词法分析、语法分析后转换为AST 调用@babel&#x2F;traverse对AST进行遍历，并采用visitor模式应用配置项中的插件对AST进行转换 调用@babel&#x2F;generator生成源码和源码对应的sourceMap 解析（parse）解析的核心是：词法分析将源码分词、语法分析将分词后的源码按照JS语法逻辑转换为AST（抽象语法树）。 词法分析：简单理解为：将源码分割为不同种类，保留关键词（如function）、条件判断词（if&#x2F;else）、运算符、数字、字符串、空格等 语法分析：将词法分析生成的分词，组合为各类型的语法短语（抽象语法树AST） 转换（Traverser）转换器会遍历AST树，然后按照配置的插件对其中需要转换的节点进行操作 生成（generator）调度器调用generator插件将AST转译成源码 babel-clibabel官方提供的脚手架，允许你以命令行的方式运行babel $ npm install babel-cli -g ​ # 将示例js输出到编译后的js中 $ babel example.js -o compiled.js webpack文件监听的原理轮询判断文件的最后编辑时间是否变化，某个文件发生变化了，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeout. watch 和 watchOptions module.exports = &#123; // 默认是false，不开起监听 watch: true, watchOptions: &#123; // 默认为空，不监听的文件或者文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行，默认300ms aggregateTimeout: 300, // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒检查1次变化 // 间隔xxx秒检查一次变化 poll: 1000 &#125; &#125; 文件指纹打包后输出的文件名的后缀，如 index_0a4dfa7c33787eec103e.chunk.js中的0a4dfa7c33787eec103e hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改 chunkhash：对于 JS 文件，和 webpack 打包的 chunk 相关，不同的entry会生成不同的 chunkhash 值 contenthash：将根据资源内容创建出唯一 hash。当资源内容发生变化时，[contenthash] 也会发生变化。 JS 的文件指纹设置，在output 的 filename，使用 [chunkhash] CSS 的文件指纹设置，可以在MiniCssExtractPlugin使用[contenthash] 使用hash的场景还应该结合mode来考虑，如果mode是development的时候，在使用hmr的情况下，尽量避免使用chunkhash和contenthash，应该使用hash。而在mode是production的时候，就是不用hmr的情况下，这时候就适合使用chunkhash了。hmr只在development开发阶段使用。 js使用chunkhash是便于寻找资源，js的资源的关联度更高；而css采用contenthash是因为css一般是根据不同的页面书写的，css资源之前的关联度不高，也就不用在其他资源修改，而css部分没有修改的时候重新更新css。 MiniCssExtractPlugin作用 将 CSS 提取到单独的文件中 为每个包含 CSS 的 JS 文件创建一个 CSS 文件 支持按需加载 CSS 和 SourceMaps 下载 npm i mini-css-extract-plugin -D const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; output: &#123; path: path.resolve(__dirname, '/dist'), filename: '[name][chunkhash:8].js' &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name][contenthash:8].css' &#125;) ] &#125; 图片的文件指纹设置在 file-loader或者url-loader 的options参数中设置name，使用[contenthash] 当 webpack 配置中使用了 [hash] 占位符时，请考虑将它改为 [contenthash] 占位符名称 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件的相对路径 [folder] 文件所在的文件夹 [hash] 每次构建生成的唯一 hash 值，默认是 md5 生成 [chunkhash] 根据chunk生成hash值 [contenthash] 根据文件内容生成hash 值，默认是md5生成，默认有32位，一般取前8位 [emoji] 一个随机的指代文件内容的 emoji hash：任何一个文件改动，整个项目的构建 hash 值都会改变； chunkhash：文件的改动只会影响其所在 chunk 的 hash 值； contenthash：每个文件都有单独的 hash 值，文件的改动只会影响自身的 hash 值； const path = require('path'); module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: 'images/[name][hash:8].[ext]' &#125; &#125; ] &#125; ] &#125; &#125; sourcemap sourcemap是一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射可以追踪源代码错误） sourcemap一般在开发环境使用，生产环境关闭 关键字 说明 eval 使用eval包裹模块代码 source-map 产生.map文件 cheap 只需要定位到行信息，不需要列信息 inline 将.map作为DataURI嵌入，不单独生成.map文件 module 包含loader的sourcemap，展示源代码中的错误位置 sourcemap的类型 不开起source-map调试是打包之后的内容，不方便调试 开启source-map调试看到的是源代码，方面调试 module.exports = &#123; devtool: 'source-map' &#125; sourcemap的类型总结[inline-、hidden-、eval-][nosources-][cheap-[module-]]source-map 说明：外部则是生成xxx.js.map文件，内联则是将.map内嵌，不生成.map文件，内联构建速度更快，但是体积比外部大 source-map：外部，能显示出错误代码准确信息和源代码的错误位置 inline-source-map：内联，只生成一个内联source-map，能显示错误代码准确信息和源代码的错误位置 eval-source-map：内联，每一个文件都生成对应的source-map，都在eval中，能显示错误代码准确信息和源代码的错误位置(文件后面会多一个hash值，print.js?8d3a) hidden-source-map：外部，为了隐藏源代码而诞生的，错误代码能显示错误原因，但是没有源代码的错误位置，不能追踪源代码错误，只能提示到构建后代码的错误位置 nosources-source-map：外部，为了隐藏源代码而诞生的，错误代码准确信息，但是没有任何源代码信息(找不到任何代码信息) cheap-source-map：外部，能显示错误代码准确信息和源代码的错误位置，只能精确的行的错误，不能精确到列（比如第四行只是后面的一个代码错误，但是是整行报错，而source-map可以准确提示哪一行的那一列出错了，同一行没错误的分号(;) 不提示错误） cheap-module-source-map：外部，能错误代码准确信息和源代码的错误位置，有module，会将loader的source map加入。 开发环境：速度快，调试更友好 速度快慢，eval&gt;inline&gt;cheap&gt;… eval-cheap-souce-map (有cheap只精确到行) eval-source-map 调试更友好 souce-map cheap-module-souce-map(module会将loader的source map加入) cheap-souce-map eval-source-map(调试最友好) 、eval-cheap-module-souce-map(调试性能最友好)、react脚手架（cra）默认使用的是eval-source-map 本地开发推荐eval-cheap-souce-map 本地开发首次打包慢点没关系，因为eval缓存的原因，rebuild会很快 开发中，我们每行代码不会写的太长，只需要定位到行就行，所以加上cheap 我们希望能够找到源代码的错误，而不是打包后的，所以需要加上module 生产环境：源代码要不要隐藏? 调试要不要更友好 内联会让代码体积变大，所以在生产环境不用内联，我们要让体积变小，就不要内联，而采用外部的方式。 nosources-source-map 全部隐藏（源码和构建后的代码都会隐藏） hidden-source-map 只隐藏源代码，会提示构建后代码错误信息 source-map(调试友好) cheap-module-souce-map（cheap的速度会快一点） 推荐none：不想别人看到我的源代码 webpack进阶自动清理构建产物 通过 npm scripts 清理构建目录 rm -rf ./dist &amp;&amp; webpack rimraf ./dist &amp;&amp; webpack 避免构建前每次都需要手动删除 dist，使用 clean-webpack-plugin，默认会删除 output 指定的输出目录 const path = require('path'); const CleanWebpackPlugin = require('clean-webpack-plugin'); module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name][chunkhash:8].js' &#125;, plugins: [ new CleanWebpackPlugin() ] &#125; webpack之PostCSS插件autoprefixer自动补齐CSS3前缀为了实现 CSS3 前缀的自动补齐，使用autoprefixer 插件：对代码打包完成后的 CSS 进行后置处理，与 postcss-loader 结合使用Can I Use 插件 查看兼容性 npm i autoprefixer postcss-loader -d const path = require('path'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name]_[chunkhash:8].js' &#125;, // 有单行注释代码的时候，需要把less loader放到后面，不然会报错的 module: &#123; rules: [ &#123; test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () => [ require('autoprefixer')(&#123; // browsers 指定 autoprefixer 所需要兼容的浏览器版本 // 最近两个版本，浏览器使用量大于1% browsers: ['last 2 version', '>1%', 'ios 7'] // browsers改成overrideBrowserslist &#125;) ] &#125; &#125; ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;) ] &#125; 移动端CSS px自动转换成rempx2rem-loader：将 px 自动转换成 rem const path = require('path'); module.exports = &#123; module: &#123; rules: [ &#123; test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', // 移动端CSS px自动转换成rem &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75, // 1rem = 75px remPrecision: 8 // px 转换为 rem 时小数点后的位数 &#125; &#125; ] &#125; ] &#125; &#125; lib-flexible：页面渲染时计算根元素的 font-size 值(可以使用手淘的 lib-flexible 库https://github.com/amfe/lib-flexible) 将 node_modules -&gt; lib-flexible -&gt; flexible.js 文件全部代码手动引入到 模板html 文件中 多页面应用(PWA) 页面有多个入口，多页面应用每个应用都是解耦的，多页面应用对SEO更加友好。 多页面跳转需要刷新所有资源，每个公共资源(js、css等)需选择性重新加载; 页面跳转：使用window.location.href &#x3D; “.&#x2F;index.html”进行页面间的跳转； 数据传递：可以使用path?account&#x3D;123&amp;password&#x3D;456 路径携带数据传递的方式，或者localstorage、cookie等存储方式; 每个页面对应一个entry，一个html-webpack-plugin，缺点是每次新增或者删除页面需要修改webpack配置 解决方案：动态获取entry和设置html-webpack-plugin的数量 约定js入口文件放置格式为 ./src/xxx/index.js，xxx为某个特定模块的名称，html模板为index.html 利用glob.sync读取文件：glob // npm i glob -d glob.sync(path.join(__dirname, './src/*/index.js')) // webpack.config.js const glob = require('glob'); const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const setMPA = () => &#123; const entry = &#123;&#125;; const htmlWebpackPlugins = []; const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js')); Object.keys(entryFiles) .map((index) => &#123; const entryFile = entryFiles[index]; const match = entryFile.match(/src\\/(.*)\\/index\\.js/); const pageName = match &amp;&amp; match[1]; entry[pageName] = entryFile; htmlWebpackPlugins.push( new HtmlWebpackPlugin(&#123; inlineSource: '.css$', template: path.join(__dirname, `src/$&#123;pageName&#125;/index.html`), filename: `$&#123;pageName&#125;.html`, chunks: ['vendors', pageName], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false &#125; &#125;) ); &#125;); return &#123; entry, htmlWebpackPlugins &#125; &#125; const &#123; entry, htmlWebpackPlugins &#125; = setMPA(); module.exports = &#123; entry: entry, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name]_[chunkhash:8].js' &#125;, mode: 'production', // module: &#123;......&#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;), new OptimizeCSSAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano') &#125;), new CleanWebpackPlugin(), new HTMLInlineCSSWebpackPlugin() ].concat(htmlWebpackPlugins) &#125;; 热更新（HMR）1、使用 webpack-dev-server 自动编译并运行，不需要手动刷新浏览器，每次修改代码都需要重新执行 webpack 命令，可以使用 webpack-dev-server 自动打包运行 不输出文件，而是放在内存中，watch是放在磁盘里 与 HotModuleReplacementPlugin 插件配合使用 npm i webpack-dev-server -d webpack.config.js const path = require('path'); const webpack = require('webpack'); module.exports = &#123; output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].js' &#125;, // 热更新一般只在开发模式使用 mode: 'development', plugins: [ new webpack.HotModuleReplacementPlugin() ], devServer: &#123; // 告诉服务器从哪里提供静态资源（只有想提供静态文件时才需要） contentBase: path.resolve(__dirname, 'public'), // 静态资源所在的路径，默认为项目根目录 hot: true // 开启热更新 port: 8888, // 端口号 compress: true, //是否启动压缩 gzip open:true // 是否自动打开浏览器 // devServer里面的publicPath表示的是打包生成的静态文件所在的位置 //（若是devServer里面的publicPath没有设置，则会认为是output里面设置的publicPath的值） &#125; &#125; package.json，–open打开浏览器 &#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server --open\" &#125; &#125; 热更新原理分析 首次编译：① -&gt; ② -&gt; A -&gt; B 修改代码后的热更新：① -&gt; ② -&gt; ③ -&gt; ④ HMR Server -&gt; HMR Runtime 以json形式传递 概念 描述 Webpack Compiler(webpack编译器) 将JS编译成 Bundle HMR Server 将热更新的文件传输给 HMR Runtime Bundle Server 提供文件在浏览器的访问，提供类似的服务器环境访问，如localhost:3003&#x2F;bundle.js，服务器和浏览器是ws链接 HMR Runtime 会被注入到浏览器，更新文件的变化 bundle.js 构建输出的文件 webpack之JS、css和html文件的压缩webpack4 内置了uglifyjs-webpack-plugin 插件（mode为production），默认打包出的 JS 文件已压缩过， webpack5 内置了terser-webpack-plugin 插件 CSS 文件的压缩 # 安装依赖，使用 optimize-css-assets-webpack-plugin 插件，同时使用预处理器 cssnano npm i optimize-css-assets-webpack-plugin cssnano -D html文件的压缩 const path = require('path'); const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name][chunkhash:8].js' &#125;, plugins: [ // 添加 css 压缩配置 new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano') &#125;), // 通常是一个html页面对应一个HtmlWebpackPlugin，多个html就使用多个HtmlWebpackPlugin new HtmlWebpackPlugin(&#123; template: path.join(__dirname, 'src/index.html'), // html 模板所在的位置 filename: 'index.html', // 指定打包出 html 的文件名称 chunks: ['index'], // 指定生成的 html 要 使用哪些 chunk inject: true, // 将指定的chunks（js、css）引入到 html中 minify: &#123; html5: true, // 移除空格 collapseWhitespace: true, // 当标记之间的空格包含换行符时，始终折叠为1换行符(不完全删除它)，必须与collapseWhitespace=true一起使用 preserveLineBreaks: false, minifyCSS: true, // 压缩文内css minifyJS: true, // 压缩文内js // 移除注释 removeComments: false &#125; &#125;) ], optimization: &#123; minimize: true, minimizer: [ // 添加 css 压缩配置 new OptimizeCssAssetsPlugin(&#123;&#125;), // 压缩 JS new TerserPlugin(&#123;&#125;) ] &#125;, &#125; 提取页面的公共资源基础库的分离 思路:将react、react-dom 基础包通过cdn 引入，不打入bundle 中 方法:使用html-webpack-externals-plugin entry: 可以是本地文件、cdn引入等 externalsexternals 配置选项提供了「从输出的 bundle 中排除依赖」的方法 例如，从CDN引入React，而不是把它打包 &lt;!-- anonymous：CORS请求将不设置凭据标志 --> &lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin=\"anonymous\" >&lt;/script> 配置externals const config = &#123; //... externals: &#123; react: 'React', &#125;, &#125;; 使用React import React from 'react'; CDNCDN用来托管静态资源，就近获取，加快访问速度，缓解服务器压力，还可以防止一些网络的攻击 CDN的原理是：本地DNS系统解析的时候，发现该URL对应的是一个CDN专用的DNS服务器，将解析权利交给了 专门处理CDN的DNS服务处理 使用SplitChunksPlugin进行公共脚本分离optimization.splitChunks 是基于 SplitChunksPlugin 插件实现的，webpack内置的。 splitChunks 分包配置 module.exports = &#123; //... optimization: &#123; splitChunks: &#123; // async：异步引入的库进行分离（默认）， initial： 同步引入的库进行分离， all：所有引入的库进行分离（推荐） chunks: 'async', minSize: 30000, // 抽离的公共包最小的大小，单位字节 30k 如果minSize: 0,只要有引用，就会抽离 minRemainingSize: 0, // 确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块 maxSize: 0, // 最大的大小 minChunks: 1, // 资源使用的次数(在多个页面使用到)， 大于1， 最小使用次数 maxAsyncRequests: 5, // 并发请求的资源数量 maxInitialRequests: 30, // 入口文件做代码分割最多能分成30个js文件 automaticNameDelimiter: '~', // 文件生成时的连接符 automaticNameMaxLength: 30, // 自动自动命名最大长度 name: true, // 让cacheGroups里设置的名字有效 cacheGroups: &#123; //当打包同步代码时，上面的参数生效，配置提取模块的方案 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, //检测引入的库是否在node_modlues目录下的 priority: -10, //值越大,优先级越高.模块先打包到优先级高的组里 filename: 'vendors.js'//把所有的库都打包到一个叫vendors.js的文件里 &#125;, default: &#123; minChunks: 2, // 上面有 priority: -20, // 上面有 reuseExistingChunk: true //如果一个模块已经被打包过了,那么再打包时就忽略这个上模块 &#125;, commons: &#123; test: /(react|react-dom)/, // 分离处理的名称，可将vendors这个chunk添加到html-webpack-plugin中的chunks数组里使用，chunks: ['vendors', pageName] name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125; &#125;; Tree Shaking的使用和原理分析 webpack默认支持，模式为production默认开启，必须是es module的模块规范，cjs不支持 Tree Shaking就是把模块中使用到的代码打入bundle，引入了但是没有使用，也不会被打包进入bundle。 Tree Shaking原理：Tree Shaking会对模块的代码进行静态的分析，在编译的阶段已经确定了哪些代码需要使用的，不需要的代码会被Tree Shaking进行注释标记，最终在uglify阶段删除无用的代码。 DCEdead code elimination，消除死代码，通常在编译阶段由编译器进行判断某些代码是否可达从而删除那些不可能执行的代码 代码不会被执行，不可到达 if(false)&#123; console.log(\"1\") // 这段代码永远不会执行 &#125; 代码的执行结果不会被用到 代码只会影响死变量（只写不读） 常规的死代码消除一般来说包含上面这几种类型的无用代码，会在打包阶段，一般是uglify.js分析并删除无用代码。 副作用的代码不能treeshking，如在window对象挂载属性值，但是没有使用；export封装成对象导出，没有使用的方法不能被treeshking，原因是treeshking只能做到export级别，编译期间的静态分析只能对es module的相关语法做分析，是不会真正去执行代码的。 Scope Hoisting（作用域提升）Scope Hoisting 是 webpack3 的新功能，它可以让 webpack 打包出来的代码文件更小，运行更快。原理是将多个模块放在同一个作用域下，并重命名防止命名冲突，通过这种方式可以减少函数声明和内存开销。 当前现状：webpack构建后的代码存在大量的闭包代码，导致什么问题？ 大量函数闭包包裹代码，导致包体积增大（模块越多越明显） 代码在运行时因为创建的函数作用域更多，内存开销变大。 模块转换分析 模块转化为模块初始化函数，转换后的模块会带上一层包裹 import会被转换成__webpack_require，__webpack_require的参数有moduleId，exprot也会发生转换 webpack模块机制 webpack 打包输出打是一个 IIFE（匿名闭包）； modules 是一个数组，每一项是一个模块初始化函数，modules会传入IIFE函数中； IIFE函数最核心的是使用 __webpack_require() 来加载和处理模块，返回 module.exports； __webpack_require()根据moduleId来查看installModules里是否存在，不存在会创建一个新的module存放到installModules； 通过 webpack_require(webpack_require.s &#x3D; 0)，entry入口依赖，启动程序。 Scope Hoisting原理（从rollup借鉴） 原理：将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突，消除包裹 Scope Hoisting的使用：webpack4以上，模式为production默认开启，必须是ESM，不支持cjs ModuleConcatenationPlugin() 插件参考Scope Hoisting 没有 Scope Hoisting 时用 webpack 打包下面两个文件 // main.js export default \"hello\"; // index.js import str from \"./main.js\"; console.log(str); 使用 webpack 打包后输出文件内容如下： // module指代源代码，__webpack_exports__就是export、__webpack_require__是import /* harmony import 是ES6语法的标识 */ /* harmony exports 是ES6语法的标识 */ [ (function (module, __webpack_exports__, __webpack_require__) &#123; var __WEBPACK_IMPORTED_MODULE_0__main_js__ = __webpack_require__(1); console.log(__WEBPACK_IMPORTED_MODULE_0__main_js__[\"a\"]); &#125;), (function (module, __webpack_exports__, __webpack_require__) &#123; __webpack_exports__[\"a\"] = ('hello'); &#125;) ] 再开启 Scope Hoisting 后，相同源码打包输出结果变为： [ (function (module, __webpack_exports__, __webpack_require__) &#123; var main = ('hello'); console.log(main); &#125;) ] 对比两种打包方式输出的代码，我们可以看出，启用 Scope Hoisting 后，函数声明变成一个， main.js 中定义的内容被直接注入到 main.js 对应模块中，这样做的好处： 代码体积更小，因为函数申明语句会产生大量代码，导致包体积增大（模块越多越明显）； 代码在运行时因为创建的函数作用域更少，内存开销也随之变小。 对比结果: 通过scope hoisting 可以减少函数声明代码和内存开销 scope hoisting理解为是把每个模块被webpack处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，但是有一个前提就是，当模块的引用次数大于1时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被webpack处理后，会被独立的包裹函数所包裹 Scope housting对模块的引用次数大于1次是不产生效果的，这个其实也很好理解，如果一个模块引用次数大于1次，那么这个模块的代码会被内联多次，从而增加了打包出来的js bundle的体积。 代码分割和动态import代码分割场景 抽离相同代码到一个共享模块 脚本懒加载，使得初始下载的代码更小，懒加载方式： cjs：require.ensure esm：动态import（目前还没有原生支持，需要babel转换） 静态分析（在模块的头部import xxx from ‘xxx’） 动态引入（在if…else{ import(‘xxx’)}），按需加载 动态import的js代码在打包时，会被抽离出来，用到的时候才会加载这个被抽离出来的js文件，通过webpackJsonp的一个请求加载。（典型的通过jsonp的形式往html插入script标签），动态import（懒加载）必定会分割代码，生成新的chunk。 prefetch (预获取)：浏览器空闲的时候进行资源的拉取 import( /* webpackPrefetch: true */ './src/xxx').then(() => &#123;&#125;) preload (预加载)：提前加载后面会用到的关键资源（谨慎使用） import(/* webpackPreload: true */ 'ChartingLibrary'); preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。 preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。 preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。 如何动态import 使用@babel&#x2F;plugin-syntax-dynamic-import插件，下载该插件，并在.babelrc的plugins配置插件 /* 通过js代码，让某个文件被单独打包成一个chunk import动态导入语法：能将某个文件单独打包 */ // 魔法注释当注解用了，标注打包后的文件名为test /* webpackChunkName: 'test' */ import(/* webpackChunkName: 'test' */'./test') .then((&#123; add &#125;) => &#123; // 文件加载成功~ // eslint-disable-next-line console.log(add(1, 2)); &#125;) .catch(() => &#123; // eslint-disable-next-line console.log('文件加载失败~'); &#125;); 在webpack中使用ESLint制定ESLint规范，检查JS 不重复造轮子，基于eslint:recommend配置并改进 能够帮助发现代码错误的规则，全部开启 ESLint如何执行落地 和CI&#x2F;CD系统集成 和webpack集成 本地开发阶段增加precommit钩子 安装husky，npm i husky -d 增加npm script，通过lint-staged增量检查修改的文件 &#123; \"scripts\": &#123; \"precommit\": \"lint-staged\", &#125;, \"lint-staged\": &#123; \"linters\": &#123; \"*.&#123;js, less&#125;\": [ \"eslint --fix\", \"git add\" ], &#125; &#125;, &#125; 使用eslint-webpack-plugin，构建时检查js规范 eslint-config-airbnb的使用 eslint-config-airbnb(react项目使用)、eslint-config-airbnb-base(其他项目)eslint-config-airbnb 下载 npm install eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y -d 下载 npm install babel-eslint eslint-config-airbnb -deslint官网 eslint配置文件：.eslint.*(.eslint.js&#x2F;.eslint.json&#x2F;.eslint.yml) // .eslint.js module.exports = &#123; \"parser\": \"babel-eslint\", // 使用的parser是babel-eslint，需要下载安装babel-eslint \"extends\": \"airbnb\", // 继承airbnb，需要安装 \"env\": &#123; // 识别browser和node环境的一些全局变量 \"browser\": true, \"node\": true &#125;, // 定义规则 \"rules\": &#123; \"indent\": [\"error\", 4] //indent空格， \"error\"错误级别、4是控制的空格数量 &#125; &#125;; 优化 resolve 配置aliasalias 用的创建 import 或 require 的别名，用来简化模块引用，项目中基本都需要进行配置。 优化 resolve 配置 const path = require('path') ... // 路径处理方法 function resolve(dir)&#123; return path.join(__dirname, dir); &#125; const config = &#123; ... resolve:&#123; // 配置别名 alias: &#123; '~': resolve('src'), '@': resolve('src'), 'components': resolve('src/components'), &#125; &#125; &#125;; 配置完成之后，我们在项目中就可以 // 使用 src 别名 ~ import '~/fonts/iconfont.css' // 使用 src 别名 @ import '@/fonts/iconfont.css' // 使用 components 别名 import footer from \"components/footer\"; extensions和modules 如果用户引入模块时不带扩展名，那么 webpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块，高频文件后缀名放前面。 modules，告诉 webpack 解析模块时应该搜索的目录，const config = &#123; //... resolve: &#123; extensions: ['.js', '.json', '.wasm'], // webpack 默认配置 // 手动配置后，默认配置会被覆盖，如果想保留默认配置，可以用 ... 扩展运算符代表默认配置 // extensions: ['.ts', '...'], modules: [resolve('src'), 'node_modules'] &#125;, &#125;; resolveLoader用于解析 webpack 的 loader 包，有自定义的 Loader 就需要配置一下，手写loader时可以用 const path = require('path'); const config = &#123; //... resolveLoader: &#123; modules: ['node_modules', path.join(__dirname,'loader')] &#125;, &#125;; webpack构建速度和优化体积使用webpack内置的stats分析&#123; \"srcipts\":&#123; \"build:stats\": \"webpack --env production --json > stats.json\" &#125; &#125; 速度分析：使用speed-measure-webpack-plugin 分析整个打包的总耗时 每个插件和loader的耗时情况 和一些Loader或者Plugin新版本会不兼容，需要进行降级处理，如mini-css-extract-plugin、html-webpack-plugin const SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin'); const smp = new SpeedMeasureWebpackPlugin(); module.exports = smp.wrap(&#123; ...... &#125;) 体积分析：使用webpack-bundle-analyzer可以直观的看到打包结果中，文件的体积大小、各模块依赖关系、文件是够重复等问题，极大的方便我们在进行项目优化的时候，进行问题诊断 构建完成后会在8888端口展示大小 依赖的第三方模块文件大小 业务里面的组件代码大小 const &#123; BundleAnalyzerPlugin &#125; = require('webpack-bundle-analyzer'); module.exports = &#123; plugins: [ // 配置插件 new BundleAnalyzerPlugin(&#123; // analyzerMode: 'disabled', // 不启动展示打包报告的http服务器 // generateStatsFile: true, // 是否生成stats.json文件 &#125;) ] &#125; webpack4webpack4: 优化原因 V8带来的优化(for of替代 forEach、Map和Set替代 Object、includes替代indexOf) 默认使用更快的md4 hash 算法 webpacks AST可以直接从loader传递给AST，减少解析时间 使用字符串方法替代正则表达式 多进程&#x2F;多实例构建：资源并行解析可选方案thread-loader parallel-webpack HappyPack（同样为开启多进程打包的工具，webpack5 已弃用） 多进程&#x2F;多实例：并行压缩const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; optimization: &#123; minimizer: [ new TerserPlugin(&#123; parallel: true, cache: true &#125;) ], minimize: true, &#125;, &#125; 优化构建速度，缩小构建目标目的：尽可能的少构建模块，比如babel-loader不解析node_modules、减少文件搜索范围 &#123; test: /\\.js$/, exclude: /node_modules/, // 同时使用多个loader 用use数组，多个可以直接配置 use: [ /* 开启多线程打包。 进程启动大概为600ms，进程通信也有开销。 只有工作消耗时间比较长，才需要多线程打包 */ &#123; loader: 'thread-loader', options: &#123; workers: 2 // 进程2个 &#125; &#125;, &#123; loader: 'babel-loader', options: &#123; // 预设：指示babel做怎么样的兼容性处理 presets: [ [ '@babel/preset-env', &#123; // 按需加载 useBuiltIns: 'usage', // 指定core-js版本 corejs: &#123; version: 3 &#125;, // 指定兼容性做到哪个版本浏览器 targets: &#123; chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' &#125; &#125; ] ], // 开启babel缓存 // 第二次构建时，会读取之前的缓存, 速度会更快一点 cacheDirectory: true &#125; &#125; ], &#125; 无用的CSS如何删除 PurifyCSS:遍历代码，识别已经用到的CSS class 使用purgecss-webpack-plugin，必须和mini-css-extract-plugin搭配使用 const PurgecssPlugin = require('purgecss-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const glob = require('glob'); const PATHS = &#123; src: path.join(__dirname, 'src') &#125;; module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;), new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;PATHS.src&#125;/**/*`, &#123; nodir: true &#125;), &#125;) ] &#125; uncss: HTML需要通过jsdom加载，所有的样式通过PostCSS解析，通过document.querySelector来识别在html文件里面不存在的选择器 prefetch 与 preloadprefetchprefetch (预获取)：等其他资源加载完毕，浏览器空闲了，会在使用之前，提前加载js文件 /* 通过js代码，让某个文件被单独打包成一个chunk import动态导入语法：能将某个文件单独打包 */ /* webpackChunkName: 'test' */ // 魔法注释当注解用了,标注打包后的文件名为test // 类似路由的懒加载 import(/* webpackChunkName: 'test' */'./test') // 按需加载 必定会分割代码，生成新的chunk img.addEventListener('click', () => &#123; import( /* webpackPrefetch: true */ './desc').then((&#123; default: element &#125;) => &#123; console.log(element) document.body.appendChild(element) &#125;) &#125;) preloadpreload (预加载)：提前加载后面会用到的关键资源，因为会提前拉取资源，如果不是特殊需要，谨慎使用 import(/* webpackPreload: true */ 'ChartingLibrary'); 全局环境变量通过 webpack 内置插件 DefinePlugin 定义 DEV 环境变量。 const webpack = require(\"webpack\"); module.exports = &#123; mode: \"development\", plugins: [ new webpack.DefinePlugin(&#123; ENV: JSON.stringify(\"dev\"), // 推荐使用JSON.tringify，不仅可以处理字符串，还可以处理Object中的字符串和Array HELLO: 'hello world', &#125;), ], &#125;; 可维护的webpack构建配置构建配置抽离成npm包的意义 通用性 业务开发者无需关注构建配置 统一团队构建脚本 可维护性 构建配置合理的拆分 README文档、ChangeLog文档等 质量 冒烟测试、单元测试、测试覆盖率 持续集成 构建配置管理的可选方案 通过多个配置文件管理不同环境的构建，webpack –config 参数进行控制 将构建配置设计成一个库，比如: hjs-webpack、Neutrino、webpack-blocks 抽成一个工具进行管理，比如: create-react-app, kyt, nwb（团队规模大抽成一个cli） 将所有的配置放在一个文件，通过–env参数控制分支选择 构建配置包设计通过多个配置文件管理不同环境的webpack构建 基础配置:webpack.base.js 开发环境:webpack.dev.js 生产环境:webpack.prod.js SSR环境:webpack.ssr.js … 抽离成一个npm包统一管理 规范: git commit日志、README、ESLint规范、Semver规范 通过webpack-merge组合配置合并配置 const merge = require('webpack-merge') module.exports = merge(baseConfig, devConfig) 功能模块设计 目录结构设计-/test # 测试代码 -/lib # 源代码 - webpack.dev.js - webpack.prod.js - webpack.ssr.js - webpack.base.js index.js README.md CHANGELOG.md .eslinrc.js package.json webpack5 node版本大于10.13.0 功能清除：清理弃用功能 所有在webpack4里面被废弃的能力都被清除，因此需要确保webpack4没有打印警告。 require.includes语法已被废弃，可以通过 Rule.parser.requirelnclude 将行为改为允许、废弃或禁用。预加载一些模块，并不会马上执行 不再为Node.js模块引入polyfill，之前的版本是：如果某个模块依赖Node.js里面的核心模块，那么这个模块被引入的时候会把Node.js整个polyfill顺带引入。 长期缓存确定的模块ld、chunk和导出名称。在生产模式下，默认的chunklds:”deterministic”, modulelds:”deterministic”。设置成deterministic时默认最小3位数会被使用，不会因为某一个文件发生了变化，其他的会产生变化。 chunklds 选项值 描述 natural 按使用顺序的数字id。 named 对调试更友好的可读的id。 deterministic 在不同的编译中不变的短数字id。有益于长期缓存。在生产模式中会默认开启。 size 专注于让初始下载包大小更小的数字id。 total-size 专注于让总下载包大小更小的数字id。 modulelds 选荐值 描述 natural 按使用顺序的数字id。 named 对调试更友好的可读的id。 deterministic 被哈希转化成的小位数值模块名。 size 专注于让初始下载包大小更小的数字id。 cache持久化缓存在webpack4里面，可以使用cache-loader将编译结果写入硬盘缓存，还可以使用babel-loader，设置option.cacheDirectory将babel-loader编译的结果写进磁盘。 webpack5缓存策略 默认开启缓存，缓存默认是在内存里。可以对cache进行设置。 缓存淘汰策略︰文件缓存存储在node_modules&#x2F;.cache&#x2F;webpack，最大500MB，缓存时常两个星期，旧的缓存先淘汰 后面打包可以直接利用它原生缓存的打包的能力 module.exports= &#123; cache: &#123; // 将缓存类型设置为文件系统 type: 'filesystem', buildDependencies: &#123; // 将你的 config添加为 buildDependency，以便在改变config时获得缓存无效 config: [__filename], // 如果你有其他的东西被构建依赖，你可以在这里添加它们 // 注意 webpack、加载器和所有从你的配置中引用的模块都会被自动添加 &#125; &#125; &#125; 构建优化：TreeShaking 支持嵌套的TreeShaking 可以分析这个模块直接的一个依赖关系 代码生成：支持生成ES6代码 webpack 4之前只生成ES5的代码。webpack 5则现在既可以生成ES5又可以生成ES6&#x2F;ES2015代码。 两种设置方式:5 =&lt;ecmaVersion &lt;= 11或2009 =&lt; ecmaVersion &lt;= 2020 module.exports = &#123; output:&#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js', ecmaVersion: 6, // 输出ES6代码 &#125; &#125; 开创性的特性：模块联邦基本解释: 使一个JavaScript 应用在运行过程中可以动态加载另一个应用的代码，并支持共享依赖(CDN)。不再需要本地安装Npm包。通过CDN加载，应用A通过一个CDN，它去加载应用B，然后这两个应用分别在不同的端口。使用组件或者模块的分享更加方便了 Remote: 被依赖方，被Host消费的 Webpack构建，提供一些组件或者依赖出来，给其他的依赖方去用，相当于服务提供方。 Host: 依赖方，消费其他 Remote 的 Webpack 构建，使用其他Remote提供的模块， 一个应用可以是Host，也可以是Remote，也可以同时是Host和Remote 开创性的特性: ModuleFederationPlugin介绍Webpack内部通过ModuleFederationPlugin 插件将多个应用结合起来。 name: 必须，唯一ID，作为输出的模块名，使用的时通过 $&#123;name&#125;/$&#123;expose&#125;的方式使用; library: 必须，其中这里的name为作为umd的name; remotes: 可选，表示作为Host时，去消费哪些Remote; shared: 可选，优先用Host的依赖，如果Host没有，再用自己的; main.js: 应用主文件 remoteEntry.js: 作为remote 时被引的文件 bundle和bundlessbundle和bundless资源加载差异 bundle：浏览器加载的是构建好的文件，最开始会加载一个bundle.js； bundless: 直接加载原文件，不是加载构建好的文件； bundle和bundless打包速度对比 bundless的冷启动时间大大缩短（使用esbuild） bundless的HMR速度不受整个项目体积影响，HMR效率高 bundless的单文件粒度的缓存更优 bundless在开发阶段的体验是更优的 vite构建速度快的原因预构建使用ESBuild（冷启动快的原因），ESBuild使用golang进行打包 参考 玩转 webpack webpack知识体系 从v4升级到v5 webpack5资源模块 webpack5资源模块的使用 构建webpack5知识体系","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]},{"title":"【前端工程化】从0-1搭建react脚手架","slug":"engineering/build-cli","date":"2021-01-25T19:29:58.000Z","updated":"2022-07-09T16:04:02.310Z","comments":true,"path":"2021/01/26/engineering/build-cli/","link":"","permalink":"http://example.com/2021/01/26/engineering/build-cli/","excerpt":"","text":"前言介绍模块的使用chalkcommanderinquirerWebpack5 + React Webpack5 + React 脚手架的配置 webpack(v5.7)+React(v18.0)+react-router(v6.3)+Mobx(v6.5)+TS(v4.6)从零开始构建 参考 从0-1搭建react + ts脚手架 从0到1构建cli脚手架 React入门———react脚手架","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"localStorage、sessionStorage和cookie的区别","slug":"front_end/browser-cache","date":"2021-01-15T10:22:49.000Z","updated":"2022-07-04T14:36:54.588Z","comments":true,"path":"2021/01/15/front_end/browser-cache/","link":"","permalink":"http://example.com/2021/01/15/front_end/browser-cache/","excerpt":"","text":"localStorage 和 sessionStorage localStorage 和 sessionStorage 是 HTML5 新增的浏览器本地缓存API，localstorage，sessionstorage在浏览器无痕模式下会存在丢失问题 只有相同域名的页面才能互相读取 localStorage 浏览器同时打开两个相同域名的tab页面，localstorage是共享的，sessionstorage是不共享的 localStorage 和 sessionStorage的存取操作都是同步的 主要用途 localStorage 项目状态管理的持久化，例如redux的持久化、mobx的持久化、vuex的持久化等 项目全局风格状态的切换（页面的默认定制配置），例如主题颜色、语言标识 token的存储 项目通用参数的存储，来记录一些不敏感的信息 sessionStorage sessionStorage 适合一次性临时数据保存 localStorage、sessionStorage和cookie的异同点 分类 生命周期 存储容量 cookie 默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效） 4KB localStorage 永久有效的，除非主动清除。 5M左右 sessionStorage 仅在当前tab页会话下有效，关闭tab页面或浏览器后会被清除。 5M左右 基本使用// 以 localStorage 为例 localStorage.setItem(key, value); // 存储 localStorage.getItem(key); // 获取 localStorage.removeItem(key); // 删除 localStorage.clear(); // 清空 localStorage 数据过期（脏数据）localstorage本身是没有过期机制的，可以通过手动实现。具体的做法是： 存入数据时，顺便存一个过期时间 maxAge 和 当前存值时间戳 time 获取数据时，通过（time + maxAge 和 Date.now()的关系）来判断当前数据是否过期，过期则删除当前数据; 否则正常返回数据 参考：如何实现localStorage的过期机制？ 没有手动封装localStorage过期的token登录例子：假如前端用localStorage永久存储token（token由过期时间、其他信息组成），发送请求时，后端拿到token检验是否过期，token过期后，后端会返回401状态码，前台统一捕获这个状态码后跳转到登录页面（过期重定向）。一般都是这么个做法，但是这个做法有一个小弊端：需要依靠请求才能感知是否已过期。 cookiecookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。 cookie的组成服务器一般是通过在http响应消息头增加Set-Cookie，将Cookie信息种在浏览器中，浏览器发送http请求时，会自动带上同源的Cookie请求头字段，传给服务器。 // 其中name=value是必选项，其它都是可选项 Set-Cookie: \"name=value;domain=.domain.com;path=/;expires=&lt;date>, 11 Jun 2019 11:29:42 GMT;HttpOnly;secure\" expires: 设置cookie的有效期，如果cookie 超过 date 所表示的日期时，cookie将失效。 如果没有设置这个选项，那么cookie将在浏览器关闭时失效。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。 Max-Age：指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。 domain&#x3D; : .taobao.com(a.taobao.com和b.taobao.com都可以访问)，但是不能设置成taobao.com，这样是不允许的携带cookies path&#x3D;: 一般是 &#x2F; (注：临时cookie，没有expires参数的cookie，不能带有domain选项)，当客户端发送一个http请求时，会将有效的cookie一起发送给服务器，如果一个cookie的domain和path参数和URL匹配，那么这个cookie就是有效的。 secure: secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。该属性只是一个开关，不需要指定值。 httponly : 表示cookie不能被客户端脚本获取到。HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是Document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。（但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全）有助于避免 XSS 攻击。（防止通过srcipt标签里面的代码获取cookie） localforage前端本地存储 可以解决 localStorage&#x2F;sessionStorage 大小限制的问题 localforage.getItem 返回的是 promise 不会因为关闭浏览器就消失，需要手动清理哦 localforage.removeItem(key), localforage.clear() localforage库 localforage前端数据存储 参考 localStorage、sessionStorage、cookie、session几种web数据存储方式对比总结 理解cookie、session、localStorage、sessionStorage的关系与区别 傻傻分不清之 Cookie、Session、Token、JWT","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"【JavaScript】写出高质量的JS代码","slug":"front_end/high-quality-code","date":"2020-12-20T11:28:51.000Z","updated":"2022-07-04T14:38:08.454Z","comments":true,"path":"2020/12/20/front_end/high-quality-code/","link":"","permalink":"http://example.com/2020/12/20/front_end/high-quality-code/","excerpt":"","text":"尽量少用全局变量，带来的第三方的 JavaScript 库、不同js文件同名变量的冲突。 尽量使用 &#x3D;&#x3D;&#x3D; ，减少&#x3D;&#x3D;的隐式转化 构造函数和组件首字母要大写，其他一般采取小驼峰命名。 使用空格分开所有的操作符和操作对象，在+，-，*，&#x3D;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;，&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;，&amp;&amp;，||，+&#x3D;等前后都需要空格。 一 、注释代码//1、一个函数解决一个问题的注释 const fun = () => &#123;&#125; //2、多个函数实现某个功能 //当按钮点击时——begin const fun_01 = () => &#123;&#125; const fun_02 = () => &#123;&#125; const fun_03 = () => &#123;&#125; //当按钮点击时——end 二、你更习惯哪种写法读取属性值？推荐——解构赋值1、代码冗余、不高效、不直观代handleResizerMove = (event) => &#123; if (this.props.visible) &#123; let newmoveX = this.state.moveX + (event.clientX - this.state.x); if (this.props.defaultwidth + newmoveX &lt; this.props.minwidth) &#123; newmoveX = this.props.minwidth - this.props.defaultwidth; this.setState(&#123; left: this.props.left + newmoveX, x: event.clientX, moveX: newmoveX &#125;); this.props.onChange &amp;&amp; this.props.onChange(event, this.props.moveX, this.props.dataSource); Event.stopPropagation(event); &#125; &#125; &#125; 2、推荐写法：解构赋值读取属性值handleResizerMove = (event) => &#123; const &#123; visible, left, dataSource, onChange, defaultwidth, minwidth &#125; = this.props; const &#123; x, moveX &#125; = this.state; if (visible) &#123; //计算出移动的距离，向左移动则值小于0，右右移动则值大于0 let newmoveX = moveX + (event.clientX - x); if (defaultwidth + newmoveX &lt; minwidth) &#123; //超过最小宽度则使用最小宽度 newmoveX = minwidth - defaultWidth; &#125; this.setState(&#123; left: left + newmoveX, x: event.clientX, moveX: newmoveX &#125;); onChange &amp;&amp; onChange(event, moveX, dataSource); Event.stopPropagation(event); &#125; &#125; 三、if多条件简化写法// 不推荐这样写： let test; if (x > 10) &#123; test = true; &#125; else &#123; test = false; &#125; // 推荐做法： let test = (x > 10) ? true : false; // 或者 let test = x > 10; // 不推荐: if (x === 'a' || x === 'b' || x === 'c' || x ==='d') &#123; //do something &#125; // 推荐做法： if(['a', 'b', 'c', 'd'].includes(x)) &#123; //do something &#125; 四、方法调用简化写法// 不推荐： var test = 1; if (test === 1) &#123; helper1(); &#125; else &#123; helper2(); &#125; // 推荐做法： test === 1 ? helper1() : helper2(); // 或者 (test === 1 ? helper1 : helper2)(); // 不推荐: if (condition) &#123; callMethod(); &#125; // 推荐做法： condition &amp;&amp; callMethod(); 五、默认属性写法let test1 = 0; let test2 = 'value'; let test3 = &#123;&#125;; // 优化写法: let [test1, test2, test3] = [0, 'value', &#123;&#125;]; if (test === undefined)&#123; test = 1; &#125; // 推荐写法: test = test || 1; 六、属性排除写法排除某些对象的属性，不需要使用第三方库，可以直接使用解构赋值。 import omit from 'omit.js'; // 引入第三方库 // 场景：去掉props对象的某些属性，把剩余属性放到other对象中。 let props=&#123; 'inputIcon':'a', 'removeIcon','b', 'clearIcon':'c', 'switcherIcon':'d', 'type':1, 'status':2, info:&#123;&#125;, visible:true &#125; // 不太推荐的做法： const others= omit(props, ['inputIcon', 'removeIcon', 'clearIcon', 'switcherIcon']); // 推荐做法：利用解构赋值，把pros其他属性放到 other 中 const &#123;inputIcon, removeIcon, clearIcon, switcherIcon, ...others&#125; = props; 七、for循环&#x2F;for…in循环&#x2F;for…of循环哪个写法的效率更高——答案是：普通for循环 forEach 遍历列表值，不能使用 break 语句或使用 return 语句结束循环 for in 遍历对象键值(key)，或者数组下标，不推荐循环一个数组 for of 遍历列表值，允许遍历 Arrays，Strings，Map（哈希），Set（集合）等可迭代的数据结构，for of循环出的是value值，不能循环普通的对象（Object 没有 Symbol.iterator属性） // 测试数据 let arr = []; for(let count = 0; count &lt; 99999; count++)&#123; arr[count] = count; &#125; // 在for循环过程中，提前获取数组长度，只检索了一次长度值。 for (let i = 0, len = arr.length; i &lt; len; i++) &#123; // do something &#125; for (let key in arr) &#123; // do something &#125; for (let value in arr) &#123; // do something &#125; // for: 2.4900375016 ms // for in: 17.1098265997 ms // for of: 7.4388625005 ms 八、求数组最大最小值const arr = [1, 2, 3, 4, 5, 6]; Math.max(…arr); Math.min(…arr); 九、查找匹配const data = [ &#123; type: 'boy', name: 'Mark' &#125;, &#123; type: 'girl', name: 'Amy' &#125;, &#123; type: 'boy', name: 'Bob' &#125; ] function findData(type, name) &#123; for (let i = 0; i &lt; data.length; ++i) &#123; if (data[i].type === type &amp;&amp; data[i].name === name) &#123; return data[i]; &#125; &#125; &#125; let result = findData('boy', 'Mark'); // 优化方法 function findData(data, type, name) &#123; return data.find((item) => &#123; return item.type === type &amp;&amp; item.name === name &#125;); &#125; let result = findData(data, 'boy', 'Mark'); 十、事件代理&lt;ul> &lt;li>test01&lt;/li> &lt;li>test02&lt;/li> &lt;li>test03&lt;/li> &lt;li>test04&lt;/li> &lt;li>test05&lt;/li> &lt;/ul> document.querySelectorAll('li').forEach((e) => &#123; e.onclick = function() &#123; //do something &#125; &#125;) //(addEventLstener) 推荐做法: document.querySelector('ul').onclick = (e) => &#123; if (e.target.nodeName === 'li') &#123; //do something &#125; &#125; 十一、DOM操作写法（1）DOM写入操作写法// 非常不推荐： for (let i = 0; i &lt; 99999; i++) &#123; let test = document.getElementById('test').innerHTML; //do something &#125; //推荐写法：先获取DOM节点，再用该节点进行doSomething var test = document.getElementById('test'); for (let i = 0; i &lt; 99999; i++) &#123; let title = test.innerHTML; //do something &#125; // 非常不推荐： for (let i = 0; i &lt; 99999; i++) &#123; document.getElementById('test').innerHTML = '&lt;span>' + i + '&lt;/span>'; &#125; //推荐写法： var html = ''; for (let i = 0; i &lt; 99999; i++) &#123; html += '&lt;span>' + i + '&lt;/span>'; &#125; document.getElementById('test').innerHTML = html; //document.createDocumentFragment 十二、If Else &#x2F; Switch 写法// if-else做法： if (type === 1) &#123; return '已提交'; &#125; else if (type === 2) &#123; return '审批中'; &#125; else if (type === 3) &#123; return '审批通过'; &#125; else if (type === 0) &#123; return '审批驳回'; &#125; // switch做法： switch (type) &#123; case 1: return '已提交'; case 2: return '审批中'; case 3: return '审批通过'; case 0: return '审批驳回'; &#125; //推荐做法:将键值存在对象中，再获取 let map = &#123; 1: '已提交', 2: '审批中', 3: '审批通过', 0: '审批驳回' &#125;; let typeStr = map[type]; // if-else做法： if (type === 'add') &#123; doAdd(); &#125; else if (type === 'delete') &#123; doDelete(); &#125; else if (type === 'edit') &#123; doEdit(); &#125; else if (type === 'view') &#123; doView(); &#125; // switch做法： switch (type) &#123; case 'add': doAdd(); break; case 'delete': doDelete(); break; case 'edit': doEdit(); break; case 'view': doView(); break; &#125; //推荐做法:将键值存在对象中，再获取 var map = &#123; 'add': doAdd, 'delete': doDelete, 'edit': doEdit, 'view': doView &#125;; map[type] &amp;&amp; map[type]();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"【JavaScript】Object对象常用方法","slug":"front_end/js-object","date":"2020-11-10T10:22:34.000Z","updated":"2022-07-07T15:03:51.447Z","comments":true,"path":"2020/11/10/front_end/js-object/","link":"","permalink":"http://example.com/2020/11/10/front_end/js-object/","excerpt":"","text":"Object.defineProperty作用：劫持或者修改对象的属性 Object.defineProperty(obj, attr, &#123; options &#125;); options参数包含如下属性： value：就是属性的值。 writable：&lt;boolean&gt;，决定属性能否被赋值。 enumerable：&lt;boolean&gt;，决定 for in 能否枚举该属性。 configurable：&lt;boolean&gt;，决定该属性能否被删除或者改变特征值(key)。 Object.hasOwnProperty检测一个对象是否含有attr的属性，不会去原型查找，不包括原型链上的属性 // 封装深拷贝时常用该方法 obj.hasOwnProperty(attr); Object.assginObject.assign只拷贝源对象的自身属性，不拷贝继承属性，也不拷贝不可枚举的属性(enumerable: false)。属性名为Symbol值的属性也会被Object.assign拷贝 Object.assgin(target, obj1, obj2, ...); Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，后面的属性就会覆盖前面的属性。 单层是深拷贝，会开辟一个新的内存空间和地址；多层是浅拷贝，会引用原来的地址。 如果只有一个参数，Object.assign会直接返回该参数。如果该参数不是对象，就会先转成对象，然后返回。 由于undefined和 null无法转成对象，因此如果它们作为参数，就会报错。如果undefined和null不在首参数，就不会报错。 object.assign(undefined) //报错 object.assign(null) //报错 object.assign(obj, undefined) //不报错 object.assign(obj, null) // 不报错 其他类型的值（数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式拷贝入目标对象外，其他值都不会产生效果。vl、v2、v3分别是字符串、布尔值和数值，结果只有字符串可以合并到目标对象中(以字符数组的形式)，数值和布尔值都会被忽略。 let vl = 'abc'; let v2 = true; let v3 = 10; const obj = object.assign (&#123;&#125;, vl, v2, v3); console.log(obj); // &#123;\"0\": \"a\"，\"l\":\"b\"，\"2\": \"c\"&#125; Object.assagin方法很多的用处 为对象添加属性 // 1 class Point&#123; constructor(x, y)&#123; Object.assign(this, x, y); &#125; &#125; // 2 Object.assign(someClass.prototype, &#123; someMethod(arg1, arg2)&#123;&#125;, anotherMethod(arg1, arg2)&#123;&#125;, attr: 'hello' &#125;) // 2的等同于 someClass.prototype.someMethod = function(arg1, arg2)&#123;&#125; someClass.prototype.anotherMethod = function(arg1, arg2)&#123;&#125; someClass.prototype.attr = 'hello'; 克隆对象 function clone(origin)&#123; return Object.assign(&#123;&#125;, origin); &#125; // 采用这种方法克隆只能克隆原始对象自身的值，不能克隆它继承的值。 // 如果想要保持继承链，可以采用下面的代码。 function clone(origin)&#123; let originProto = Object.getPrototypeof(origin); return Object.assign(0bjObjectect.create(originProto), origin); &#125; 合并多个对象，将多个对象合并到某个对象。 const merge = (target, ...sources) => 0bject.assign(target, ...sources); // 如果希望合并后返回一个新对象，可以改写上面的函数，对一个空对象合并 const merge = (...sources) => Object.assign(&#123;&#125;, ...sources); Object.keys获取对象的key值，以数组存放返回 // 使用 Object.keys(obj) // 原理 function keys(object) &#123; const result = []; for (let key in object)&#123; object.hasOwnProperty(key) &amp;&amp; result.push(key); &#125; return result; &#125; Object.values获取对象的value值，以数组存放返回（不会遍历继承的属性，并且会过滤属性名为Symbol值的属性） 如果Object.values方法的参数是一个字符串，就会返回各个字符组成的一个数组。object.values(‘foo’) &#x3D;&gt; [‘f’, ‘o’, ‘o’] 如果参数不是对象，Object.values就会先将其转为对象。由于数值和布尔值的包装对象都不会为实例添加非继承的属性，因此Object.values会返回空数组。 // 使用 Object.values(obj) Object.values(42) // [] Object.values(true) // [] Object.entries获取对象可枚举的[key, value]键值对，以数组存放返回 for(let [key, value] in Object.entries(obj))&#123; // &#125; 实现entriesfunction entries(obj)&#123; let arr = []; for(let key of Object.keys(obj))&#123; arr.push([key, obj[key]]); &#125; return arr; &#125; Object.getOwnPropertyNames获取对象所有属性的key值，包括不可枚举属性，但是不包括Symbol属性 const obj = &#123; a: 1, b: 2 &#125; Object.getOwnPropertyNames(obj) // ['a', 'b'] Object.getOwnPropertySymbols获取一个对象所有Symbol属性 Object.getOwnPropertyDescriptor获取对象的数据属性描述 const obj = &#123; a: 1 &#125;; obj.b = 2; // a和b皆为数据属性 Object.getOwnPropertyDescriptor(obj, \"a\") // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.getOwnPropertyDescriptor(obj, \"b\") // &#123;value: 2, writable: true, enumerable: true, configurable: true&#125; Object.create根据指定的原型创建实例对象，实例完全继承原型对象，原型可以是null。 // 原型对象 const obj1 = &#123;&#125;; // 实例对象 const obj2 = Object.create(obj1); obj2.__proto__ === obj1 // true // Object.getPrototypeOf(obj2) === obj1 动手实现Object.createObject.create = function(prototype)&#123; function F()&#123;&#125;; F.prototype = prototype; F.prototype.constructor = F; return new F(); &#125; Object.getPrototypeOf获取一个对象的原型 // Object.getPrototypeOf(obj) function F() &#123;&#125;; const f = new F(); Object.getPrototypeOf(f) === F.prototype // true Object.setPrototypeOf为第一个参数对象设置原型，第二个参数是原型对象， Object.setPrototypeOf(obj, prototype); Object.isPrototypeOf判断该对象是否为参数对象的原型 function F()&#123;&#125;; const f = new F(); F.prototype.isPrototypeOf(f) // true Object.freeze冻结的对象是只读的，不能修改、不能添加新的属性。 Object.freeze(obj) 属性的可枚举性对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 let obj = &#123; foo: 123 &#125;; Object.getOwnPropertyDescriptor(obj, 'foo') // &#123; value: 123, writable: true, enumerable: true, configurable: true&#125; 会忽略enumerable为false的属性的操作 for…in循环: 只遍历对象自身的和继承的可枚举的属性。 Object.keys(): 返回对象自身的所有可枚举的属性的键名。 JSON.stringify(): 只串行化对象自身的可枚举的属性。 Object.assign()，会忽略enumerable为 false的属性，只拷贝对象自身可枚举的属性。 只有for…in 会返回继承的属性。实际上，引入enumerable的最初目的就是让某些属性可以规避掉for..in操作。比如，对象原型的toString方法以及数组的length属性就通过这种手段避免被for…in遍历到。 object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerablel // false object.getOwnPropertyDescriptor([], 'length').enumerable // false 另外，ES6规定，所有Class的原型的方法都是不可枚举的。 0bject.getOwnPropertyDescriptor(class&#123; foo()&#123;&#125; &#125;.prototype, 'foo').enumerable // false // class中声明的发法是 挂载到prototype上的 尽量不要用for…in循环，而用Object.keys()代替。 属性的遍历ES6一共有5种方法可以遍历对象的属性。 (1) for…infor…in循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)。 (2)Object.keys(obj)Object.keys返回一个数组，包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)。 (3)Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性)。 (4)Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 (5)Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性遵守同样的属性遍历的次序规则: 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 参考 MDN-Object 《Node.js12 实战》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"前端面试八股文","slug":"interview/interview01","date":"2020-08-22T12:05:02.000Z","updated":"2022-07-09T17:38:16.516Z","comments":true,"path":"2020/08/22/interview/interview01/","link":"","permalink":"http://example.com/2020/08/22/interview/interview01/","excerpt":"","text":"前端面试复习 中高级前端大厂面试秘籍 聊聊前端面试 「2021」高频前端面试题汇总之手写代码篇 前端面试复习计划 2022年我的前端面试准备 XPoet’s Blog","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"【计算机基础】常见数据结构与算法","slug":"computer_base/algorithm","date":"2020-05-22T10:35:29.000Z","updated":"2022-07-10T03:54:50.471Z","comments":true,"path":"2020/05/22/computer_base/algorithm/","link":"","permalink":"http://example.com/2020/05/22/computer_base/algorithm/","excerpt":"","text":"常用的数据结构字符串数组队列栈哈希表哈希算法之美 堆链表链表的9个基本操作 二叉树二叉树之美 算法排序算法梳理6大排序算法 查找二分搜索算法回溯算法带你看回溯算法之美 剪枝递归DFS和BFSDFS和BFS算法之美 动态规划动态规划算法之美 分治思想分治算法之美 贪心思想参考 awesome-coding-js 前端算法与数据结构总结","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://example.com/tags/Koa/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}