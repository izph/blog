{"meta":{"title":"前端点点滴滴","subtitle":"坚持初衷，成为更好的自己","description":"Stick to your original intention and become a better self","author":"zhongph","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2016-09-05T23:41:55.000Z","updated":"2022-06-29T17:04:15.671Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-10T08:46:45.363Z","updated":"2022-07-10T08:46:45.363Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"&#123; name: 'izph' age: 22, gender: '男', profession: 'Front End Developer', experience: '1年', address: '北京市', education: '本科', github: 'https://github.com/izph', blog: 'http://blog.yolo-ui.xyz', email: 'izph@foxmail.com', description: '来自HQU、信息与计算科学（数学方向）、前端开发程序员', skills: [ ['HTML', 'CSS', 'JavaScript', 'ES6'], ['Webpack', 'Git'], ['React', 'Node'] ], devTools: [ ['Visual Studio Code', 'Chrome DevTools'], ] &#125;"},{"title":"推荐阅读书单","date":"2022-07-10T09:02:31.490Z","updated":"2022-07-10T09:02:31.490Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"JavaScript高级程序设计（第4版） 学习JavaScript数据结构与算法（第3版）"},{"title":"友情链接","date":"2022-06-29T17:04:15.722Z","updated":"2022-06-29T17:04:15.722Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"pageName","date":"2022-07-03T16:35:17.000Z","updated":"2022-07-03T08:35:17.141Z","comments":true,"path":"pageName/index.html","permalink":"http://example.com/pageName/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-29T17:04:15.726Z","updated":"2022-06-29T17:04:15.726Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-29T17:04:15.723Z","updated":"2022-06-29T17:04:15.723Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"【React源码】React Concurrent模式","slug":"front_end/react-concurrent","date":"2022-09-10T22:32:08.000Z","updated":"2022-10-13T14:29:22.658Z","comments":true,"path":"2022/09/11/front_end/react-concurrent/","link":"","permalink":"http://example.com/2022/09/11/front_end/react-concurrent/","excerpt":"","text":"React Concurrent模式日常开发主要使用的是Legacy Mode（通过ReactDOM.render创建） React v17.0没有包含新特性。究其原因，v17.0主要的工作在于源码内部对Concurrent Mode的支持。所以v17版本也被称为“垫脚石”版本。 实现Concurrent Mode，最关键的一点是：实现异步可中断的更新。 架构的驱动力 —— Scheduler如果我们同步运行Fiber架构（通过ReactDOM.render），则Fiber架构与重构前并无区别。 但是当我们配合时间切片，就能根据宿主环境性能，为每个工作单元分配一个可运行时间，实现“异步可中断的更新”。于是，scheduler (opens new window)（调度器）产生了。 架构运行策略 —— lane模型React可以控制更新在Fiber架构中运行&#x2F;中断&#x2F;继续运行。 基于当前的架构，当一次更新在运行过程中被中断，过段时间再继续运行，这就是“异步可中断的更新”。 当一次更新在运行过程中被中断，转而重新开始一次新的更新，我们可以说：后一次更新打断了前一次更新。 这就是优先级的概念：后一次更新的优先级更高，他打断了正在进行的前一次更新。 多个优先级之间如何互相打断？优先级能否升降？本次更新应该赋予什么优先级？ 这就需要一个模型控制不同优先级之间的关系与行为，于是lane模型诞生了。 上层实现现在，我们可以说： 从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”。 那么基于该架构之上可以实现哪些有意思的功能？我们举几个例子： batchedUpdates如果我们在一次事件回调中触发多次更新，他们会被合并为一次更新进行处理。 如下代码执行只会触发一次更新： onClick() &#123; this.setState(&#123;stateA: 1&#125;); this.setState(&#123;stateB: false&#125;); this.setState(&#123;stateA: 2&#125;); &#125; 这种合并多个更新的优化方式被称为batchedUpdates。 batchedUpdates在很早的版本就存在了，不过之前的实现局限很多（脱离当前上下文环境的更新不会被合并）。 在Concurrent Mode中，是以优先级为依据对更新进行合并的，使用范围更广。 SuspenseSuspense可以在组件请求数据时展示一个pending状态。请求成功后渲染数据。 本质上讲Suspense内的组件子树比组件树的其他部分拥有更低的优先级。 useDeferredValueuseDeferredValue返回一个延迟响应的值，该值可能“延后”的最长时间为timeoutMs。 例子： const deferredValue = useDeferredValue(value, &#123; timeoutMs: 2000 &#125;); 在useDeferredValue内部会调用useState并触发一次更新。 这次更新的优先级很低，所以当前如果有正在进行中的更新，不会受useDeferredValue产生的更新影响。所以useDeferredValue能够返回延迟的值。 当超过timeoutMs后useDeferredValue产生的更新还没进行（由于优先级太低一直被打断），则会再触发一次高优先级更新。 总结除了以上介绍的实现，相信未来React还会开发更多基于Concurrent Mode的玩法。 Fiber架构在之前的章节已经学习了。所以，在本章接下来的部分，我们会按照上文的脉络，自底向上，从架构到实现讲解Concurrent Mode。 1. 时间切片2. 优先级调度本节我们学习这个两个功能是如何在Scheduler中实现的。 时间切片原理时间切片的本质是模拟实现requestIdleCallback。 除去“浏览器重排&#x2F;重绘”，下图是浏览器一帧中可以用于执行JS的时机。 一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback requestIdleCallback是在“浏览器重排&#x2F;重绘”后如果当前帧还有空余时间时被调用的。 浏览器并没有提供其他API能够在同样的时机（浏览器重排&#x2F;重绘后）调用以模拟其实现。 唯一能精准控制调用时机的API是requestAnimationFrame，他能让我们在“浏览器重排&#x2F;重绘”之前执行JS。 这也是为什么我们通常用这个API实现JS动画 —— 这是浏览器渲染前的最后时机，所以动画能快速被渲染。 所以，退而求其次，Scheduler的时间切片功能是通过task（宏任务）实现的。 最常见的task当属setTimeout了。但是有个task比setTimeout执行时机更靠前，那就是MessageChannel。 所以Scheduler将需要被执行的回调函数作为MessageChannel的回调执行。如果当前宿主环境不支持MessageChannel，则使用setTimeout。 你可以在这里看到MessageChannel的实现。这里看到setTimeout的实现 在React的render阶段，开启Concurrent Mode时，每次遍历前，都会通过Scheduler提供的shouldYield方法判断是否需要中断遍历，使浏览器有时间渲染： function workLoopConcurrent() &#123; // Perform work until Scheduler asks us to yield while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; performUnitOfWork(workInProgress); &#125; &#125; 是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。 在Schdeduler中，为任务分配的初始剩余时间为5ms。 你可以从这里看到初始剩余时间的定义 随着应用运行，会通过fps动态调整分配给任务的可执行时间。 你可以从这里看到动态分配任务时间 这也解释了为什么设计理念一节启用Concurrent Mode后每个任务的执行时间大体都是多于5ms的一小段时间 —— 每个时间切片被设定为5ms，任务本身再执行一小段时间，所以整体时间是多于5ms的时间 那么当shouldYield为true，以至于performUnitOfWork被中断后是如何重新启动的呢？我们会在介绍完”优先级调度”后解答。 优先级调度首先我们来了解优先级的来源。需要明确的一点是，Scheduler是独立于React的包，所以他的优先级也是独立于React的优先级的。 Scheduler对外暴露了一个方法unstable_runWithPriority。 这个方法接受一个优先级与一个回调函数，在回调函数内部调用获取优先级的方法都会取得第一个参数对应的优先级： function unstable_runWithPriority(priorityLevel, eventHandler) &#123; switch (priorityLevel) &#123; case ImmediatePriority: case UserBlockingPriority: case NormalPriority: case LowPriority: case IdlePriority: break; default: priorityLevel = NormalPriority; &#125; var previousPriorityLevel = currentPriorityLevel; currentPriorityLevel = priorityLevel; try &#123; return eventHandler(); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; &#125; &#125; 可以看到，Scheduler内部存在5种优先级。 在React内部凡是涉及到优先级调度的地方，都会使用unstable_runWithPriority。 比如，我们知道commit阶段是同步执行的。可以看到，commit阶段的起点commitRoot方法的优先级为ImmediateSchedulerPriority。 ImmediateSchedulerPriority即ImmediatePriority的别名，为最高优先级，会立即执行。 function commitRoot(root) &#123; const renderPriorityLevel = getCurrentPriorityLevel(); runWithPriority( ImmediateSchedulerPriority, commitRootImpl.bind(null, root, renderPriorityLevel), ); return null; &#125; 优先级的意义Scheduler对外暴露最重要的方法便是unstable_scheduleCallback。该方法用于以某个优先级注册回调函数。 比如在React中，之前讲过在commit阶段的beforeMutation阶段会调度useEffect的回调： if (!rootDoesHavePassiveEffects) &#123; rootDoesHavePassiveEffects = true; scheduleCallback(NormalSchedulerPriority, () => &#123; flushPassiveEffects(); return null; &#125;); &#125; 这里的回调便是通过scheduleCallback调度的，优先级为NormalSchedulerPriority，即NormalPriority。 不同优先级意味着什么？不同优先级意味着不同时长的任务过期时间： var timeout; switch (priorityLevel) &#123; case ImmediatePriority: timeout = IMMEDIATE_PRIORITY_TIMEOUT; break; case UserBlockingPriority: timeout = USER_BLOCKING_PRIORITY_TIMEOUT; break; case IdlePriority: timeout = IDLE_PRIORITY_TIMEOUT; break; case LowPriority: timeout = LOW_PRIORITY_TIMEOUT; break; case NormalPriority: default: timeout = NORMAL_PRIORITY_TIMEOUT; break; &#125; var expirationTime = startTime + timeout; 其中： // Times out immediately var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out var USER_BLOCKING_PRIORITY_TIMEOUT = 250; var NORMAL_PRIORITY_TIMEOUT = 5000; var LOW_PRIORITY_TIMEOUT = 10000; // Never times out var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; 可以看到，如果一个任务的优先级是ImmediatePriority，对应IMMEDIATE_PRIORITY_TIMEOUT为-1，那么 var expirationTime = startTime - 1; 则该任务的过期时间比当前时间还短，表示他已经过期了，需要立即被执行。 不同优先级任务的排序我们已经知道优先级意味着任务的过期时间。设想一个大型React项目，在某一刻，存在很多不同优先级的任务，对应不同的过期时间。 同时，又因为任务可以被延迟，所以我们可以将这些任务按是否被延迟分为： 已就绪任务 未就绪任务 if (typeof options === 'object' &amp;&amp; options !== null) &#123; var delay = options.delay; if (typeof delay === 'number' &amp;&amp; delay > 0) &#123; // 任务被延迟 startTime = currentTime + delay; &#125; else &#123; startTime = currentTime; &#125; &#125; else &#123; startTime = currentTime; &#125; 所以，Scheduler存在两个队列： timerQueue：保存未就绪任务 taskQueue：保存已就绪任务 每当有新的未就绪的任务被注册，我们将其插入timerQueue并根据开始时间重新排列timerQueue中任务的顺序。 当timerQueue中有任务就绪，即startTime &lt;= currentTime ，我们将其取出并加入taskQueue。 取出taskQueue中最早过期的任务并执行他。 为了能在O(1)复杂度找到两个队列中时间最早的那个任务，Scheduler使用小顶堆实现了优先级队列。 你可以在这里看到优先级队列的实现 至此，我们了解了Scheduler的实现。现在可以回答介绍时间切片时提到的问题： 那么当shouldYield为true，以至于performUnitOfWork被中断后是如何重新启动的呢？ 在“取出taskQueue中最早过期的任务并执行他”这一步中有如下关键步骤： const continuationCallback = callback(didUserCallbackTimeout); currentTime = getCurrentTime(); if (typeof continuationCallback === 'function') &#123; // continuationCallback是函数 currentTask.callback = continuationCallback; markTaskYield(currentTask, currentTime); &#125; else &#123; if (enableProfiling) &#123; markTaskCompleted(currentTask, currentTime); currentTask.isQueued = false; &#125; if (currentTask === peek(taskQueue)) &#123; // 将当前任务清除 pop(taskQueue); &#125; &#125; advanceTimers(currentTime); 当注册的回调函数执行后的返回值continuationCallback为function，会将continuationCallback作为当前任务的回调函数。 如果返回值不是function，则将当前被执行的任务清除出taskQueue。 render阶段被调度的函数为performConcurrentWorkOnRoot，在该函数末尾有这样一段代码： if (root.callbackNode === originalCallbackNode) &#123; // The task node scheduled for this root is the same one that's // currently executed. Need to return a continuation. return performConcurrentWorkOnRoot.bind(null, root); &#125; 可以看到，在满足一定条件时，该函数会将自己作为返回值。 你可以在这里看到这段代码 总结刚才我们讲到，Scheduler与React是两套优先级机制。那么React中的优先级是如何运转的？我们会在下一节介绍。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【React源码】React Hooks","slug":"front_end/react-hooks","date":"2022-08-25T20:12:49.000Z","updated":"2022-10-13T14:22:47.708Z","comments":true,"path":"2022/08/26/front_end/react-hooks/","link":"","permalink":"http://example.com/2022/08/26/front_end/react-hooks/","excerpt":"","text":"React HooksfunctionComponent有自己对应的fiber，fiber对象包含多个属性。如memoizedState保存该functionComponent的hook。stateNode保存的是对应的function。 在React中，通过判断 current是否存在，来确认是mount还是update。 render阶段会触发执行function函数，函数返回jsx useState包含两部分，state和setState，state是基于baseState、以及拥有足够优先级的update实现的。 update的产生是由于调用setState方法。 调用useState方法会执行state的计算过程，返回的setState方法会执行update的创建过程。 memoizedState如何保存多个hook？会使用链表这种数据结构保存hook 例子中，全局变量workInProgressHook表示当前正在执行的hook。 render阶段会从 fiber.memoizedState取出第一个hook（hook的初始化） 在mount时，首先需要创建hook，hook数据结构是用来保存update的 update在ClassComponent和HostRoot中，会保存在updateQueue，hook的数据结构和updateQueue类似 多个hook可以通过next指针连接，形成单项链表。 let hook = &#123; queue: &#123; pending: null, // 保存了最后一个update &#125; // mount阶段的 memoizedState就是 useState的 初始值 initialState memoizedState: null, // 保存了hook对应的state属性 next: null, // next指针 用于指向下一个 hook &#125; Hooks的数据结构在Hooks中，组件mount时的hook与update时的hook来源于不同的对象，这类对象在React源码中被称为dispatcher。 // mount时的Dispatcher const HooksDispatcherOnMount: Dispatcher = &#123; useCallback: mountCallback, useContext: readContext, useEffect: mountEffect, useImperativeHandle: mountImperativeHandle, useLayoutEffect: mountLayoutEffect, useMemo: mountMemo, useReducer: mountReducer, useRef: mountRef, useState: mountState, // ...省略 &#125;; // update时的Dispatcher const HooksDispatcherOnUpdate: Dispatcher = &#123; useCallback: updateCallback, useContext: readContext, useEffect: updateEffect, useImperativeHandle: updateImperativeHandle, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: updateReducer, useRef: updateRef, useState: updateState, // ...省略 &#125;; 可见，mount时调用的hook和update时调用的hook其实是两个不同的函数。 在FunctionComponent render之前，会根据FunctionComponent对应fiber的以下条件区分mount与update。 current === null || current.memoizedState === null 并将不同情况对应的dispatcher赋值给全局变量ReactCurrentDispatcher的current属性。 ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate; export function renderWithHooks&lt;Props, SecondArg>( current: Fiber | null, workInProgress: Fiber, Component: (p: Props, arg: SecondArg) => any, props: Props, secondArg: SecondArg, nextRenderLanes: Lanes, ): any &#123; renderLanes = nextRenderLanes; currentlyRenderingFiber = workInProgress; workInProgress.memoizedState = null; workInProgress.updateQueue = null; workInProgress.lanes = NoLanes; if (__DEV__) &#123; if (current !== null &amp;&amp; current.memoizedState !== null) &#123; ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV; &#125; else if (hookTypesDev !== null) &#123; ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV; &#125; else &#123; // mount ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV; &#125; &#125; else &#123; ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate; &#125; // 调用FunctionComponent，内部会触发hook let children = Component(props, secondArg); // 省略 return children; &#125; 在FunctionComponent render时，会从ReactCurrentDispatcher.current（即当前dispatcher）中寻找需要的hook。 换言之，不同的调用栈上下文为ReactCurrentDispatcher.current赋值不同的dispatcher，则FunctionComponent render时调用的hook也是不同的函数。 useState在上下文的中对应着不同的函数，在mount阶段，使用HooksDispatcherOnMount中的Dispatcher，useState是mountState。在update阶段，使用HooksDispatcherOnUpdate， useState是updateState。不同的上下文，使用不同的Dispatcher，不同的Dispatcher中的hook指向不同的实现，这样可能根据不同的上下文，对hook的具体实现做一些区别的对待。 dispatcher在源码中的定义export const ContextOnlyDispatcher: Dispatcher = &#123; readContext, useCallback: throwInvalidHookError, useContext: throwInvalidHookError, useEffect: throwInvalidHookError, useImperativeHandle: throwInvalidHookError, useLayoutEffect: throwInvalidHookError, useMemo: throwInvalidHookError, useReducer: throwInvalidHookError, useRef: throwInvalidHookError, useState: throwInvalidHookError, useDebugValue: throwInvalidHookError, useResponder: throwInvalidHookError, useDeferredValue: throwInvalidHookError, useTransition: throwInvalidHookError, useMutableSource: throwInvalidHookError, useOpaqueIdentifier: throwInvalidHookError, unstable_isNewReconciler: enableNewReconciler, &#125;; const HooksDispatcherOnMount: Dispatcher = &#123; readContext, useCallback: mountCallback, useContext: readContext, useEffect: mountEffect, useImperativeHandle: mountImperativeHandle, useLayoutEffect: mountLayoutEffect, useMemo: mountMemo, useReducer: mountReducer, useRef: mountRef, useState: mountState, useDebugValue: mountDebugValue, useResponder: createDeprecatedResponderListener, useDeferredValue: mountDeferredValue, useTransition: mountTransition, useMutableSource: mountMutableSource, useOpaqueIdentifier: mountOpaqueIdentifier, unstable_isNewReconciler: enableNewReconciler, &#125;; const HooksDispatcherOnUpdate: Dispatcher = &#123; readContext, useCallback: updateCallback, useContext: readContext, useEffect: updateEffect, useImperativeHandle: updateImperativeHandle, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: updateReducer, useRef: updateRef, useState: updateState, useDebugValue: updateDebugValue, useResponder: createDeprecatedResponderListener, useDeferredValue: updateDeferredValue, useTransition: updateTransition, useMutableSource: updateMutableSource, useOpaqueIdentifier: updateOpaqueIdentifier, unstable_isNewReconciler: enableNewReconciler, &#125;; const HooksDispatcherOnRerender: Dispatcher = &#123; readContext, useCallback: updateCallback, useContext: readContext, useEffect: updateEffect, useImperativeHandle: updateImperativeHandle, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: rerenderReducer, useRef: updateRef, useState: rerenderState, useDebugValue: updateDebugValue, useResponder: createDeprecatedResponderListener, useDeferredValue: rerenderDeferredValue, useTransition: rerenderTransition, useMutableSource: updateMutableSource, useOpaqueIdentifier: rerenderOpaqueIdentifier, unstable_isNewReconciler: enableNewReconciler, &#125;; mountStatefunction mountState&lt;S>( initialState: (() => S) | S, ): [S, Dispatch&lt;BasicStateAction&lt;S>>] &#123; // mount时为该useState生成hook const hook = mountWorkInProgressHook(); if (typeof initialState === 'function') &#123; // $FlowFixMe: Flow doesn't like mixed types initialState = initialState(); &#125; // 赋值initialState hook.memoizedState = hook.baseState = initialState; const queue = hook.queue = &#123; pending: null, dispatch: null, // 绑定当前的fiber // 处理特定下的优化 lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState), // initialState: any &#125;; const dispatch: Dispatch&lt;BasicStateAction&lt;S>, > = (queue.dispatch = (dispatchAction.bind( null, currentlyRenderingFiber, // 当前的fiber queue, ): any)); return [hook.memoizedState, dispatch]; &#125; // 创建mount时的hook function mountWorkInProgressHook(): Hook &#123; // 创建一个对象hook const hook: Hook = &#123; memoizedState: null, baseState: null, // 优先级相关 baseQueue: null, // 优先级相关 queue: null, next: null, &#125;; if (workInProgressHook === null) &#123; // workInProgressHook可能是一个全局变量？ // This is the first hook in the list currentlyRenderingFiber.memoizedState = workInProgressHook = hook; &#125; else &#123; // Append to the end of the list // 把 hook挂载到上一个hook的next下 workInProgressHook = workInProgressHook.next = hook; &#125; return workInProgressHook; &#125; // 和mountState基本一致 function mountReducer&lt;S, I, A>( reducer: (S, A) => S, initialArg: I, init?: I => S, ): [S, Dispatch&lt;A>] &#123; const hook = mountWorkInProgressHook(); let initialState; if (init !== undefined) &#123; initialState = init(initialArg); &#125; else &#123; initialState = ((initialArg: any): S); &#125; hook.memoizedState = hook.baseState = initialState; const queue = (hook.queue = &#123; pending: null, dispatch: null, lastRenderedReducer: reducer, lastRenderedState: (initialState: any), &#125;); const dispatch: Dispatch&lt;A> = (queue.dispatch = (dispatchAction.bind( null, currentlyRenderingFiber, queue, ): any)); return [hook.memoizedState, dispatch]; &#125; updateStateuseState是预制了reducer的useReducer function updateState&lt;S>( initialState: (() => S) | S, ): [S, Dispatch&lt;BasicStateAction&lt;S>>] &#123; return updateReducer(basicStateReducer, (initialState: any)); &#125; type BasicStateAction&lt;S> = (S => S) | S; function basicStateReducer&lt;S>(state: S, action: BasicStateAction&lt;S>): S &#123; // $FlowFixMe: Flow doesn't like mixed types return typeof action === 'function' ? action(state) : action; &#125; function updateReducer&lt;S, I, A>( reducer: (S, A) => S, initialArg: I, init?: I => S, ): [S, Dispatch&lt;A>] &#123; // 获取当前的hook const hook = updateWorkInProgressHook(); const queue = hook.queue; queue.lastRenderedReducer = reducer; const current: Hook = (currentHook: any); // The last rebase update that is NOT part of the base state. let baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet. const pendingQueue = queue.pending; if (pendingQueue !== null) &#123; // We have new updates that haven't been processed yet. // We'll add them to the base queue. if (baseQueue !== null) &#123; // Merge the pending queue and the base queue. const baseFirst = baseQueue.next; const pendingFirst = pendingQueue.next; baseQueue.next = pendingFirst; pendingQueue.next = baseFirst; &#125; current.baseQueue = baseQueue = pendingQueue; queue.pending = null; &#125; if (baseQueue !== null) &#123; // We have a queue to process. const first = baseQueue.next; let newState = current.baseState; let newBaseState = null; let newBaseQueueFirst = null; let newBaseQueueLast = null; let update = first; do &#123; const updateLane = update.lane; if (!isSubsetOfLanes(renderLanes, updateLane)) &#123; const clone: Update&lt;S, A> = &#123; lane: updateLane, action: update.action, eagerReducer: update.eagerReducer, eagerState: update.eagerState, next: (null: any), &#125;; if (newBaseQueueLast === null) &#123; newBaseQueueFirst = newBaseQueueLast = clone; newBaseState = newState; &#125; else &#123; newBaseQueueLast = newBaseQueueLast.next = clone; &#125; currentlyRenderingFiber.lanes = mergeLanes( currentlyRenderingFiber.lanes, updateLane, ); markSkippedUpdateLanes(updateLane); &#125; else &#123; // This update does have sufficient priority. if (newBaseQueueLast !== null) &#123; const clone: Update&lt;S, A> = &#123; lane: NoLane, action: update.action, eagerReducer: update.eagerReducer, eagerState: update.eagerState, next: (null: any), &#125;; newBaseQueueLast = newBaseQueueLast.next = clone; &#125; // Process this update. if (update.eagerReducer === reducer) &#123; newState = ((update.eagerState: any): S); &#125; else &#123; const action = update.action; newState = reducer(newState, action); &#125; &#125; update = update.next; &#125; while (update !== null &amp;&amp; update !== first); if (newBaseQueueLast === null) &#123; newBaseState = newState; &#125; else &#123; newBaseQueueLast.next = (newBaseQueueFirst: any); &#125; // Mark that the fiber performed work, but only if the new state is // different from the current state. if (!is(newState, hook.memoizedState)) &#123; markWorkInProgressReceivedUpdate(); &#125; // 最终计算完成 hook.memoizedState = newState; hook.baseState = newBaseState; hook.baseQueue = newBaseQueueLast; queue.lastRenderedState = newState; &#125; const dispatch: Dispatch&lt;A> = (queue.dispatch: any); return [hook.memoizedState, dispatch]; &#125; // 处理render阶段、update阶段的更新的hook，并返回这个hook function updateWorkInProgressHook(): Hook &#123; let nextCurrentHook: null | Hook; if (currentHook === null) &#123; const current = currentlyRenderingFiber.alternate; if (current !== null) &#123; nextCurrentHook = current.memoizedState; &#125; else &#123; nextCurrentHook = null; &#125; &#125; else &#123; nextCurrentHook = currentHook.next; &#125; let nextWorkInProgressHook: null | Hook; if (workInProgressHook === null) &#123; nextWorkInProgressHook = currentlyRenderingFiber.memoizedState; &#125; else &#123; nextWorkInProgressHook = workInProgressHook.next; &#125; if (nextWorkInProgressHook !== null) &#123; // There's already a work-in-progress. Reuse it. workInProgressHook = nextWorkInProgressHook; nextWorkInProgressHook = workInProgressHook.next; currentHook = nextCurrentHook; &#125; else &#123; currentHook = nextCurrentHook; const newHook: Hook = &#123; memoizedState: currentHook.memoizedState, baseState: currentHook.baseState, baseQueue: currentHook.baseQueue, queue: currentHook.queue, next: null, &#125;; if (workInProgressHook === null) &#123; // This is the first hook in the list. currentlyRenderingFiber.memoizedState = workInProgressHook = newHook; &#125; else &#123; // Append to the end of the list. workInProgressHook = workInProgressHook.next = newHook; &#125; &#125; return workInProgressHook; &#125; dispatchActionfunction dispatchAction&lt;S, A>( fiber: Fiber, queue: UpdateQueue&lt;S, A>, action: A, ) &#123; // 获取当前事件的时间 const eventTime = requestEventTime(); // 获取当前fiber的优先级 const lane = requestUpdateLane(fiber); // 创建update对象 const update: Update&lt;S, A> = &#123; lane, action, eagerReducer: null, eagerState: null, next: (null: any), &#125;; // Append the update to the end of the list. const pending = queue.pending; if (pending === null) &#123; // This is the first update. Create a circular list. update.next = update; &#125; else &#123; update.next = pending.next; pending.next = update; &#125; // 将 update保存在pending上 queue.pending = update; const alternate = fiber.alternate; // 是否是render阶段的更新 if ( fiber === currentlyRenderingFiber || (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber) ) &#123; // render阶段的更新：标记一个变量 didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true; &#125; else &#123; // 不是 render阶段的更新 if ( fiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes) ) &#123; const lastRenderedReducer = queue.lastRenderedReducer; if (lastRenderedReducer !== null) &#123; try &#123; const currentState: S = (queue.lastRenderedState: any); const eagerState = lastRenderedReducer(currentState, action); // 优化逻辑 update.eagerReducer = lastRenderedReducer; update.eagerState = eagerState; if (is(eagerState, currentState)) &#123; return; &#125; &#125; catch (error) &#123; // Suppress the error. It will throw again in the render phase. &#125; finally &#123; &#125; &#125; &#125; scheduleUpdateOnFiber(fiber, lane, eventTime); &#125; if (enableSchedulingProfiler) &#123; markStateUpdateScheduled(fiber, lane); &#125; &#125; 一个dispatcher使用场景 当错误的书写了嵌套形式的hook，如： useEffect(() => &#123; useState(0); &#125;) 此时ReactCurrentDispatcher.current已经指向ContextOnlyDispatcher，所以调用useState实际会调用throwInvalidHookError，直接抛出异常。 export const ContextOnlyDispatcher: Dispatcher = &#123; useCallback: throwInvalidHookError, useContext: throwInvalidHookError, useEffect: throwInvalidHookError, useImperativeHandle: throwInvalidHookError, useLayoutEffect: throwInvalidHookError, // ...省略 Hook的数据结构const hook: Hook = &#123; memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null, &#125;; // 源码中的声明 function mountWorkInProgressHook(): Hook &#123; const hook: Hook = &#123; memoizedState: null, // 保存hook对应的state baseState: null, baseQueue: null, queue: null, // 保存update的queue next: null, // 与下一个Hook连接形成单向无环链表 &#125;; if (workInProgressHook === null) &#123; // This is the first hook in the list currentlyRenderingFiber.memoizedState = workInProgressHook = hook; &#125; else &#123; // Append to the end of the list workInProgressHook = workInProgressHook.next = hook; &#125; return workInProgressHook; &#125; memoizedState::: warning 注意hook与FunctionComponent fiber都存在memoizedState属性，不要混淆他们的概念。 fiber.memoizedState：FunctionComponent对应fiber保存的Hooks链表。 hook.memoizedState：Hooks链表中保存的单一hook对应的数据。::: 不同类型hook的memoizedState保存不同类型数据，具体如下： useState：对于const [state, updateState] = useState(initialState)，memoizedState保存state的值 useReducer：对于const [state, dispatch] = useReducer(reducer, &#123;&#125;);，memoizedState保存state的值 useEffect：memoizedState保存包含useEffect回调函数、依赖项等的链表数据结构effect，你可以在这里看到effect的创建过程。effect链表同时会保存在fiber.updateQueue中 useRef：对于useRef(1)，memoizedState保存&#123;current: 1&#125; useMemo：对于useMemo(callback, [depA])，memoizedState保存[callback(), depA] useCallback：对于useCallback(callback, [depA])，memoizedState保存[callback, depA]。与useMemo的区别是，useCallback保存的是callback函数本身，而useMemo保存的是callback函数的执行结果 有些hook是没有memoizedState的，比如：useContext useState和useReducer的实现流程概览我们将这两个Hook的工作流程分为声明阶段和调用阶段，对于： function App() &#123; const [state, dispatch] = useReducer(reducer, &#123;a: 1&#125;); const [num, updateNum] = useState(0); return ( &lt;div> &lt;button onClick=&#123;() => dispatch(&#123;type: 'a'&#125;)&#125;>&#123;state.a&#125;&lt;/button> &lt;button onClick=&#123;() => updateNum(num => num + 1)&#125;>&#123;num&#125;&lt;/button> &lt;/div> ) &#125; 声明阶段即App调用时，会依次执行useReducer与useState方法。 调用阶段即点击按钮后，dispatch或updateNum被调用时。 声明阶段当FunctionComponent进入render阶段的beginWork时，会调用renderWithHooks方法。 该方法内部会执行FunctionComponent对应函数（即fiber.type）。 你可以在这里看到这段逻辑 对于这两个Hook，他们的源码如下： function useState(initialState) &#123; var dispatcher = resolveDispatcher(); return dispatcher.useState(initialState); &#125; function useReducer(reducer, initialArg, init) &#123; var dispatcher = resolveDispatcher(); return dispatcher.useReducer(reducer, initialArg, init); &#125; 正如上一节dispatcher所说，在不同场景下，同一个Hook会调用不同处理函数。 我们分别讲解mount与update两个场景。 mount时mount时，useReducer会调用mountReducer，useState会调用mountState。 我们来简单对比这这两个方法： function mountState&lt;S>( initialState: (() => S) | S, ): [S, Dispatch&lt;BasicStateAction&lt;S>>] &#123; // 创建并返回当前的hook const hook = mountWorkInProgressHook(); // ...赋值初始state // 创建queue const queue = (hook.queue = &#123; pending: null, dispatch: null, lastRenderedReducer: basicStateReducer, lastRenderedState: (initialState: any), &#125;); // ...创建dispatch return [hook.memoizedState, dispatch]; &#125; function mountReducer&lt;S, I, A>( reducer: (S, A) => S, initialArg: I, init?: I => S, ): [S, Dispatch&lt;A>] &#123; // 创建并返回当前的hook const hook = mountWorkInProgressHook(); // ...赋值初始state // 创建queue const queue = (hook.queue = &#123; pending: null, dispatch: null, lastRenderedReducer: reducer, lastRenderedState: (initialState: any), &#125;); // ...创建dispatch return [hook.memoizedState, dispatch]; &#125; 其中mountWorkInProgressHook方法会创建并返回对应hook，对应极简Hooks实现中useState方法的isMount逻辑部分。 可以看到，mount时这两个Hook的唯一区别为queue参数的lastRenderedReducer字段。 queue的数据结构如下： const queue = (hook.queue = &#123; // 与极简实现中的同名字段意义相同，保存update对象 pending: null, // 保存dispatchAction.bind()的值 dispatch: null, // 上一次render时使用的reducer lastRenderedReducer: reducer, // 上一次render时的state lastRenderedState: (initialState: any), &#125;); 其中，useReducer的lastRenderedReducer为传入的reducer参数。useState的lastRenderedReducer为basicStateReducer。 basicStateReducer方法如下： function basicStateReducer&lt;S>(state: S, action: BasicStateAction&lt;S>): S &#123; return typeof action === 'function' ? action(state) : action; &#125; 可见，useState即reducer参数为basicStateReducer的useReducer。 mount时的整体运行逻辑与极简实现的isMount逻辑类似，你可以对照着看。 update时如果说mount时这两者还有区别，那update时，useReducer与useState调用的则是同一个函数updateReducer。 function updateReducer&lt;S, I, A>( reducer: (S, A) => S, initialArg: I, init?: I => S, ): [S, Dispatch&lt;A>] &#123; // 获取当前hook const hook = updateWorkInProgressHook(); const queue = hook.queue; queue.lastRenderedReducer = reducer; // ...同update与updateQueue类似的更新逻辑 const dispatch: Dispatch&lt;A> = (queue.dispatch: any); return [hook.memoizedState, dispatch]; &#125; 整个流程可以概括为一句话： 找到对应的hook，根据update计算该hook的新state并返回。 mount时获取当前hook使用的是mountWorkInProgressHook，而update时使用的是updateWorkInProgressHook，这里的原因是： mount时可以确定是调用ReactDOM.render或相关初始化API产生的更新，只会执行一次。 update可能是在事件回调或副作用中触发的更新或者是render阶段触发的更新，为了避免组件无限循环更新，后者需要区别对待。 举个render阶段触发的更新的例子： function App() &#123; const [num, updateNum] = useState(0); updateNum(num + 1); return ( &lt;button onClick=&#123;() => updateNum(num => num + 1)&#125;>&#123;num&#125;&lt;/button> ) &#125; 在这个例子中，App调用时，代表已经进入render阶段执行renderWithHooks。 在App内部，调用updateNum会触发一次更新。如果不对这种情况下触发的更新作出限制，那么这次更新会开启一次新的render阶段，最终会无限循环更新。 基于这个原因，React用一个标记变量didScheduleRenderPhaseUpdate判断是否是render阶段触发的更新。 updateWorkInProgressHook方法也会区分这两种情况来获取对应hook。 获取对应hook，接下来会根据hook中保存的state计算新的state，这个步骤同Update一节一致。 调用阶段调用阶段会执行dispatchAction，此时该FunctionComponent对应的fiber以及hook.queue已经通过调用bind方法预先作为参数传入。 function dispatchAction(fiber, queue, action) &#123; // ...创建update var update = &#123; eventTime: eventTime, lane: lane, suspenseConfig: suspenseConfig, action: action, eagerReducer: null, eagerState: null, next: null &#125;; // ...将update加入queue.pending var alternate = fiber.alternate; if (fiber === currentlyRenderingFiber$1 || alternate !== null &amp;&amp; alternate === currentlyRenderingFiber$1) &#123; // render阶段触发的更新 didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true; &#125; else &#123; if (fiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) &#123; // ...fiber的updateQueue为空，优化路径 &#125; scheduleUpdateOnFiber(fiber, lane, eventTime); &#125; &#125; 整个过程可以概括为： 创建update，将update加入queue.pending中，并开启调度。 这里值得注意的是if...else...逻辑，其中： if (fiber === currentlyRenderingFiber$1 || alternate !== null &amp;&amp; alternate === currentlyRenderingFiber$1) currentlyRenderingFiber即workInProgress，workInProgress存在代表当前处于render阶段。 触发更新时通过bind预先保存的fiber与workInProgress全等，代表本次更新发生于FunctionComponent对应fiber的render阶段。 所以这是一个render阶段触发的更新，需要标记变量didScheduleRenderPhaseUpdate，后续单独处理。 再来关注： if (fiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes)) fiber.lanes保存fiber上存在的update的优先级。 fiber.lanes === NoLanes意味着fiber上不存在update。 我们已经知道，通过update计算state发生在声明阶段，这是因为该hook上可能存在多个不同优先级的update，最终state的值由多个update共同决定。 但是当fiber上不存在update，则调用阶段创建的update为该hook上第一个update，在声明阶段计算state时也只依赖于该update，完全不需要进入声明阶段再计算state。 这样做的好处是：如果计算出的state与该hook之前保存的state一致，那么完全不需要开启一次调度。即使计算出的state与该hook之前保存的state不一致，在声明阶段也可以直接使用调用阶段已经计算出的state。 你可以在这里看到这段提前计算state的逻辑 小Tip我们通常认为，useReducer(reducer, initialState)的传参为初始化参数，在以后的调用中都不可变。 但是在updateReducer方法中，可以看到lastRenderedReducer在每次调用时都会重新赋值。 function updateReducer(reducer, initialArg, init) &#123; // ... queue.lastRenderedReducer = reducer; // ... 也就是说，reducer参数是随时可变的。 每秒useReducer使用的reducer会改变一次 点击按钮后会随时间不同会出现+1或-1的效果 useEffectFunctionComponent中，所有的hook是保存在fiber.memoizedState上的，并且它们会形成一条单项链表。这些hooks的调用顺序是不变的。 在一个FunctionComponent中，多个useEffect的effect是通过链表连接，形成环状链表。 在mount阶段时，会调用mountEffectImpl；在update阶段，调用updateEffectImpl。 // mount阶段的useEffect function mountEffect( create: () => (() => void) | void, deps: Array&lt;mixed> | void | null, ): void &#123; return mountEffectImpl( UpdateEffect | PassiveEffect, HookPassive, // flags的标记 create, deps, ); &#125; // update阶段的useEffect function updateEffect( create: () => (() => void) | void, deps: Array&lt;mixed> | void | null, ): void &#123; return updateEffectImpl( UpdateEffect | PassiveEffect, HookPassive, // flags的标记 create, deps, ); &#125; function mountEffectImpl(fiberFlags, hookFlags, create, deps): void &#123; // 获取当前hook对应的数据 const hook = mountWorkInProgressHook(); // 依赖项 const nextDeps = deps === undefined ? null : deps; // 设置当前fiber阶段 的flags currentlyRenderingFiber.flags |= fiberFlags; // pushEffect 返回effect // 保存当前hook上最后一个effect数据，它是一条环状链表 hook.memoizedState = pushEffect( HookHasEffect | hookFlags, create, undefined, nextDeps, ); &#125; export type Hook = &#123;| memoizedState: any, baseState: any, baseQueue: Update&lt;any, any> | null, queue: UpdateQueue&lt;any, any> | null, next: Hook | null, |&#125;; let currentHook: Hook | null = null; // 在update中才能取到上一个effect的destroy function updateEffectImpl(fiberFlags, hookFlags, create, deps): void &#123; // 获取当前hook对应的数据 const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; let destroy = undefined; if (currentHook !== null) &#123; // 取出上一次更新的effect const prevEffect = currentHook.memoizedState; // 从 上一次effect中取出销毁函数，等到create执行之后才有destroy destroy = prevEffect.destroy; if (nextDeps !== null) &#123; const prevDeps = prevEffect.deps; // 浅比较 前后的deps是否相等 if (areHookInputsEqual(nextDeps, prevDeps)) &#123; // 进入这里，则依赖项没有改变，执行pushEffect，并return终止向下执行 pushEffect(hookFlags, create, destroy, nextDeps); return; &#125; &#125; &#125; // 依赖项改变的逻辑 currentlyRenderingFiber.flags |= fiberFlags; // pushEffect 返回effect // 存在HookHasEffect | hookFlags 情况才本次的effect才会被执行 hook.memoizedState = pushEffect( HookHasEffect | hookFlags, // HookHasEffect = /* */ 0b001; create, destroy, nextDeps, ); &#125; // deps浅比较 function areHookInputsEqual( nextDeps: Array&lt;mixed>, prevDeps: Array&lt;mixed> | null, ) &#123; // deps浅比较的原理 for (let i = 0; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123; if (is(nextDeps[i], prevDeps[i])) &#123; // is是Object.is continue; &#125; return false; &#125; return true; &#125; function createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue &#123; return &#123; lastEffect: null, &#125;; &#125; // currentlyRenderingFiber即workInProgress 当前函数组件的fiber function pushEffect(tag, create, destroy, deps) &#123; const effect: Effect = &#123; tag, create, // useEffect的回调函数 destroy, // useEffect的销毁函数 deps, // 依赖项 // Circular next: null, // 指向下一个effect &#125;; // 创建updateQueue let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any); if (componentUpdateQueue === null) &#123; componentUpdateQueue = createFunctionComponentUpdateQueue(); currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any); // 将创建的effect挂载到 UpdateQueue.lastEffect，并让 effect 形成一条环状链表 componentUpdateQueue.lastEffect = effect.next = effect; &#125; else &#123; const lastEffect = componentUpdateQueue.lastEffect; if (lastEffect === null) &#123; componentUpdateQueue.lastEffect = effect.next = effect; &#125; else &#123; // 在环状链表中插入effect const firstEffect = lastEffect.next; lastEffect.next = effect; effect.next = firstEffect; componentUpdateQueue.lastEffect = effect; &#125; &#125; // 返回effect return effect; &#125; commit阶段流程中，在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。 通过flushPassiveEffects方法内部探索useEffect的工作原理。 flushPassiveEffectsImplflushPassiveEffects内部会设置优先级，并执行flushPassiveEffectsImpl。 你可以从这里看到flushPassiveEffects的代码 flushPassiveEffectsImpl主要做三件事： 调用该useEffect在上一次render时的销毁函数 调用该useEffect在本次render时的回调函数 如果存在同步任务，不需要等待下次事件循环的宏任务，提前执行他 本节我们关注前两步。 在v16中第一步是同步执行的，在官方博客中提到： 副作用清理函数（如果存在）在 React 16 中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。 基于这个原因，在v17.0.0中，useEffect的两个阶段会在页面渲染后（layout阶段后）异步执行。 事实上，从代码中看，v16.13.1中已经是异步执行了 接下来我们详细讲解这两个步骤。 阶段一：销毁函数的执行useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。 这是因为多个组件间可能共用同一个ref。 如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。 在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。 在阶段一，会遍历并执行所有useEffect的销毁函数。 // pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect const unmountEffects = pendingPassiveHookEffectsUnmount; pendingPassiveHookEffectsUnmount = []; for (let i = 0; i &lt; unmountEffects.length; i += 2) &#123; const effect = ((unmountEffects[i]: any): HookEffect); const fiber = ((unmountEffects[i + 1]: any): Fiber); const destroy = effect.destroy; effect.destroy = undefined; if (typeof destroy === 'function') &#123; // 销毁函数存在则执行 try &#123; destroy(); &#125; catch (error) &#123; captureCommitPhaseError(fiber, error); &#125; &#125; &#125; 其中pendingPassiveHookEffectsUnmount数组的索引i保存需要销毁的effect，i+1保存该effect对应的fiber。 向pendingPassiveHookEffectsUnmount数组内push数据的操作发生在layout阶段 commitLayoutEffectOnFiber方法内部的schedulePassiveEffects方法中。 commitLayoutEffectOnFiber方法我们在Layout阶段已经介绍 function schedulePassiveEffects(finishedWork: Fiber) &#123; const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any); const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null; if (lastEffect !== null) &#123; const firstEffect = lastEffect.next; let effect = firstEffect; do &#123; const &#123;next, tag&#125; = effect; if ( (tag &amp; HookPassive) !== NoHookEffect &amp;&amp; (tag &amp; HookHasEffect) !== NoHookEffect ) &#123; // 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect enqueuePendingPassiveHookEffectUnmount(finishedWork, effect); // 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect enqueuePendingPassiveHookEffectMount(finishedWork, effect); &#125; effect = next; &#125; while (effect !== firstEffect); &#125; &#125; 阶段二：回调函数的执行与阶段一类似，同样遍历数组，执行对应effect的回调函数。 其中向pendingPassiveHookEffectsMount中push数据的操作同样发生在schedulePassiveEffects中。 // pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect const mountEffects = pendingPassiveHookEffectsMount; pendingPassiveHookEffectsMount = []; for (let i = 0; i &lt; mountEffects.length; i += 2) &#123; const effect = ((mountEffects[i]: any): HookEffect); const fiber = ((mountEffects[i + 1]: any): Fiber); try &#123; const create = effect.create; effect.destroy = create(); &#125; catch (error) &#123; captureCommitPhaseError(fiber, error); &#125; &#125; useRefref是reference（引用）的缩写。在React中，我们习惯用ref保存DOM。 事实上，任何需要被”引用”的数据都可以保存在ref中，useRef的出现将这种思想进一步发扬光大。 在Hooks数据结构一节我们讲到： 对于useRef(1)，memoizedState保存&#123;current: 1&#125; 本节我们会介绍useRef的实现，以及ref的工作流程。 由于string类型的ref已不推荐使用，所以本节针对function | &#123;current: any&#125;类型的ref。 useRef与其他Hook一样，对于mount与update，useRef对应两个不同dispatcher。 function mountRef&lt;T>(initialValue: T): &#123;|current: T|&#125; &#123; // 获取当前useRef hook const hook = mountWorkInProgressHook(); // 创建ref const ref = &#123;current: initialValue&#125;; hook.memoizedState = ref; return ref; &#125; function updateRef&lt;T>(initialValue: T): &#123;|current: T|&#125; &#123; // 获取当前useRef hook const hook = updateWorkInProgressHook(); // 返回保存的数据 return hook.memoizedState; &#125; 你可以在这里看到这段代码 可见，useRef仅仅是返回一个包含current属性的对象。 为了验证这个观点，我们再看下React.createRef方法的实现： export function createRef(): RefObject &#123; const refObject = &#123; current: null, &#125;; return refObject; &#125; 你可以从这里看到这段代码 了解了ref的数据结构后，我们再来看看ref的工作流程。 ref的工作流程在React中，HostComponent、ClassComponent、ForwardRef可以赋值ref属性。 // HostComponent &lt;div ref=&#123;domRef&#125;>&lt;/div> // ClassComponent / ForwardRef &lt;App ref=&#123;cpnRef&#125; /> 其中，ForwardRef只是将ref作为第二个参数传递下去，不会进入ref的工作流程。 所以接下来讨论ref的工作流程时会排除ForwardRef。 // 对于ForwardRef，secondArg为传递下去的ref let children = Component(props, secondArg); 你可以在这里看到这段代码 我们知道HostComponent在commit阶段的mutation阶段执行DOM操作。 所以，对应ref的更新也是发生在mutation阶段。 再进一步，mutation阶段执行DOM操作的依据为effectTag。 所以，对于HostComponent、ClassComponent如果包含ref操作，那么也会赋值相应的effectTag。 // ... export const Placement = /* */ 0b0000000000000010; export const Update = /* */ 0b0000000000000100; export const Deletion = /* */ 0b0000000000001000; export const Ref = /* */ 0b0000000010000000; // ... 你可以在ReactSideEffectTags文件中看到ref对应的effectTag 所以，ref的工作流程可以分为两部分： render阶段为含有ref属性的fiber添加Ref effectTag commit阶段为包含Ref effectTag的fiber执行对应操作 render阶段在render阶段的beginWork与completeWork中有个同名方法markRef用于为含有ref属性的fiber增加Ref effectTag。 // beginWork的markRef function markRef(current: Fiber | null, workInProgress: Fiber) &#123; const ref = workInProgress.ref; if ( (current === null &amp;&amp; ref !== null) || (current !== null &amp;&amp; current.ref !== ref) ) &#123; // Schedule a Ref effect workInProgress.effectTag |= Ref; &#125; &#125; // completeWork的markRef function markRef(workInProgress: Fiber) &#123; workInProgress.effectTag |= Ref; &#125; 你可以在这里看到beginWork的markRef、这里看到completeWork的markRef 在beginWork中，如下两处调用了markRef： updateClassComponent内的finishClassComponent，对应ClassComponent 注意ClassComponent即使shouldComponentUpdate为false该组件也会调用markRef updateHostComponent，对应HostComponent 在completeWork中，如下两处调用了markRef： completeWork中的HostComponent类型 completeWork中的ScopeComponent类型 ScopeComponent是一种用于管理focus的测试特性，详见PR 总结下组件对应fiber被赋值Ref effectTag需要满足的条件： fiber类型为HostComponent、ClassComponent、ScopeComponent（这种情况我们不讨论） 对于mount，workInProgress.ref !== null，即存在ref属性 对于update，current.ref !== workInProgress.ref，即ref属性改变 commit阶段在commit阶段的mutation阶段中，对于ref属性改变的情况，需要先移除之前的ref。 function commitMutationEffects(root: FiberRoot, renderPriorityLevel) &#123; while (nextEffect !== null) &#123; const effectTag = nextEffect.effectTag; // ... if (effectTag &amp; Ref) &#123; const current = nextEffect.alternate; if (current !== null) &#123; // 移除之前的ref commitDetachRef(current); &#125; &#125; // ... &#125; // ... 你可以在这里看到这段代码 function commitDetachRef(current: Fiber) &#123; const currentRef = current.ref; if (currentRef !== null) &#123; if (typeof currentRef === 'function') &#123; // function类型ref，调用他，传参为null currentRef(null); &#125; else &#123; // 对象类型ref，current赋值为null currentRef.current = null; &#125; &#125; &#125; 接下来，在mutation阶段，对于Deletion effectTag的fiber（对应需要删除的DOM节点），需要递归他的子树，对子孙fiber的ref执行类似commitDetachRef的操作。 在mutation阶段一节我们讲到 对于Deletion effectTag的fiber，会执行commitDeletion。 在commitDeletion——unmountHostComponents——commitUnmount——ClassComponent | HostComponent类型case中调用的safelyDetachRef方法负责执行类似commitDetachRef的操作。 function safelyDetachRef(current: Fiber) &#123; const ref = current.ref; if (ref !== null) &#123; if (typeof ref === 'function') &#123; try &#123; ref(null); &#125; catch (refError) &#123; captureCommitPhaseError(current, refError); &#125; &#125; else &#123; ref.current = null; &#125; &#125; &#125; 你可以在这里看到这段代码 接下来进入ref的赋值阶段。我们在Layout阶段一节讲到 commitLayoutEffect会执行commitAttachRef（赋值ref） function commitAttachRef(finishedWork: Fiber) &#123; const ref = finishedWork.ref; if (ref !== null) &#123; // 获取ref属性对应的Component实例 const instance = finishedWork.stateNode; let instanceToUse; switch (finishedWork.tag) &#123; case HostComponent: // 原生DOM instanceToUse = getPublicInstance(instance); break; default: instanceToUse = instance; &#125; // 赋值ref if (typeof ref === 'function') &#123; ref(instanceToUse); &#125; else &#123; ref.current = instanceToUse; &#125; &#125; &#125; 至此，ref的工作流程完毕。 总结本节我们学习了ref的工作流程。 对于FunctionComponent，useRef负责创建并返回对应的ref。 对于赋值了ref属性的HostComponent与ClassComponent，会在render阶段经历赋值Ref effectTag，在commit阶段执行对应ref操作。 useMemo和useCallback在了解其他hook的实现后，理解useMemo与useCallback的实现非常容易。 本节我们以mount与update两种情况分别讨论这两个hook。 mountfunction mountMemo&lt;T>( nextCreate: () => T, deps: Array&lt;mixed> | void | null, ): T &#123; // 创建并返回当前hook const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; // 计算value const nextValue = nextCreate(); // 将value与deps保存在hook.memoizedState hook.memoizedState = [nextValue, nextDeps]; return nextValue; &#125; // 省略了 像mountMemo 执行 nextCreate()的这一步 function mountCallback&lt;T>(callback: T, deps: Array&lt;mixed> | void | null): T &#123; // 创建并返回当前hook const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; // 将value与deps保存在hook.memoizedState hook.memoizedState = [callback, nextDeps]; return callback; &#125; 可以看到，与mountCallback这两个唯一的区别是 mountMemo会将回调函数(nextCreate)的执行结果作为value保存 mountCallback会将回调函数作为value保存 updatefunction updateMemo&lt;T>( nextCreate: () => T, deps: Array&lt;mixed> | void | null, ): T &#123; // 返回当前hook const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) &#123; if (nextDeps !== null) &#123; const prevDeps: Array&lt;mixed> | null = prevState[1]; // 判断update前后value是否变化 if (areHookInputsEqual(nextDeps, prevDeps)) &#123; // 未变化 return prevState[0]; &#125; &#125; &#125; // 变化，重新计算value const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; &#125; function updateCallback&lt;T>(callback: T, deps: Array&lt;mixed> | void | null): T &#123; // 返回当前hook const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) &#123; if (nextDeps !== null) &#123; const prevDeps: Array&lt;mixed> | null = prevState[1]; // 判断update前后value是否变化 if (areHookInputsEqual(nextDeps, prevDeps)) &#123; // 未变化 return prevState[0]; &#125; &#125; &#125; // 变化，将新的callback作为value hook.memoizedState = [callback, nextDeps]; return callback; &#125; 可见，对于update，这两个hook的唯一区别也是是回调函数本身还是回调函数的执行结果作为value。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【React源码】React状态更新","slug":"front_end/react-updateState","date":"2022-08-11T21:55:32.000Z","updated":"2022-10-13T14:20:30.022Z","comments":true,"path":"2022/08/12/front_end/react-updateState/","link":"","permalink":"http://example.com/2022/08/12/front_end/react-updateState/","excerpt":"","text":"状态更新的整个流程更新 产生更新：调用 决定需要更新什么组件：协调 （render） 将更新的组件渲染到页面：渲染 （commit阶段） before mutation阶段：渲染前 mutation阶段：渲染中 layout阶段：渲染后 几个关键节点状态更新的整个流程：我们需要一个机制，触发状态更新，并且经过一些流程，进入render阶段，在render中执行reconcile（也就是diff算法），diff的结果会交给commit阶段，去执行视图的更新。 render阶段的开始render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新（同步模式）还是异步更新（并发模式Concurrent）。 开启并发模式Concurrent，更新会获得不同程度的优先级，不同的优先级会以异步的方式调度执行，当进入render阶段时，调用的是performConcurrentWorkOnRoot。而当前使用的ReactDOM.render渲染的页面（legacy模式）是同步的模式，也就是所有的更新是同步进行的。 开启并发模式Concurrent：ReactDOM.createRoot(rootNode).render() 严格模式 commit阶段的开始commit阶段开始于commitRoot方法的调用。其中rootFiber会作为传参。render阶段完成后会进入commit阶段。接下来讲解从触发状态更新到render阶段的路径。 触发状态更新（根据场景调用不同方法） | | v ？ | | v render阶段（&#96;performSyncWorkOnRoot&#96; 或 &#96;performConcurrentWorkOnRoot&#96;） | | v commit阶段（&#96;commitRoot&#96;） 创建Update对象在React中，有如下方法可以触发状态更新（排除SSR相关）： ReactDOM.render（首屏渲染） this.setState（ClassComponent） this.forceUpdate（ClassComponent） useState（FunctionComponent） useReducer（FunctionComponent） 这些方法调用的场景各不相同，他们是如何接入同一套状态更新机制呢？ 答案是：每次状态更新都会创建一个保存更新状态相关内容的对象，我们叫它Update。在render阶段的beginWork中会根据Update计算新的state。 触发更新的流程在FunctionComponent中有一个按钮，点击按钮，在onClick事件中触发useState的setState方法，setState触发后会调用dispatchAction。 dispatchAction方法function dispatchAction&lt;S, A>( fiber: Fiber, // 触发更新的FunctionComponent 对应的 fiber节点 queue: UpdateQueue&lt;S, A>, action: A, ) &#123; const eventTime = requestEventTime(); const lane = requestUpdateLane(fiber); // 创建Update对象，包含本次更新的一些数据，update会被保存在一条环状链表，pending中 const update: Update&lt;S, A> = &#123; lane, action, // useState的setState触发后的传参 eagerReducer: null, eagerState: null, next: (null: any), &#125;; // Append the update to the end of the list. const pending = queue.pending; if (pending === null) &#123; // This is the first update. Create a circular list. update.next = update; &#125; else &#123; update.next = pending.next; pending.next = update; &#125; queue.pending = update; const alternate = fiber.alternate; if ( fiber === currentlyRenderingFiber || (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber) ) &#123; // This is a render phase update. Stash it in a lazily-created map of // queue -> linked list of updates. After this render pass, we'll restart // and apply the stashed updates on top of the work-in-progress hook. didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true; &#125; else &#123; if ( fiber.lanes === NoLanes &amp;&amp; (alternate === null || alternate.lanes === NoLanes) ) &#123; // The queue is currently empty, which means we can eagerly compute the // next state before entering the render phase. If the new state is the // same as the current state, we may be able to bail out entirely. const lastRenderedReducer = queue.lastRenderedReducer; if (lastRenderedReducer !== null) &#123; let prevDispatcher; try &#123; const currentState: S = (queue.lastRenderedState: any); const eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute // it, on the update object. If the reducer hasn't changed by the // time we enter the render phase, then the eager state can be used // without calling the reducer again. update.eagerReducer = lastRenderedReducer; update.eagerState = eagerState; if (is(eagerState, currentState)) &#123; return; &#125; &#125; catch (error) &#123; // Suppress the error. It will throw again in the render phase. &#125; finally &#123; if (__DEV__) &#123; ReactCurrentDispatcher.current = prevDispatcher; &#125; &#125; &#125; &#125; &#125; // 最终调用：在 这个fiber中调度update更新 scheduleUpdateOnFiber(fiber, lane, eventTime); &#125; if (enableSchedulingProfiler) &#123; markStateUpdateScheduled(fiber, lane); &#125; &#125; scheduleUpdateOnFiberexport function scheduleUpdateOnFiber( fiber: Fiber, lane: Lane, eventTime: number ) &#123; checkForNestedUpdates(); warnAboutRenderPhaseUpdatesInDEV(fiber); // 由当前触发更新的fiber，一直向上遍历到根节点 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root === null) &#123; warnAboutUpdateOnUnmountedFiberInDEV(fiber); return null; &#125; // Mark that the root has a pending update. markRootUpdated(root, lane, eventTime); if (root === workInProgressRoot) &#123; if ( deferRenderPhaseUpdateToNextBatch || (executionContext &amp; RenderContext) === NoContext ) &#123; workInProgressRootUpdatedLanes = mergeLanes( workInProgressRootUpdatedLanes, lane ); &#125; if (workInProgressRootExitStatus === RootSuspendedWithDelay) &#123; markRootSuspended(root, workInProgressRootRenderLanes); &#125; &#125; // TODO: requestUpdateLanePriority also reads the priority. Pass the // priority as an argument to that function and this one. const priorityLevel = getCurrentPriorityLevel(); // 判断当前的优先级是否是 同步的 if (lane === SyncLane) &#123; // legacy模式 if ( // Check if we're inside unbatchedUpdates (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp; // Check if we're not already rendering (executionContext &amp; (RenderContext | CommitContext)) === NoContext ) &#123; // Register pending interactions on the root to avoid losing traced interaction data. schedulePendingInteractions(root, lane); performSyncWorkOnRoot(root); &#125; else &#123; ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); if (executionContext === NoContext) &#123; resetRenderTimer(); flushSyncCallbackQueue(); &#125; &#125; &#125; else &#123; // Concurrent模式 // Schedule a discrete update but only if it's not Sync. if ( (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp; // Only updates at user-blocking priority or greater are considered // discrete, even inside a discrete event. (priorityLevel === UserBlockingSchedulerPriority || priorityLevel === ImmediateSchedulerPriority) ) &#123; // This is the result of a discrete event. Track the lowest priority // discrete update per root so we can flush them early, if needed. if (rootsWithPendingDiscreteUpdates === null) &#123; rootsWithPendingDiscreteUpdates = new Set([root]); &#125; else &#123; rootsWithPendingDiscreteUpdates.add(root); &#125; &#125; // Schedule other updates after in case the callback is sync. // 确保当前整个应用 的根节点被调度。 ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); &#125; mostRecentlyUpdatedRoot = root; &#125; ensureRootIsScheduledfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) &#123; const existingCallbackNode = root.callbackNode; // 给过期未执行的 lanes 标记为 过期 markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority. const nextLanes = getNextLanes( root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes ); // 获取当前优先级最高的lanes const newCallbackPriority = returnNextLanesPriority(); if (nextLanes === NoLanes) &#123; // Special case: There's nothing to work on. if (existingCallbackNode !== null) &#123; cancelCallback(existingCallbackNode); root.callbackNode = null; root.callbackPriority = NoLanePriority; &#125; return; &#125; // Check if there's an existing task. We may be able to reuse it. if (existingCallbackNode !== null) &#123; const existingCallbackPriority = root.callbackPriority; if (existingCallbackPriority === newCallbackPriority) &#123; // The priority hasn't changed. We can reuse the existing task. Exit. return; &#125; // The priority changed. Cancel the existing callback. We'll schedule a new // one below. cancelCallback(existingCallbackNode); &#125; // Schedule a new callback. let newCallbackNode; // 同步的优先级 if (newCallbackPriority === SyncLanePriority) &#123; // Special case: Sync React callbacks are scheduled on a special // internal queue newCallbackNode = scheduleSyncCallback( performSyncWorkOnRoot.bind(null, root) ); &#125; else if (newCallbackPriority === SyncBatchedLanePriority) &#123; newCallbackNode = scheduleCallback( ImmediateSchedulerPriority, performSyncWorkOnRoot.bind(null, root) ); &#125; else &#123; // 调度的逻辑，将 lanePriority转化为 SchedulerPriority const schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority); // 调度优先级 newCallbackNode = scheduleCallback( schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root) ); &#125; root.callbackPriority = newCallbackPriority; root.callbackNode = newCallbackNode; &#125; 从fiber到root现在触发状态更新的fiber上已经包含Update对象。 我们知道，render阶段是从rootFiber开始向下遍历。那么如何从触发状态更新的fiber得到rootFiber呢？ 答案是：调用markUpdateLaneFromFiberToRoot方法。 function markUpdateLaneFromFiberToRoot( sourceFiber: Fiber, lane: Lane ): FiberRoot | null &#123; // Update the source fiber's lanes sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane); let alternate = sourceFiber.alternate; if (alternate !== null) &#123; alternate.lanes = mergeLanes(alternate.lanes, lane); &#125; // Walk the parent path to the root and update the child expiration time. let node = sourceFiber; // 将sourceFiber的父级赋值给 parent let parent = sourceFiber.return; while (parent !== null) &#123; parent.childLanes = mergeLanes(parent.childLanes, lane); alternate = parent.alternate; if (alternate !== null) &#123; alternate.childLanes = mergeLanes(alternate.childLanes, lane); &#125; node = parent; // 一直循环，将 parent.return 赋值给 parent parent = parent.return; &#125; // 最终 当 tag为 当前应用的根节点HostRoot时，返回根节点 对应的DOM（div#root） if (node.tag === HostRoot) &#123; const root: FiberRoot = node.stateNode; // 返回div#root return root; &#125; else &#123; return null; &#125; &#125; 该方法做的工作可以概括为：从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber。 由于不同更新优先级不尽相同，所以过程中还会更新遍历到的fiber的优先级。这对于我们当前属于超纲内容。 调度更新现在我们拥有一个rootFiber，该rootFiber对应的Fiber树中某个Fiber节点包含一个Update。 接下来通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。 这里调用的方法是ensureRootIsScheduled。 以下是ensureRootIsScheduled最核心的一段代码： if (newCallbackPriority === SyncLanePriority) &#123; // 任务已经过期，需要同步执行render阶段 newCallbackNode = scheduleSyncCallback( performSyncWorkOnRoot.bind(null, root) ); &#125; else &#123; // 根据任务优先级异步执行render阶段 var schedulerPriorityLevel = lanePriorityToSchedulerPriority( newCallbackPriority ); newCallbackNode = scheduleCallback( schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root) ); &#125; 你可以从这里看到ensureRootIsScheduled的源码 其中，scheduleCallback和scheduleSyncCallback会调用Scheduler提供的调度方法根据优先级调度回调函数执行。 可以看到，这里调度的回调函数为： performSyncWorkOnRoot.bind(null, root); performConcurrentWorkOnRoot.bind(null, root); 即render阶段的入口函数。 至此，状态更新就和我们所熟知的render阶段连接上了。 总结让我们梳理下状态更新的整个调用路径的关键节点： 触发状态更新（根据场景调用不同方法） | | v 创建Update对象 | | v 从fiber到root（&#96;markUpdateLaneFromFiberToRoot&#96;） | | v 调度更新（&#96;ensureRootIsScheduled&#96;） | | v render阶段（&#96;performSyncWorkOnRoot&#96; 或 &#96;performConcurrentWorkOnRoot&#96;） | | v commit阶段（&#96;commitRoot&#96;） 总结本节我们了解了状态更新的整个流程。 在接下来三节中，我们会花大量篇幅讲解Update的工作机制，因为他是构成React concurrent mode的核心机制之一。 更新的优先级优先级是一个全局的概念，legacy模式没有优先级的概念，是同步执行，后面高优先级的更新不能中断前面低优先级的更新。 export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5; // TODO: Use symbols? export const NoPriority = 0; // 初始化的无优先级 export const ImmediatePriority = 1; // 立即执行的优先级，也就是同步的优先级（React中最高优先级） export const UserBlockingPriority = 2; // 用户触发的更新 优先级（如事件，触发setState） export const NormalPriority = 3; // 一般的优先级，最常见的优先级，比如请求数据完之后再更新，它的优先级低于 用户触发的UserBlockingPriority export const LowPriority = 4; // 低优先级，Suspense就是使用这个优先级。 export const IdlePriority = 5; // 空闲的优先级 更新机制的心智模型update的计算参考了git代码版本控制的理念 同步更新的React我们可以将更新机制类比代码版本控制。 在没有代码版本控制前，我们在代码中逐步叠加功能。一切看起来井然有序，直到我们遇到了一个紧急线上bug（红色节点）。 为了修复这个bug，我们需要首先将之前的代码提交。 在React中，所有通过ReactDOM.render创建的应用（其他创建应用的方式参考ReactDOM.render一节）都是通过类似的方式更新状态。 即没有优先级概念，高优更新（红色节点）需要排在其他更新后面执行。 并发更新的React当有了代码版本控制，有紧急线上bug需要修复时，我们暂存当前分支的修改，在master分支修复bug并紧急上线。 bug修复上线后通过git rebase命令和开发分支连接上。开发分支基于修复bug的版本继续开发。 在React中，通过ReactDOM.createBlockingRoot和ReactDOM.createRoot创建的应用会采用并发的方式更新状态。 高优更新（红色节点）中断正在进行中的低优更新（蓝色节点），先完成render - commit流程。 待高优更新完成后，低优更新基于高优更新的结果重新更新。 接下来两节我们会从源码角度讲解这套并发更新是如何实现的。 参考资料外网 英文 React Core Team Dan介绍React未来发展方向 UpdateUpdate的分类触发更新的方法所隶属的组件分类： ReactDOM.render —— HostRoot this.setState —— ClassComponent this.forceUpdate —— ClassComponent useState —— FunctionComponent useReducer —— FunctionComponent 可以看到，一共三种组件（HostRoot | ClassComponent | FunctionComponent）可以触发更新。 由于不同类型组件工作方式不同，所以存在两种不同结构的Update，其中ClassComponent与HostRoot共用一套Update结构，FunctionComponent单独使用一种Update结构。 虽然他们的结构不同，但是他们工作机制与工作流程大体相同。在本节我们介绍前一种Update，FunctionComponent对应的Update在Hooks章节介绍。 Update的结构ClassComponent与HostRoot（即rootFiber.tag对应类型）共用同一种Update结构。 对应的结构如下： const update: Update&lt;*> = &#123; eventTime, lane, suspenseConfig, tag: UpdateState, payload: null, callback: null, next: null, &#125;; Update由createUpdate方法返回，你可以从这里看到createUpdate的源码 字段意义如下： eventTime：任务时间，通过performance.now()获取的毫秒数。由于该字段在未来会重构，当前我们不需要理解它。 lane：优先级相关字段。本次update所属的优先级，通过不同的方式触发的更新，它的优先级是不一样的。不同的优先级通过lane展示，只需要知道不同Update优先级可能是不同的。 你可以将lane类比心智模型中需求的紧急程度。 suspenseConfig：Suspense相关。 tag：更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate。 payload：更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参。 callback：更新的回调函数。this.setState第二个参数中的回调函数、RenderDOM.render第三个参数的回调函数。 next：与其他Update连接形成链表。如下，会创建4个update，每个update之间通过next指针连接 const onClick = () => &#123; updateCount((count) => count + 2); updateCount((count) => count + 2); updateCount((count) => count + 2); updateCount((count) => count + 2); &#125; Update与Fiber的联系Update这种数据结构如何保存在fiber中的呢？ 我们发现，Update存在一个连接其他Update形成链表的字段next。联系React中另一种以链表形式组成的结构Fiber，他们之间有什么关联么？ 答案是肯定的。 从双缓存机制一节我们知道，Fiber节点组成Fiber树，页面中最多同时存在两棵Fiber树： 代表当前页面状态的current Fiber树 代表正在render阶段的workInProgress Fiber树 类似Fiber节点组成Fiber树，Fiber节点上的多个Update会组成链表并被包含在fiber.updateQueue中。 ::: warning 什么情况下一个Fiber节点会存在多个Update？ 你可能疑惑为什么一个Fiber节点会存在多个Update。这其实是很常见的情况。 在这里介绍一种最简单的情况： onClick() &#123; this.setState(&#123; a: 1 &#125;) this.setState(&#123; b: 2 &#125;) &#125; 在一个ClassComponent中触发this.onClick方法，方法内部调用了两次this.setState。这会在该fiber中产生两个Update。 ::: Fiber节点最多同时存在两个updateQueue： current fiber保存的updateQueue即current updateQueue workInProgress fiber保存的updateQueue即workInProgress updateQueue 在commit阶段完成页面渲染后，workInProgress Fiber树变为current Fiber树，workInProgress Fiber树内Fiber节点的updateQueue就变成current updateQueue。 updateQueuefiber节点上有一个updateQueue字段，update就是保存在updateQueue中的。 updateQueue有三种类型，HostComponent、ClassComponent、FunctionComponent的类型 ClassComponent与HostRoot使用的UpdateQueue结构如下： const queue: UpdateQueue&lt;State> = &#123; baseState: fiber.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: &#123; pending: null, &#125;, effects: null, &#125;; UpdateQueue由initializeUpdateQueue方法返回，你可以从这里看到initializeUpdateQueue的源码 字段说明如下： baseState：本次更新前该Fiber节点的state，Update基于该state计算更新后的state。 你可以将baseState类比心智模型中的master分支。 firstBaseUpdate与lastBaseUpdate：本次更新前该Fiber节点已保存的Update。以链表形式存在，链表头为firstBaseUpdate，链表尾为lastBaseUpdate。之所以在更新产生前该Fiber节点内就存在Update，是由于某些Update优先级较低所以在上次render阶段由Update计算state时被跳过。 你可以将baseUpdate类比心智模型中执行git rebase基于的commit（节点D）。 shared.pending：触发更新时，产生的Update会保存在shared.pending中形成单向环状链表。当由Update计算state时这个环会被剪开并连接在lastBaseUpdate后面。 你可以将shared.pending类比心智模型中本次需要提交的commit（节点ABC）。 effects：数组。保存update.callback !== null的Update。保存update的回调函数 createUpdate：创建update，并返回update数据结构。 export function createUpdate(eventTime: number, lane: Lane): Update&lt;*> &#123; const update: Update&lt;*> = &#123; eventTime, lane, tag: UpdateState, payload: null, callback: null, next: null, &#125;; return update; &#125; enqueueUpdate：为fiber的update的链表增加 新的update。 export function enqueueUpdate&lt;State>(fiber: Fiber, update: Update&lt;State>) &#123; const updateQueue = fiber.updateQueue; if (updateQueue === null) &#123; // Only occurs if the fiber has been unmounted. return; &#125; const sharedQueue: SharedQueue&lt;State> = (updateQueue: any).shared; const pending = sharedQueue.pending; // 执行链表的操作 if (pending === null) &#123; // This is the first update. Create a circular list. update.next = update; &#125; else &#123; // 已经存在的update，会用next指针指向新的update，这些update的会头尾相连，形成一个链表。 update.next = pending.next; pending.next = update; &#125; sharedQueue.pending = update; &#125; 例子updateQueue相关代码逻辑涉及到大量链表操作，比较难懂。在此我们举例对updateQueue的工作流程讲解下。 假设有一个fiber刚经历commit阶段完成渲染。 该fiber上有两个由于优先级过低所以在上次的render阶段并没有处理的Update。他们会成为下次更新的baseUpdate。 我们称其为u1和u2，其中u1.next === u2。 fiber.updateQueue.firstBaseUpdate === u1; fiber.updateQueue.lastBaseUpdate === u2; u1.next === u2; 我们用--&gt;表示链表的指向： fiber.updateQueue.baseUpdate: u1 --> u2 现在我们在fiber上触发两次状态更新，这会先后产生两个新的Update，我们称为u3和u4。 每个 update 都会通过 enqueueUpdate 方法插入到 updateQueue 队列上 当插入u3后： fiber.updateQueue.shared.pending === u3; u3.next === u3; shared.pending的环状链表，用图表示为： fiber.updateQueue.shared.pending: u3 ─────┐ ^ | └──────┘ 接着插入u4之后： fiber.updateQueue.shared.pending === u4; u4.next === u3; u3.next === u4; shared.pending是环状链表，用图表示为： fiber.updateQueue.shared.pending: u4 ──> u3 ^ | └──────┘ shared.pending 会保证始终指向最后一个插入的update，你可以在这里看到enqueueUpdate的源码 更新调度完成后进入render阶段。 此时shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面： fiber.updateQueue.baseUpdate: u1 --> u2 --> u3 --> u4 接下来遍历updateQueue.baseUpdate链表，以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state（该操作类比Array.prototype.reduce）。 在遍历时如果有优先级低的Update会被跳过。 当遍历完成后获得的state，就是该Fiber节点在本次更新的state（源码中叫做memoizedState）。 render阶段的Update操作由processUpdateQueue完成，你可以从这里看到processUpdateQueue的源码 state的变化在render阶段产生与上次更新不同的JSX对象，通过Diff算法产生effectTag，在commit阶段渲染在页面上。 渲染完成后workInProgress Fiber树变为current Fiber树，整个更新流程结束。 什么是优先级在React理念一节我们聊到React将人机交互研究的结果整合到真实的UI中。具体到React运行上这是什么意思呢？ 状态更新由用户交互产生，用户心里对交互执行顺序有个预期。React根据人机交互研究的结果中用户对交互的预期顺序为交互产生的状态更新赋予不同优先级。 具体如下： 生命周期方法：同步执行。 受控的用户输入：比如输入框内输入文字，同步执行。 交互事件：比如动画，高优先级执行。 其他：比如数据请求，低优先级执行。 如何调度优先级我们在新的React结构一节讲到，React通过Scheduler调度任务。 具体到代码，每当需要调度任务时，React会调用Scheduler提供的方法runWithPriority。 该方法接收一个优先级常量与一个回调函数作为参数。回调函数会以优先级高低为顺序排列在一个定时器中并在合适的时间触发。 对于更新来讲，传递的回调函数一般为状态更新流程概览一节讲到的render阶段的入口函数。 你可以在&#x3D;&#x3D;unstable_runWithPriority&#x3D;&#x3D; 这里看到runWithPriority方法的定义。在这里看到Scheduler对优先级常量的定义。 例子优先级最终会反映到update.lane变量上。当前我们只需要知道这个变量能够区分Update的优先级。 接下来我们通过一个例子结合上一节介绍的Update相关字段讲解优先级如何决定更新的顺序。 该例子来自React Core Team Andrew向网友讲解Update工作流程的推文 在这个例子中，有两个Update。我们将“关闭黑夜模式”产生的Update称为u1，输入字母“I”产生的Update称为u2。 其中u1先触发并进入render阶段。其优先级较低，执行时间较长。此时： fiber.updateQueue = &#123; baseState: &#123; blackTheme: true, text: 'H' &#125;, firstBaseUpdate: null, lastBaseUpdate: null shared: &#123; pending: u1 &#125;, effects: null &#125;; 在u1完成render阶段前用户通过键盘输入字母“I”，产生了u2。u2属于受控的用户输入，优先级高于u1，于是中断u1产生的render阶段。 此时： fiber.updateQueue.shared.pending === u2 ----> u1 ^ | |________| // 即 u2.next === u1; u1.next === u2; 其中u2优先级高于u1。 接下来进入u2产生的render阶段。 在processUpdateQueue方法中，shared.pending环状链表会被剪开并拼接在baseUpdate后面。 需要明确一点，shared.pending指向最后一个pending的update，所以实际执行时update的顺序为： u1 -- u2 接下来遍历baseUpdate，处理优先级合适的Update（这一次处理的是更高优的u2）。 由于u2不是baseUpdate中的第一个update，在其之前的u1由于优先级不够被跳过。 update之间可能有依赖关系，所以被跳过的update及其后面所有update会成为下次更新的baseUpdate。（即u1 -- u2）。 最终u2完成render - commit阶段。 此时： fiber.updateQueue = &#123; baseState: &#123; blackTheme: true, text: 'HI' &#125;, firstBaseUpdate: u1, lastBaseUpdate: u2 shared: &#123; pending: null &#125;, effects: null &#125;; 在commit阶段结尾会再调度一次更新。在该次更新中会基于baseState中firstBaseUpdate保存的u1，开启一次新的render阶段。 最终两次Update都完成后的结果如下： fiber.updateQueue = &#123; baseState: &#123; blackTheme: false, text: 'HI' &#125;, firstBaseUpdate: null, lastBaseUpdate: null shared: &#123; pending: null &#125;, effects: null &#125;; 我们可以看见，u2对应的更新执行了两次，相应的render阶段的生命周期勾子componentWillXXX也会触发两次。这也是为什么这些勾子会被标记为unsafe_。 如何保证状态正确现在我们基本掌握了updateQueue的工作流程。还有两个疑问： render阶段可能被中断。如何保证updateQueue中保存的Update不丢失？ 有时候当前状态需要依赖前一个状态。如何在支持跳过低优先级状态的同时保证状态依赖的连续性？ 我们分别讲解下。 如何保证Update不丢失在上一节例子中我们讲到，在render阶段，shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面。 实际上shared.pending会被同时连接在workInProgress updateQueue.lastBaseUpdate与current updateQueue.lastBaseUpdate后面。 具体代码见这里 当render阶段被中断后重新开始时，会基于current updateQueue克隆出workInProgress updateQueue。由于current updateQueue.lastBaseUpdate已经保存了上一次的Update，所以不会丢失。 当commit阶段完成渲染，由于workInProgress updateQueue.lastBaseUpdate中保存了上一次的Update，所以 workInProgress Fiber树变成current Fiber树后也不会造成Update丢失。 如何保证状态依赖的连续性当某个Update由于优先级低而被跳过时，保存在baseUpdate中的不仅是该Update，还包括链表中该Update之后的所有Update。 考虑如下例子： baseState: '' shared.pending: A1 --> B2 --> C1 --> D2 其中字母代表该Update要在页面插入的字母，数字代表优先级，值越低优先级越高。 第一次render，优先级为1。 baseState: '' baseUpdate: null render阶段使用的Update: [A1, C1] memoizedState: 'AC' 其中B2由于优先级为2，低于当前优先级，所以他及其后面的所有Update会被保存在baseUpdate中作为下次更新的Update（即B2 C1 D2）。 这么做是为了保持状态的前后依赖顺序。 第二次render，优先级为2。 baseState: 'A' baseUpdate: B2 --> C1 --> D2 render阶段使用的Update: [B2, C1, D2] memoizedState: 'ABCD' 注意这里baseState并不是上一次更新的memoizedState。这是由于B2被跳过了。 即当有Update被跳过时，下次更新的baseState !== 上次更新的memoizedState。 跳过B2的逻辑见这里 通过以上例子我们可以发现，React保证最终的状态一定和用户触发的交互一致，但是中间过程状态可能由于设备不同而不同。 :::details 高优先级任务打断低优先级任务Demo 关注公众号，后台回复815获得在线Demo地址 ::: 参考资料深入源码剖析componentWillXXX为什么UNSAFE React源码中讲解Update工作流程及优先级的注释 React Core Team Andrew向网友讲解Update工作流程的推文 ReactDOM.renderReactDOM.render完成页面渲染的整个流程？ 创建fiber首次执行ReactDOM.render会创建fiberRootNode和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是要渲染组件所在组件树的根节点。 这一步发生在调用ReactDOM.render后进入的legacyRenderSubtreeIntoContainer方法中。 render方法function render(element, container, callback) &#123; if (!isValidContainerLegacy(container)) &#123; throw new Error('Target container is not a DOM element.'); &#125; &#123; var isModernRoot = isContainerMarkedAsRoot(container) &amp;&amp; container._reactRootContainer === undefined; if (isModernRoot) &#123; error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?'); &#125; &#125; return legacyRenderSubtreeIntoContainer(null, element, container, false, callback); &#125; legacyRenderSubtreeIntoContainer和legacyCreateRootFromDOMContainerfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) &#123; &#123; topLevelUpdateWarnings(container); warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render'); &#125; var root = container._reactRootContainer; var fiberRoot; // 根节点不存在，则会先创建整个根节点 if (!root) &#123; // Initial mount root是整个应用的根节点，fiberRootNode root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate); fiberRoot = root; // ReactDOM.render的第三个参数是否存在 if (typeof callback === 'function') &#123; var originalCallback = callback; callback = function () &#123; var instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); &#125;; &#125; // Initial mount should not be batched. flushSync(function () &#123; // 调用updateContainer updateContainer(children, fiberRoot, parentComponent, callback); &#125;); &#125; else &#123; fiberRoot = root; if (typeof callback === 'function') &#123; var _originalCallback = callback; callback = function () &#123; var instance = getPublicRootInstance(fiberRoot); _originalCallback.call(instance); &#125;; &#125; // Update updateContainer(children, fiberRoot, parentComponent, callback); &#125; return getPublicRootInstance(fiberRoot); &#125; function legacyCreateRootFromDOMContainer( container: Container, forceHydrate: boolean, ): RootType &#123; const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content. if (!shouldHydrate) &#123; // 不是服务端渲染情况 let warned = false; let rootSibling; while ((rootSibling = container.lastChild)) &#123; // 如果容器下存在其他的DOM元素，需要先将这些DOM元素删除 container.removeChild(rootSibling); &#125; &#125; return createLegacyRoot( container, shouldHydrate ? &#123; hydrate: true, &#125; : undefined, ); &#125; export function createBlockingRoot( container: Container, options?: RootOptions, ): RootType &#123; warnIfReactDOMContainerInDEV(container); return new ReactDOMBlockingRoot(container, BlockingRoot, options); &#125; // ReactRootTags.js————开始 // Legacy和Concurrent的区别是优先级lane的不同 export type RootTag = 0 | 1 | 2; export const LegacyRoot = 0; // ReactDOM.render export const BlockingRoot = 1; export const ConcurrentRoot = 2; // ReactDOM.createRoot(rootNode).render(&lt;App />) // ReactRootTags.js————结束 export function createLegacyRoot( container: Container, options?: RootOptions, ): RootType &#123; return new ReactDOMBlockingRoot(container, LegacyRoot, options); &#125; function ReactDOMBlockingRoot( container: Container, tag: RootTag, options: void | RootOptions, ) &#123; this._internalRoot = createRootImpl(container, tag, options); &#125; function createRootImpl( container: Container, tag: RootTag, // tag为 0/1/2，从ReactDOMBlockingRoot的LegacyRoot传入 options: void | RootOptions, ) &#123; // Tag is either LegacyRoot or Concurrent Root const hydrate = options != null &amp;&amp; options.hydrate === true; const hydrationCallbacks = (options != null &amp;&amp; options.hydrationOptions) || null; const mutableSources = (options != null &amp;&amp; options.hydrationOptions != null &amp;&amp; options.hydrationOptions.mutableSources) || null; // fiberRootNode整个应用的根节点 const root = createContainer(container, tag, hydrate, hydrationCallbacks); markContainerAsRoot(root.current, container); const containerNodeType = container.nodeType; if (enableEagerRootListeners) &#123; const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; listenToAllSupportedEvents(rootContainerElement); &#125; else &#123; if (hydrate &amp;&amp; tag !== LegacyRoot) &#123; const doc = containerNodeType === DOCUMENT_NODE ? container : container.ownerDocument; eagerlyTrapReplayableEvents(container, ((doc: any): Document)); &#125; else if ( containerNodeType !== DOCUMENT_FRAGMENT_NODE &amp;&amp; containerNodeType !== DOCUMENT_NODE ) &#123; ensureListeningTo(container, 'onMouseEnter', null); &#125; &#125; if (mutableSources) &#123; for (let i = 0; i &lt; mutableSources.length; i++) &#123; const mutableSource = mutableSources[i]; registerMutableSourceForHydration(root, mutableSource); &#125; &#125; return root; &#125; // container指ReactDOM.render的第二个参数（即应用挂载的DOM节点） root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate, ); fiberRoot = root._internalRoot; 你可以从这里看到这一步的代码 legacyCreateRootFromDOMContainer方法内部会调用createFiberRoot方法完成fiberRootNode和rootFiber的创建以及关联。并初始化updateQueue。 export function createFiberRoot( containerInfo: any, tag: RootTag, hydrate: boolean, hydrationCallbacks: null | SuspenseHydrationCallbacks, ): FiberRoot &#123; // 创建fiberRootNode const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any); // 创建rootFiber const uninitializedFiber = createHostRootFiber(tag); // 连接rootFiber与fiberRootNode root.current = uninitializedFiber; uninitializedFiber.stateNode = root; // 初始化updateQueue initializeUpdateQueue(uninitializedFiber); return root; &#125; 根据以上代码，现在我们可以在双缓存机制一节基础上补充上rootFiber到fiberRootNode的引用。 你可以从这里看到这一步的代码 创建update我们已经做好了组件的初始化工作，接下来就等待创建Update来开启一次更新。 这一步发生在updateContainer方法中。 export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component&lt;any, any>, callback: ?Function, ): Lane &#123; // ...省略与逻辑不相关代码 // 创建update const update = createUpdate(eventTime, lane, suspenseConfig); // update.payload为需要挂载在根节点的组件 update.payload = &#123;element&#125;; // callback为ReactDOM.render的第三个参数 —— 回调函数 callback = callback === undefined ? null : callback; if (callback !== null) &#123; update.callback = callback; &#125; // 将生成的update加入updateQueue enqueueUpdate(current, update); // 调度更新 scheduleUpdateOnFiber(current, lane, eventTime); // ...省略与逻辑不相关代码 &#125; 你可以从这里看到updateContainer的代码 值得注意的是其中update.payload = &#123;element&#125;; 这就是我们在Update一节介绍的，对于HostRoot，payload为ReactDOM.render的第一个传参。 流程概览至此，ReactDOM.render的流程就和我们已知的流程连接上了。 整个流程如下： 创建fiberRootNode、rootFiber、updateQueue（&#96;legacyCreateRootFromDOMContainer&#96;） | | v 创建Update对象（&#96;updateContainer&#96;） | | v 从fiber到root（&#96;markUpdateLaneFromFiberToRoot&#96;） | | v 调度更新（&#96;ensureRootIsScheduled&#96;） | | v render阶段（&#96;performSyncWorkOnRoot&#96; 或 &#96;performConcurrentWorkOnRoot&#96;） | | v commit阶段（&#96;commitRoot&#96;） React的其他入口函数当前React共有三种模式： legacy，这是当前React使用的方式。当前没有计划删除本模式，但是这个模式可能不支持一些新功能。 blocking，开启部分concurrent模式特性的中间模式。目前正在实验中。作为迁移到concurrent模式的第一个步骤。 concurrent，面向未来的开发模式。我们之前讲的任务中断/任务优先级都是针对concurrent模式。 你可以从下表看出各种模式对特性的支持： legacy 模式 blocking 模式 concurrent 模式 String Refs ✅ 🚫** 🚫** Legacy Context ✅ 🚫** 🚫** findDOMNode ✅ 🚫** 🚫** Suspense ✅ ✅ ✅ SuspenseList 🚫 ✅ ✅ Suspense SSR + Hydration 🚫 ✅ ✅ Progressive Hydration 🚫 ✅ ✅ Selective Hydration 🚫 🚫 ✅ Cooperative Multitasking 🚫 🚫 ✅ Automatic batching of multiple setStates 🚫* ✅ ✅ Priority-based Rendering 🚫 🚫 ✅ Interruptible Prerendering 🚫 🚫 ✅ useTransition 🚫 🚫 ✅ useDeferredValue 🚫 🚫 ✅ Suspense Reveal “Train” 🚫 🚫 ✅ *：legacy模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非React事件想使用这个功能必须使用 unstable_batchedUpdates。在blocking模式和concurrent模式下，所有的setState在默认情况下都是批处理的。 **：会在开发中发出警告。 模式的变化影响整个应用的工作方式，所以无法只针对某个组件开启不同模式。 基于此原因，可以通过不同的入口函数开启不同模式： legacy – ReactDOM.render(&lt;App /&gt;, rootNode) blocking – ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;) concurrent – ReactDOM.createRoot(rootNode).render(&lt;App /&gt;) 你可以在这里看到React团队解释为什么会有这么多模式 虽然不同模式的入口函数不同，但是他们仅对fiber.mode变量产生影响，对我们在流程概览中描述的流程并无影响。 this.setState流程流程概览this.setState内会调用this.updater.enqueueSetState方法。 Component.prototype.setState = function (partialState, callback) &#123; if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) &#123; &#123; throw Error( \"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\" ); &#125; &#125; /** * this: ClassComponent的实例 * partialState: 需要传递的state，state会变为 update.playload * callback: setState函数的callback * * */ this.updater.enqueueSetState(this, partialState, callback, 'setState'); &#125;; // updater对象 const classComponentUpdater = &#123; isMounted, // this.setState相关 enqueueSetState(inst, payload, callback) &#123; // 获取当前的fiber const fiber = getInstance(inst); // 获取当前事件的时间 const eventTime = requestEventTime(); // 获取优先级lane const lane = requestUpdateLane(fiber); // 创建 update const update = createUpdate(eventTime, lane); update.payload = payload; if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; &#125; enqueueUpdate(fiber, update); scheduleUpdateOnFiber(fiber, lane, eventTime); if (enableSchedulingProfiler) &#123; markStateUpdateScheduled(fiber, lane); &#125; &#125;, enqueueReplaceState(inst, payload, callback) &#123; const fiber = getInstance(inst); const eventTime = requestEventTime(); const lane = requestUpdateLane(fiber); const update = createUpdate(eventTime, lane); update.tag = ReplaceState; update.payload = payload; if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; &#125; enqueueUpdate(fiber, update); scheduleUpdateOnFiber(fiber, lane, eventTime); if (enableSchedulingProfiler) &#123; markStateUpdateScheduled(fiber, lane); &#125; &#125;, // this.forceUpdate相关 enqueueForceUpdate(inst, callback) &#123; const fiber = getInstance(inst); const eventTime = requestEventTime(); const lane = requestUpdateLane(fiber); const update = createUpdate(eventTime, lane); update.tag = ForceUpdate; if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; &#125; enqueueUpdate(fiber, update); scheduleUpdateOnFiber(fiber, lane, eventTime); if (enableSchedulingProfiler) &#123; markForceUpdateScheduled(fiber, lane); &#125; &#125;, &#125;; 在enqueueSetState方法中就是我们熟悉的从创建update到调度update的流程了。 enqueueSetState(inst, payload, callback) &#123; // 通过组件实例获取对应fiber const fiber = getInstance(inst); const eventTime = requestEventTime(); const suspenseConfig = requestCurrentSuspenseConfig(); // 获取优先级 const lane = requestUpdateLane(fiber, suspenseConfig); // 创建update const update = createUpdate(eventTime, lane, suspenseConfig); update.payload = payload; // 赋值回调函数 if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; &#125; // 将update插入updateQueue enqueueUpdate(fiber, update); // 调度update scheduleUpdateOnFiber(fiber, lane, eventTime); &#125; 对于ClassComponent，update.payload为this.setState的第一个传参（即要改变的state）。 this.forceUpdate在this.updater上，除了enqueueSetState外，还存在enqueueForceUpdate，当我们调用this.forceUpdate时会调用他。 可以看到，除了赋值update.tag = ForceUpdate;以及没有payload外，其他逻辑与this.setState一致。 enqueueForceUpdate(inst, callback) &#123; const fiber = getInstance(inst); const eventTime = requestEventTime(); const suspenseConfig = requestCurrentSuspenseConfig(); const lane = requestUpdateLane(fiber, suspenseConfig); const update = createUpdate(eventTime, lane, suspenseConfig); // 赋值tag为ForceUpdate update.tag = ForceUpdate; if (callback !== undefined &amp;&amp; callback !== null) &#123; update.callback = callback; &#125; enqueueUpdate(fiber, update); scheduleUpdateOnFiber(fiber, lane, eventTime); &#125;, &#125;; 那么赋值update.tag = ForceUpdate;有何作用呢？ 在判断ClassComponent是否需要更新时有两个条件需要满足： const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext, ); 你可以在这里看到这段代码 checkHasForceUpdateAfterProcessing：内部会判断本次更新的Update是否为ForceUpdate。即如果本次更新的Update中存在tag为ForceUpdate，则返回true。 checkShouldComponentUpdate：内部会调用shouldComponentUpdate方法。以及当该ClassComponent为PureComponent时会浅比较state与props。 你可以在这里看到checkShouldComponentUpdate代码 所以，当某次更新含有tag为ForceUpdate的Update，那么当前ClassComponent不会受其他性能优化手段（shouldComponentUpdate|PureComponent）影响，一定会更新。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【React源码】React diff算法","slug":"front_end/react-diff","date":"2022-07-22T20:02:15.000Z","updated":"2022-10-13T14:11:14.583Z","comments":true,"path":"2022/07/23/front_end/react-diff/","link":"","permalink":"http://example.com/2022/07/23/front_end/react-diff/","excerpt":"","text":"diff算法流程概览一个DOM节点在某一时刻最多会有4个节点和他相关。 current Fiber。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的Fiber节点。 workInProgress Fiber。如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber代表该DOM节点对应的Fiber节点。 DOM节点本身。 JSX对象。即ClassComponent的render方法的返回结果，或FunctionComponent的调用结果。JSX对象中包含描述DOM节点的信息。 Diff算法的本质是对比1和4，生成2。 Diff的瓶颈以及React如何应对由于Diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中n是树中元素的数量。 如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。 为了降低算法复杂度，React的diff会预设三个限制： 只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。 开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子： // 更新前 &lt;div> &lt;p key=\"ka\">ka&lt;/p> &lt;h3 key=\"song\">song&lt;/h3> &lt;/div> // 更新后 &lt;div> &lt;h3 key=\"song\">song&lt;/h3> &lt;p key=\"ka\">ka&lt;/p> &lt;/div> 如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。这符合限制2的设定，会销毁并新建。 但是当我们用key指明了节点前后对应关系后，React知道key === &quot;ka&quot;的p在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。 这就是React为了应对算法性能瓶颈做出的三条限制。 diff算法有key和没有key的区别，举个例子：页面上有两个相邻的元素需要调换位置，如果没有为这两个元素绑定key属性，React会销毁元素并新建元素。如果是指明了这两个元素的key，React就知道这两个元素是交换顺序，DOM节点可以复用。 Diff是如何实现的Diff的入口函数是reconcileChildFibers，该函数会根据newChild（即JSX对象）类型调用不同的处理函数。（render阶段） // 根据newChild类型选择不同diff函数处理 function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, ): Fiber | null &#123; // 当前的newChild是否是 fragment类型 const isUnkeyedTopLevelFragment = typeof newChild === 'object' &amp;&amp; newChild !== null &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === null; if (isUnkeyedTopLevelFragment) &#123; newChild = newChild.props.children; &#125; // 是否是一个object， const isObject = typeof newChild === 'object' &amp;&amp; newChild !== null; if (isObject) &#123; // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE switch (newChild.$$typeof) &#123; // 单一节点 由placeSingleChild处理 case REACT_ELEMENT_TYPE: // 调用 reconcileSingleElement 处理 return placeSingleChild( reconcileSingleElement( returnFiber, currentFirstChild, newChild, lanes, ), ); case REACT_PORTAL_TYPE: return placeSingleChild( reconcileSinglePortal( returnFiber, currentFirstChild, newChild, lanes, ), ); case REACT_LAZY_TYPE: if (enableLazyElements) &#123; const payload = newChild._payload; const init = newChild._init; // TODO: This function is supposed to be non-recursive. return reconcileChildFibers( returnFiber, currentFirstChild, init(payload), lanes, ); &#125; &#125; &#125; // 当做文本节点处理 if (typeof newChild === 'string' || typeof newChild === 'number') &#123; // 调用 reconcileSingleTextNode 处理 // ...省略 &#125; // 一个ul有多个li情况，这个newChild就是Array if (isArray(newChild)) &#123; // 调用 reconcileChildrenArray 处理 // ...省略 return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, lanes, ); &#125; // 一些其他情况调用处理函数 // ...省略 // 以上都没有命中，删除节点 return deleteRemainingChildren(returnFiber, currentFirstChild); &#125; 我们可以从同级的节点数量将Diff分为两类： 当newChild类型为object、number、string，代表同级只有一个节点 当newChild类型为Array，同级有多个节点 单节点Diff什么是单一节点？更新之后，这一级只存在一个节点。对于单个节点，我们以类型object为例，会进入reconcileSingleElement const isObject = typeof newChild === 'object' &amp;&amp; newChild !== null; if (isObject) &#123; // 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE switch (newChild.$$typeof) &#123; case REACT_ELEMENT_TYPE: // 调用 reconcileSingleElement 处理 // ...其他case &#125; &#125; 这个函数会做如下事情：区别在于是重新生成workInProgress fiber节点，还是复用current fiber节点属性来生成workInProgress fiber。 判断DOM节点是否可以复用的实现如下：reconcileSingleElement目的是比较currentFirstChild和element（对应JSX对象），最终生成workInProgress fiber。 /** * returnFiber：current fiber 的 父级 fiber节点 * currentFirstChild：当前的current fiber * element：对应JSX对象 * lanes：优先级相关 */ function reconcileSingleElement( returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement, lanes: Lanes, ): Fiber &#123; const key = element.key; let child = currentFirstChild; // 首先判断是否存在对应DOM节点，mount时，child不存在 while (child !== null) &#123; // 上一次更新存在DOM节点，接下来判断是否可复用 // 首先比较key是否相同 if (child.key === key) &#123; // key相同，接下来比较type是否相同 switch (child.tag) &#123; // ...省略case default: &#123; // type相同则表示可以复用 if (child.elementType === element.type) &#123; // 删除已经存在的children，单一节点的更新，需要删除sibling deleteRemainingChildren(returnFiber, child.sibling); // useFiber是复用老的fiber const existing = useFiber(child, element.props); existing.ref = coerceRef(returnFiber, child, element); existing.return = returnFiber; if (__DEV__) &#123; existing._debugSource = element._source; existing._debugOwner = element._owner; &#125; // 返回复用的fiber return existing; &#125; // type不同则跳出switch break; &#125; &#125; // 代码执行到这里代表：key相同但是type不同 // 将该fiber及其兄弟fiber标记为删除 deleteRemainingChildren(returnFiber, child); // 只有在key相同的情况才会 比较它的type break; &#125; else &#123; // 不能复用的情况，前后的key不相同 // key不同，将该fiber标记为删除 deleteChild(returnFiber, child); &#125; child = child.sibling; &#125; // mount阶段，currentFirstChild不存在。创建新Fiber，并返回 if (element.type === REACT_FRAGMENT_TYPE) &#123; // 有fragment const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key, ); created.return = returnFiber; return created; &#125; else &#123; // 没有fragment，createFiberFromElement创建新Fiber，并返回 const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; &#125; &#125; function useFiber(fiber: Fiber, pendingProps: mixed): Fiber &#123; // 通过current 克隆 WorkInProgress fiber const clone = createWorkInProgress(fiber, pendingProps); clone.index = 0; clone.sibling = null; return clone; &#125; function deleteRemainingChildren( returnFiber: Fiber, currentFirstChild: Fiber | null, ): null &#123; if (!shouldTrackSideEffects) &#123; // Noop. return null; &#125; let childToDelete = currentFirstChild; while (childToDelete !== null) &#123; deleteChild(returnFiber, childToDelete); childToDelete = childToDelete.sibling; &#125; return null; &#125; function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void &#123; if (!shouldTrackSideEffects) &#123; // Noop. return; &#125; const last = returnFiber.lastEffect; if (last !== null) &#123; last.nextEffect = childToDelete; returnFiber.lastEffect = childToDelete; &#125; else &#123; returnFiber.firstEffect = returnFiber.lastEffect = childToDelete; &#125; childToDelete.nextEffect = null; childToDelete.flags = Deletion; &#125; 还记得我们刚才提到的，React预设的限制么， 从代码可以看出，React通过先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用。（判断一个元素是否可以复用需要满足两个条件：更新前后元素的type是否相同，更新前后的key是否相同），也就是说，JSX对象上的props属性值的有变化，理论上它对应的fiber节点是可以复用的，需要调用方法更新props属性值的变化。 这里有个细节需要关注下： 当child !== null且key相同且type不同时执行deleteRemainingChildren将child及其兄弟fiber都标记删除。 当child !== null且key不同时仅将child标记删除。 考虑如下例子： 当前页面有3个li，我们要全部删除，再插入一个p。 // 当前页面显示的 ul > li * 3 // 这次需要更新的 ul > p 由于本次更新时只有一个p，属于单一节点的Diff，会走上面介绍的代码逻辑。 在reconcileSingleElement中遍历之前的3个fiber（对应的DOM为3个li），寻找本次更新的p是否可以复用之前的3个fiber中某个的DOM。 当key相同且type不同时，代表我们已经找到本次更新的p对应的上次的fiber，但是p与li type不同，不能复用。既然唯一的可能性已经不能复用，则剩下的fiber都没有机会了，所以都需要标记删除。 当key不同时只代表遍历到的该fiber不能被p复用，后面还有兄弟fiber还没有遍历到。所以仅仅标记该fiber删除。 练习题让我们来做几道习题巩固下吧： 请判断如下JSX对象对应的DOM元素是否可以复用： // 习题1 更新前 &lt;div>ka song&lt;/div> // 更新后 &lt;p>ka song&lt;/p> // 习题2 更新前 &lt;div key=\"xxx\">ka song&lt;/div> // 更新后 &lt;div key=\"ooo\">ka song&lt;/div> // 习题3 更新前 &lt;div key=\"xxx\">ka song&lt;/div> // 更新后 &lt;p key=\"ooo\">ka song&lt;/p> // 习题4 更新前 &lt;div key=\"xxx\">ka song&lt;/div> // 更新后 &lt;div key=\"xxx\">xiao bei&lt;/div> 习题1: 未设置key prop默认 key = null;，所以更新前后key相同，都为null，但是更新前type为div，更新后为p，type改变则不能复用。 习题2: 更新前后key改变，不需要再判断type，不能复用。 习题3: 更新前后key改变，不需要再判断type，不能复用。 习题4: 更新前后key与type都未改变，可以复用。children变化，DOM的子元素需要更新。 多节点的Diff// 一个ul有多个li情况，这个newChild就是Array // 一个div下有多个子元素 if (isArray(newChild)) &#123; // 调用 reconcileChildrenArray 处理 // ...省略 return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, // 是一个数组，数组总包含 所有子元素的JSX对象 lanes, ); &#125; 现在考虑我们有一个FunctionComponent： function List () &#123; return ( &lt;ul> &lt;li key=\"0\">0&lt;/li> &lt;li key=\"1\">1&lt;/li> &lt;li key=\"2\">2&lt;/li> &lt;li key=\"3\">3&lt;/li> &lt;/ul> ) &#125; 他的返回值JSX对象的children属性不是单一节点，而是包含四个对象的数组 &#123; $$typeof: Symbol(react.element), key: null, props: &#123; children: [ &#123;$$typeof: Symbol(react.element), type: \"li\", key: \"0\", ref: null, props: &#123;…&#125;, …&#125; &#123;$$typeof: Symbol(react.element), type: \"li\", key: \"1\", ref: null, props: &#123;…&#125;, …&#125; &#123;$$typeof: Symbol(react.element), type: \"li\", key: \"2\", ref: null, props: &#123;…&#125;, …&#125; &#123;$$typeof: Symbol(react.element), type: \"li\", key: \"3\", ref: null, props: &#123;…&#125;, …&#125; ] &#125;, ref: null, type: \"ul\" &#125; 这种情况下，reconcileChildFibers的newChild参数类型为Array，在reconcileChildFibers函数内部对应如下情况： if (isArray(newChild)) &#123; // 调用 reconcileChildrenArray 处理 // ...省略 &#125; 这一节我们来看看，如何处理同级多个节点的Diff。 概览首先归纳下我们需要处理的情况： 我们以之前代表更新前的JSX对象，之后代表更新后的JSX对象 情况1：节点更新（出现的情况非常多）// 之前 &lt;ul> &lt;li key=\"0\" className=\"before\">0&lt;li> &lt;li key=\"1\">1&lt;li> &lt;/ul> // 之后 情况1 —— 节点属性变化 &lt;ul> &lt;li key=\"0\" className=\"after\">0&lt;li> &lt;li key=\"1\">1&lt;li> &lt;/ul> // 之后 情况2 —— 节点类型更新 &lt;ul> &lt;div key=\"0\">0&lt;/div> &lt;li key=\"1\">1&lt;li> &lt;/ul> 情况2：节点新增或减少// 之前 &lt;ul> &lt;li key=\"0\">0&lt;li> &lt;li key=\"1\">1&lt;li> &lt;/ul> // 之后 情况1 —— 新增节点 &lt;ul> &lt;li key=\"0\">0&lt;li> &lt;li key=\"1\">1&lt;li> &lt;li key=\"2\">2&lt;li> &lt;/ul> // 之后 情况2 —— 删除节点 &lt;ul> &lt;li key=\"1\">1&lt;li> &lt;/ul> 情况3：节点位置变化// 之前 &lt;ul> &lt;li key=\"0\">0&lt;li> &lt;li key=\"1\">1&lt;li> &lt;/ul> // 之后 &lt;ul> &lt;li key=\"1\">1&lt;li> &lt;li key=\"0\">0&lt;li> &lt;/ul> 同级多个节点的Diff，一定属于以上三种情况中的一种或多种。 Diff的思路该如何设计算法呢？如果让我设计一个Diff算法，我首先想到的方案是： 判断当前节点的更新属于哪种情况 如果是新增，执行新增逻辑 如果是删除，执行删除逻辑 如果是更新，执行更新逻辑 按这个方案，其实有个隐含的前提——不同操作的优先级是相同的 但是React团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新。 ::: warning 注意在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。 虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。 即 newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较。 所以无法使用双指针优化。::: 基于以上原因，Diff算法的整体逻辑会经历两轮遍历： 第一轮遍历：处理更新的节点。 第二轮遍历：处理剩下的不属于更新的节点。 第一轮遍历第一轮遍历步骤如下： let i = 0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用。 如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历。 如果不可复用，分两种情况： key不同导致不可复用，立即跳出整个遍历（不属于第一种情况节点更新，属于了节点位置的变化）第一轮遍历结束。 key相同type不同导致不可复用，会将oldFiber标记为DELETION，并继续遍历（jsx的type不一样，节点类型更新） 如果newChildren遍历完（即i === newChildren.length - 1）或者oldFiber遍历完（即oldFiber.sibling === null），跳出遍历，第一轮遍历结束。 reconcileChildrenArray遍历的源码function reconcileChildrenArray( returnFiber: Fiber, currentFirstChild: Fiber | null, newChildren: Array&lt;*>, lanes: Lanes, ): Fiber | null &#123; // 保存多节点diff 的 WorkInProgress fiber let resultingFirstChild: Fiber | null = null; //函数 最终返回这个变量 // 中间变量 ，将生成的上一个节点 与生成的下一个节点，通过previousNewFiber.sibling指针连接 let previousNewFiber: Fiber | null = null; // 当前正在diff的 current fiber let oldFiber = currentFirstChild; // 指代新创建的 fiber节点 对应的DOM节点 在页面中的索引位置 // 处理情况3，也就是节点的位置变化 let lastPlacedIndex = 0; // 遍历到当前 JSX对象的索引 let newIdx = 0; // 代表 当前 oldFiber 的下一个 oldFiber let nextOldFiber = null; // 第一轮遍历————开始———— for (; oldFiber !== null &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123; if (oldFiber.index > newIdx) &#123; nextOldFiber = oldFiber; oldFiber = null; &#125; else &#123; nextOldFiber = oldFiber.sibling; &#125; // 判断是否需要新建一个fiber、fiber节点是否可以复用 const newFiber = updateSlot( returnFiber, oldFiber, newChildren[newIdx], // 传入的参数是需要更新的JSX对象 lanes, ); if (newFiber === null) &#123; if (oldFiber === null) &#123; oldFiber = nextOldFiber; &#125; // newFiber为空，退出第一轮遍历 break; &#125; if (shouldTrackSideEffects) &#123; if (oldFiber &amp;&amp; newFiber.alternate === null) &#123; // 将 current fiber 标记为 删除（oldFiber 就是 current fiber） deleteChild(returnFiber, oldFiber); &#125; &#125; // 将创建好的 fiber节点 标记flags 为 Placement lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) &#123; resultingFirstChild = newFiber; &#125; else &#123; previousNewFiber.sibling = newFiber; &#125; previousNewFiber = newFiber; oldFiber = nextOldFiber; &#125; // 第一轮遍历————结束———— if (newIdx === newChildren.length) &#123; // 删除所有没有遍历的 oldFiber // 如果 oldFiber 为null，则表示 oldFiber和 newFiber同时遍历完，所有节点可以复用 deleteRemainingChildren(returnFiber, oldFiber); // 这种情况 直接返回 第一个创建的 newFiber 作为 WorkInProgress fiber return resultingFirstChild; &#125; // oldFiber遍历完了，但是 newChildren还没有遍历完，说明 newChildren里有新增的节点 if (oldFiber === null) &#123; // If we don't have any more existing children we can choose a fast path // since the rest will all be insertions. // 遍历是从没有遍历到的newFiber的 newIdx索引开始 for (; newIdx &lt; newChildren.length; newIdx++) &#123; // 创建一个新的fiber节点 const newFiber = createChild(returnFiber, newChildren[newIdx], lanes); if (newFiber === null) &#123; continue; &#125; // 将 它标记为 插入DOM中 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) &#123; // TODO: Move out of the loop. This only happens for the first run. resultingFirstChild = newFiber; &#125; else &#123; previousNewFiber.sibling = newFiber; &#125; previousNewFiber = newFiber; &#125; // 返回 return resultingFirstChild; &#125; // Add all children to a key map for quick lookups. // 接下来需要处理节点位置变化的情况，不能使用前后index来比较，这时候需要使用节点前后的key 来比较，为了在O(1)复杂度找到 key对应的oldFiber，需要将oldFiber保存在 （以oldFiber 的 key为属性，以fiber节点作为value）map中， const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // 继续遍历剩下的 newChildren（可能处理节点位置变化的情况） // Keep scanning and use the map to restore deleted items as moves. for (; newIdx &lt; newChildren.length; newIdx++) &#123; const newFiber = updateFromMap( existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, ); if (newFiber !== null) &#123; if (shouldTrackSideEffects) &#123; if (newFiber.alternate !== null) &#123; // 在 map中复用完之后，需要将 对应的fiber节点去掉 existingChildren.delete( newFiber.key === null ? newIdx : newFiber.key, ); &#125; &#125; // 将新复用的 fiber节点 标记flags 为 插入（Placement） lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) &#123; resultingFirstChild = newFiber; &#125; else &#123; previousNewFiber.sibling = newFiber; &#125; previousNewFiber = newFiber; &#125; &#125; if (shouldTrackSideEffects) &#123; // map中含有 未被复用的 fiber，需要将未被复用的标记为删除。 existingChildren.forEach(child => deleteChild(returnFiber, child)); &#125; // 最终返回 WorkInProgress fiber 节点 return resultingFirstChild; &#125; updateSlot方法的逻辑function updateSlot( returnFiber: Fiber, oldFiber: Fiber | null, newChild: any, lanes: Lanes, ): Fiber | null &#123; // Update the fiber if the keys match, otherwise return null. const key = oldFiber !== null ? oldFiber.key : null; if (typeof newChild === 'string' || typeof newChild === 'number') &#123; if (key !== null) &#123; return null; &#125; return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes); &#125; if (typeof newChild === 'object' &amp;&amp; newChild !== null) &#123; switch (newChild.$$typeof) &#123; case REACT_ELEMENT_TYPE: &#123; // 前后的key相同 if (newChild.key === key) &#123; // fragment 走这里的逻辑 if (newChild.type === REACT_FRAGMENT_TYPE) &#123; return updateFragment( returnFiber, oldFiber, newChild.props.children, lanes, key, ); &#125; // 其他 return updateElement(returnFiber, oldFiber, newChild, lanes); &#125; else &#123; // 前后的key不相同 // 不能复用之前的fiber节点，直接返回null return null; &#125; &#125; case REACT_PORTAL_TYPE: &#123; if (newChild.key === key) &#123; return updatePortal(returnFiber, oldFiber, newChild, lanes); &#125; else &#123; return null; &#125; &#125; case REACT_LAZY_TYPE: &#123; if (enableLazyElements) &#123; const payload = newChild._payload; const init = newChild._init; return updateSlot(returnFiber, oldFiber, init(payload), lanes); &#125; &#125; &#125; if (isArray(newChild) || getIteratorFn(newChild)) &#123; if (key !== null) &#123; return null; &#125; return updateFragment(returnFiber, oldFiber, newChild, lanes, null); &#125; throwOnInvalidObjectType(returnFiber, newChild); &#125; return null; &#125; updateElement的逻辑function updateElement( returnFiber: Fiber, current: Fiber | null, element: ReactElement, lanes: Lanes, ): Fiber &#123; if (current !== null) &#123; // 判断 current fiber节点上的elementType 和 JSX对象的type 是否一致 if (current.elementType === element.type ) &#123; // 复用 currnet fiber 节点，传入JSX的 props const existing = useFiber(current, element.props); existing.ref = coerceRef(returnFiber, current, element); existing.return = returnFiber; // 将复用的 fiber 返回 return existing; &#125; else if (enableBlocksAPI &amp;&amp; current.tag === Block) &#123; // 省略... &#125; &#125; // current fiber节点上的elementType 和 JSX对象的type 不一致情况，没办法复用之前的 current fiber // 基于当前的JSX 对象 创建 新的fiber 节点 const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, current, element); created.return = returnFiber; return created; &#125; placeChild// 需要将当前fiber节点 对应的DOM节点插入到页面中 function placeChild( newFiber: Fiber, lastPlacedIndex: number, newIndex: number, ): number &#123; // index表示fiber 节点 对应的 DOM节点 同级中的索引位置 newFiber.index = newIndex; if (!shouldTrackSideEffects) &#123; // 不需要追踪副作用，直接return return lastPlacedIndex; &#125; // 新节点的 alternate是否存在 const current = newFiber.alternate; // current 存在，代表当前 fiber节点是 复用之前的 alternate 节点 而创建的 if (current !== null) &#123; const oldIndex = current.index; if (oldIndex &lt; lastPlacedIndex) &#123; // This is a move. // 需要追踪，为flags 赋值为Placement // Placement作用在ReactFiberFlags查看 newFiber.flags = Placement; return lastPlacedIndex; &#125; else &#123; // This item can stay in place. return oldIndex; &#125; &#125; else &#123; // current 不存在，代表当前节点是新创建的节点，标记为 Placement // This is an insertion. newFiber.flags = Placement; // 返回 return lastPlacedIndex; &#125; &#125; mapRemainingChildren的逻辑function mapRemainingChildren( returnFiber: Fiber, currentFirstChild: Fiber, ): Map&lt;string | number, Fiber> &#123; // 创建 map const existingChildren: Map&lt;string | number, Fiber> = new Map(); let existingChild = currentFirstChild; while (existingChild !== null) &#123; if (existingChild.key !== null) &#123; // key设置为 fiber节点的key，value为fiber节点 existingChildren.set(existingChild.key, existingChild); &#125; else &#123; existingChildren.set(existingChild.index, existingChild); &#125; existingChild = existingChild.sibling; &#125; // 最终返回map return existingChildren; &#125; updateFromMapfunction updateFromMap( existingChildren: Map&lt;string | number, Fiber>, returnFiber: Fiber, newIdx: number, newChild: any, lanes: Lanes, ): Fiber | null &#123; if (typeof newChild === 'string' || typeof newChild === 'number') &#123; // Text nodes don't have keys, so we neither have to check the old nor // new node for the key. If both are text nodes, they match. const matchedFiber = existingChildren.get(newIdx) || null; return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes); &#125; if (typeof newChild === 'object' &amp;&amp; newChild !== null) &#123; switch (newChild.$$typeof) &#123; case REACT_ELEMENT_TYPE: &#123; const matchedFiber = existingChildren.get( newChild.key === null ? newIdx : newChild.key, ) || null; if (newChild.type === REACT_FRAGMENT_TYPE) &#123; return updateFragment( returnFiber, matchedFiber, newChild.props.children, lanes, newChild.key, ); &#125; return updateElement(returnFiber, matchedFiber, newChild, lanes); &#125; case REACT_PORTAL_TYPE: &#123; const matchedFiber = existingChildren.get( newChild.key === null ? newIdx : newChild.key, ) || null; return updatePortal(returnFiber, matchedFiber, newChild, lanes); &#125; case REACT_LAZY_TYPE: if (enableLazyElements) &#123; const payload = newChild._payload; const init = newChild._init; return updateFromMap( existingChildren, returnFiber, newIdx, init(payload), lanes, ); &#125; &#125; if (isArray(newChild) || getIteratorFn(newChild)) &#123; const matchedFiber = existingChildren.get(newIdx) || null; return updateFragment(returnFiber, matchedFiber, newChild, lanes, null); &#125; throwOnInvalidObjectType(returnFiber, newChild); &#125; return null; &#125; 当遍历结束后，会有两种结果： 步骤3跳出的遍历此时newChildren没有遍历完，oldFiber也没有遍历完。 举个例子，考虑如下代码： // 之前 &lt;li key=\"0\">0&lt;/li> &lt;li key=\"1\">1&lt;/li> &lt;li key=\"2\">2&lt;/li> // 之后 &lt;li key=\"0\">0&lt;/li> &lt;li key=\"2\">1&lt;/li> &lt;li key=\"1\">2&lt;/li> 第一个节点可复用，遍历到key === 2的节点发现key改变，不可复用，跳出遍历，等待第二轮遍历处理。 此时oldFiber剩下key === 1、key === 2未遍历，newChildren剩下key === 2、key === 1未遍历。 步骤4跳出的遍历可能newChildren遍历完，或oldFiber遍历完，或他们同时遍历完。 举个例子，考虑如下代码： // 之前 &lt;li key=\"0\" className=\"a\">0&lt;/li> &lt;li key=\"1\" className=\"b\">1&lt;/li> // 之后 情况1 —— newChildren与oldFiber都遍历完 &lt;li key=\"0\" className=\"aa\">0&lt;/li> &lt;li key=\"1\" className=\"bb\">1&lt;/li> // 之后 情况2 —— newChildren没遍历完，oldFiber遍历完 // newChildren剩下 key===\"2\" 未遍历 &lt;li key=\"0\" className=\"aa\">0&lt;/li> &lt;li key=\"1\" className=\"bb\">1&lt;/li> &lt;li key=\"2\" className=\"cc\">2&lt;/li> // 之后 情况3 —— newChildren遍历完，oldFiber没遍历完 // oldFiber剩下 key===\"1\" 未遍历 &lt;li key=\"0\" className=\"aa\">0&lt;/li> 带着第一轮遍历的结果，我们开始第二轮遍历。 第二轮遍历对于第一轮遍历的结果，我们分别讨论： newChildren与oldFiber同时遍历完那就是最理想的情况：只需在第一轮遍历进行组件更新。此时Diff结束。 newChildren没遍历完，oldFiber遍历完已有的DOM节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement。 你可以在这里看到这段源码逻辑 newChildren遍历完，oldFiber没遍历完意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion。 你可以在这里看到这段源码逻辑 newChildren与oldFiber都没遍历完这意味着有节点在这次更新中改变了位置。 这是Diff算法最精髓也是最难懂的部分。我们接下来会重点讲解。 你可以在这里看到这段源码逻辑 处理移动的节点由于有节点改变了位置，所以不能再用位置索引i对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？ 我们需要使用key。 为了快速的找到key对应的oldFiber，我们将所有还未处理的oldFiber存入以key为key，oldFiber为value的Map中。 const existingChildren = mapRemainingChildren(returnFiber, oldFiber); 你可以在这里看到这段源码逻辑 接下来遍历剩余的newChildren，通过newChildren[i].key就能在existingChildren中找到key相同的oldFiber。 标记节点是否移动既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？ 我们的参照物是：最后一个可复用的节点在oldFiber中的位置索引（用变量lastPlacedIndex表示）。 由于本次更新中节点是按newChildren的顺序排列。在遍历newChildren过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在lastPlacedIndex对应的可复用的节点在本次更新中位置的后面。 那么我们只需要比较遍历到的可复用节点在上次更新时是否也在lastPlacedIndex对应的oldFiber后面，就能知道两次更新中这两个节点的相对位置改变没有。 我们用变量oldIndex表示遍历到的可复用节点在oldFiber中的位置索引。如果oldIndex &lt; lastPlacedIndex，代表本次更新该节点需要向右移动。 lastPlacedIndex初始为0，每遍历一个可复用的节点，如果oldIndex &gt;= lastPlacedIndex，则lastPlacedIndex = oldIndex。 单纯文字表达比较晦涩，这里我们提供两个Demo，你可以对照着理解。 Demo1在Demo中我们简化下书写，每个字母代表一个节点，字母的值代表节点的key // 之前 abcd // 之后 acdb ===第一轮遍历开始=== a（之后）vs a（之前） key不变，可复用 此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为0 所以 lastPlacedIndex = 0; 继续第一轮遍历... c（之后）vs b（之前） key改变，不能复用，跳出第一轮遍历 此时 lastPlacedIndex === 0; ===第一轮遍历结束=== ===第二轮遍历开始=== newChildren === cdb，没用完，不需要执行删除旧节点 oldFiber === bcd，没用完，不需要执行插入新节点 将剩余oldFiber（bcd）保存为map // 当前oldFiber：bcd // 当前newChildren：cdb 继续遍历剩余newChildren key === c 在 oldFiber中存在 const oldIndex = c（之前）.index; 此时 oldIndex === 2; // 之前节点为 abcd，所以c.index === 2 比较 oldIndex 与 lastPlacedIndex; 如果 oldIndex >= lastPlacedIndex 代表该可复用节点不需要移动 并将 lastPlacedIndex = oldIndex; 如果 oldIndex &lt; lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动 在例子中，oldIndex 2 > lastPlacedIndex 0， 则 lastPlacedIndex = 2; c节点位置不变 继续遍历剩余newChildren // 当前oldFiber：bd // 当前newChildren：db key === d 在 oldFiber中存在 const oldIndex = d（之前）.index; oldIndex 3 > lastPlacedIndex 2 // 之前节点为 abcd，所以d.index === 3 则 lastPlacedIndex = 3; d节点位置不变 继续遍历剩余newChildren // 当前oldFiber：b // 当前newChildren：b key === b 在 oldFiber中存在 const oldIndex = b（之前）.index; oldIndex 1 &lt; lastPlacedIndex 3 // 之前节点为 abcd，所以b.index === 1 则 b节点需要向右移动 ===第二轮遍历结束=== 最终acd 3个节点都没有移动，b节点被标记为移动 Demo2// 之前 abcd // 之后 dabc ===第一轮遍历开始=== d（之后）vs a（之前） key改变，不能复用，跳出遍历 ===第一轮遍历结束=== ===第二轮遍历开始=== newChildren === dabc，没用完，不需要执行删除旧节点 oldFiber === abcd，没用完，不需要执行插入新节点 将剩余oldFiber（abcd）保存为map 继续遍历剩余newChildren // 当前oldFiber：abcd // 当前newChildren dabc key === d 在 oldFiber中存在 const oldIndex = d（之前）.index; 此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3 比较 oldIndex 与 lastPlacedIndex; oldIndex 3 > lastPlacedIndex 0 则 lastPlacedIndex = 3; d节点位置不变 继续遍历剩余newChildren // 当前oldFiber：abc // 当前newChildren abc key === a 在 oldFiber中存在 const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0 此时 oldIndex === 0; 比较 oldIndex 与 lastPlacedIndex; oldIndex 0 &lt; lastPlacedIndex 3 则 a节点需要向右移动 继续遍历剩余newChildren // 当前oldFiber：bc // 当前newChildren bc key === b 在 oldFiber中存在 const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1 此时 oldIndex === 1; 比较 oldIndex 与 lastPlacedIndex; oldIndex 1 &lt; lastPlacedIndex 3 则 b节点需要向右移动 继续遍历剩余newChildren // 当前oldFiber：c // 当前newChildren c key === c 在 oldFiber中存在 const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2 此时 oldIndex === 2; 比较 oldIndex 与 lastPlacedIndex; oldIndex 2 &lt; lastPlacedIndex 3 则 c节点需要向右移动 ===第二轮遍历结束=== 可以看到，我们以为从 abcd 变为 dabc，只需要将d移动到前面。 但实际上React保持d不变，将abc分别移动到了d的后面。 从这点可以看出，考虑性能，我们要尽量减少将节点从后面移动到前面的操作。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【React源码】React commit阶段","slug":"front_end/react-commit","date":"2022-06-30T22:33:45.000Z","updated":"2022-10-13T17:24:21.712Z","comments":true,"path":"2022/07/01/front_end/react-commit/","link":"","permalink":"http://example.com/2022/07/01/front_end/react-commit/","excerpt":"","text":"commit阶段commitRoot方法是commit阶段工作的起点。fiberRootNode会作为传参。 commitRoot(root); // commitRoot实际要执行的方法是 commitRootImpl function commitRoot(root) &#123; const renderPriorityLevel = getCurrentPriorityLevel(); // 是由调度器Schduler 提供的 // 参数一：调度的优先级； 参数二：调度的回调函数 runWithPriority( ImmediateSchedulerPriority, // 该函数触发的任何调度，都会以第一个参数ImmediateSchedulerPriority 作为优先级 commitRootImpl.bind(null, root, renderPriorityLevel) ); return null; &#125; 在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props。 这些副作用对应的DOM操作在commit阶段执行。 除此之外，一些生命周期钩子（比如componentDidXXX）、hook（比如useEffect）需要在commit阶段执行。 commit阶段的主要工作（即Renderer的工作流程）分为三部分： before mutation阶段（执行DOM操作前） mutation阶段（执行DOM操作） layout阶段（执行DOM操作后） 在before mutation阶段之前和layout阶段之后还有一些额外工作，涉及到比如useEffect的触发、优先级相关的重置、ref的绑定&#x2F;解绑。 before mutation之前（重置变量）commitRootImpl方法中直到第一句if (firstEffect !&#x3D;&#x3D; null)之前属于before mutation之前。 // 整个commit阶段最重要的是发生在commitRootImpl方法里面的3个 do...while循环，分别处理commit的3个阶段工作 function commitRootImpl(root, renderPriorityLevel) &#123; // ======= before mutation ======= // 开始本次commit阶段之前，看一下还有没有需要执行的useEffect，如果有则执行它们， do &#123; // 触发useEffect回调与其他同步任务。由于这些任务可能触发新的渲染，所以这里要一直遍历执行直到没有任务 // 目的：执行useEffect在上一次更新的销毁函数，和本次更新的useEffect回调函数 flushPassiveEffects(); // 直到没有 遗留的回调函数 没有被处理时，跳出循环 // rootWithPendingPassiveEffects为true，则表示有useEffect回调函数需要执行。 &#125; while (rootWithPendingPassiveEffects !== null); // root指 fiberRootNode // root.finishedWork指当前应用的rootFiber const finishedWork = root.finishedWork; // 凡是变量名带lane的都是优先级相关 const lanes = root.finishedLanes; if (finishedWork === null) &#123; return null; &#125; root.finishedWork = null; root.finishedLanes = NoLanes; // 重置Scheduler绑定的回调函数 root.callbackNode = null; root.callbackId = NoLanes; let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // 重置优先级相关变量 markRootFinished(root, remainingLanes); // 清除已完成的discrete updates，例如：用户鼠标点击触发的更新。 // DiscreteUpdates指离散的更新 if (rootsWithPendingDiscreteUpdates !== null) &#123; if ( !hasDiscreteLanes(remainingLanes) &amp;&amp; rootsWithPendingDiscreteUpdates.has(root) ) &#123; rootsWithPendingDiscreteUpdates.delete(root); &#125; &#125; // 重置一些render阶段使用的 全局变量 if (root === workInProgressRoot) &#123; workInProgressRoot = null; workInProgress = null; workInProgressRootRenderLanes = NoLanes; &#125; else &#123; &#125; // 将effectList赋值给firstEffect // 由于每个fiber的effectList只包含他的子孙节点 // 所以根节点如果有flags则不会被包含进来 // 所以这里将有flags的根节点插入到effectList尾部 // 这样才能保证有effect的fiber都在effectList中 let firstEffect; // 处理包含flags的fiber节点的链表 if (finishedWork.flags > PerformedWork) &#123; if (finishedWork.lastEffect !== null) &#123; finishedWork.lastEffect.nextEffect = finishedWork; firstEffect = finishedWork.firstEffect; &#125; else &#123; firstEffect = finishedWork; &#125; &#125; else &#123; // 根节点没有flags firstEffect = finishedWork.firstEffect; &#125; // ======= before mutation ======= if (firstEffect !== null)&#123; // 省略... &#125;else&#123; // 省略... &#125; // 省略... &#125; 可以看到，before mutation之前主要做一些变量赋值，状态重置的工作。 这一长串代码我们只需要关注最后赋值的firstEffect，在commit的三个子阶段都会用到他。 if (firstEffect !== null) &#123; let previousLanePriority; if (decoupleUpdatePriorityFromScheduler) &#123; // 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级 previousLanePriority = getCurrentUpdateLanePriority(); setCurrentUpdateLanePriority(SyncLanePriority); &#125; // 将当前上下文标记为CommitContext，作为commit阶段的标志 const prevExecutionContext = executionContext; executionContext |= CommitContext; const prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles ReactCurrentOwner.current = null; // 处理focus状态 focusedInstanceHandle = prepareForCommit(root.containerInfo); shouldFireAfterActiveInstanceBlur = false; //循环： commit before mutation 执行的工作——开始 nextEffect = firstEffect; do &#123; if (__DEV__) &#123; invokeGuardedCallback(null, commitBeforeMutationEffects, null); if (hasCaughtError()) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); const error = clearCaughtError(); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; else &#123; try &#123; // before mutation 主要的执行方法 commitBeforeMutationEffects(); // beforeMutation阶段的主函数 &#125; catch (error) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; while (nextEffect !== null); // commit before mutation 执行的工作——结束 // We no longer need to track the active instance fiber focusedInstanceHandle = null; if (enableProfilerTimer) &#123; // Mark the current commit time to be shared by all Profilers in this // batch. This enables them to be grouped later. recordCommitTime(); &#125; //循环工作： commit mutation 阶段执行的工作——开始 // The next phase is the mutation phase, where we mutate the host tree. nextEffect = firstEffect; do &#123; if (__DEV__) &#123; invokeGuardedCallback( null, commitMutationEffects, null, root, renderPriorityLevel ); if (hasCaughtError()) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); const error = clearCaughtError(); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; else &#123; try &#123; // mutation 主要的执行方法 commitMutationEffects(root, renderPriorityLevel); &#125; catch (error) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; while (nextEffect !== null); //循环工作： commit mutation 阶段执行的工作——结束 if (shouldFireAfterActiveInstanceBlur) &#123; afterActiveInstanceBlur(); &#125; resetAfterCommit(root.containerInfo); // 将root.current执行 workInProgress fiber树，为什么是在commit mutation阶段完成之后，layout阶段之前执行呢？这是因为在mutation阶段会执行componentWillUnmount这个生命周期，这个钩子中，current还指向之前的fiber树，而在layout阶段，会调用componentDidMount/Update钩子，此时 current已经指向了当前workInProgress fiber树 root.current = finishedWork; nextEffect = firstEffect; //循环工作： commit layout 阶段执行的工作——开始 do &#123; if (__DEV__) &#123; invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes); if (hasCaughtError()) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); const error = clearCaughtError(); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; else &#123; try &#123; // layout阶段 主要的执行方法 commitLayoutEffects(root, lanes); &#125; catch (error) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; &#125; while (nextEffect !== null); // 循环工作： commit layout 阶段执行的工作——结束 nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an // opportunity to paint. requestPaint(); if (enableSchedulerTracing) &#123; popInteractions(((prevInteractions: any): Set&lt;Interaction>)); &#125; executionContext = prevExecutionContext; if (decoupleUpdatePriorityFromScheduler &amp;&amp; previousLanePriority != null) &#123; // Reset the priority to the previous non-sync value. setCurrentUpdateLanePriority(previousLanePriority); &#125; &#125; else &#123; // No effects. root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were // no effects. // TODO: Maybe there's a better way to report this. if (enableProfilerTimer) &#123; recordCommitTime(); &#125; &#125; const rootDidHavePassiveEffects = rootDoesHavePassiveEffects; // 这里面的逻辑 跟本次useEffect的执行有关 // 本次更新存在 useEffect的调用 if (rootDoesHavePassiveEffects) &#123; rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; pendingPassiveEffectsRenderPriority = renderPriorityLevel; &#125; else &#123; // 本次更新不存在 useEffect的调用 nextEffect = firstEffect; // 遍历包含flags的fiber节点的链表 while (nextEffect !== null) &#123; // 将相应的变量置空，方便垃圾回收 const nextNextEffect = nextEffect.nextEffect; nextEffect.nextEffect = null; if (nextEffect.flags &amp; Deletion) &#123; detachFiberAfterEffects(nextEffect); &#125; nextEffect = nextNextEffect; &#125; &#125; // Read this again, since an effect might have updated it remainingLanes = root.pendingLanes; // Check if there's remaining work on this root if (remainingLanes !== NoLanes) &#123; if (enableSchedulerTracing) &#123; if (spawnedWorkDuringRender !== null) &#123; const expirationTimes = spawnedWorkDuringRender; spawnedWorkDuringRender = null; for (let i = 0; i &lt; expirationTimes.length; i++) &#123; // Interactions跟react的性能追踪有关 scheduleInteractions( root, expirationTimes[i], root.memoizedInteractions ); &#125; &#125; schedulePendingInteractions(root, remainingLanes); &#125; &#125; else &#123; // If there's no remaining work, we can clear the set of already failed // error boundaries. legacyErrorBoundariesThatAlreadyFailed = null; &#125; if (enableSchedulerTracing) &#123; if (!rootDidHavePassiveEffects) &#123; // If there are no passive effects, then we can complete the pending interactions. // Otherwise, we'll wait until after the passive effects are flushed. // Wait to do this until after remaining work has been scheduled, // so that we don't prematurely signal complete for interactions when there's e.g. hidden work. finishPendingInteractions(root, lanes); &#125; &#125; if (remainingLanes === SyncLane) &#123; // 判断更新是否是一个无限循环的更新，如果是无限循环的更新会抛出错误 if (root === rootWithNestedUpdates) &#123; nestedUpdateCount++; &#125; else &#123; nestedUpdateCount = 0; rootWithNestedUpdates = root; &#125; &#125; else &#123; nestedUpdateCount = 0; &#125; onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel); if (__DEV__) &#123; onCommitRootTestSelector(); &#125; // 代码执行到这里，已经完成了commit阶段，页面已经更新 // 由于commit阶段可能产生新的更新，在commit阶段的结尾，会将整个应用的节点重新调度一次 ensureRootIsScheduled(root, now()); if (hasUncaughtError) &#123; hasUncaughtError = false; const error = firstUncaughtError; firstUncaughtError = null; throw error; &#125; if ((executionContext &amp; LegacyUnbatchedContext) !== NoContext) &#123; if (__DEV__) &#123; if (enableDebugTracing) &#123; logCommitStopped(); &#125; &#125; if (enableSchedulingProfiler) &#123; markCommitStopped(); &#125; // This is a legacy edge case. We just committed the initial mount of // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired // synchronously, but layout updates should be deferred until the end // of the batch. return null; &#125; // If layout work was scheduled, flush it now. // react会将一些同步的更新，放在一个SyncCallbackQueue的队列中 // 每次执行flushSyncCallbackQueue，就会执行 这个队列中的同步任务 flushSyncCallbackQueue(); //FunctionComponent 在useLayoutEffect里面 重新setState，setState触发的更新是一个同步的更新，就会被flushSyncCallbackQueue这个逻辑中同步的执行。 // 省略... return null; &#125; 三种模式： legacy模式: ReactDOM.render(&lt;App/&gt;, rootNode)。这是当前React app使用的方式。在这个模式下，所有的更新都会以同步的执行，很多更优先级的功能是无法使用的， blocking模式: ReactDOM.createBlockingRoot(rootNode).render()。 concurrent模式（并发模式）: ReactDOM.createRoot(rootNode).render()。未来作为React的默认开发模式，这个模式开启了所有的新功能。出现不同优先级的更新。 before mutation阶段Renderer工作的阶段被称为commit阶段。commit阶段可以分为三个子阶段： before mutation阶段（执行DOM操作前） mutation阶段（执行DOM操作） layout阶段（执行DOM操作后） commitBeforeMutationEffectsbefore mutation阶段的整个过程就是遍历effectList并调用commitBeforeMutationEffects函数处理。 整体可以分为三部分： 处理DOM节点渲染&#x2F;删除后的 autoFocus、blur 逻辑。 调用getSnapshotBeforeUpdate生命周期钩子。 调度useEffect。 function commitBeforeMutationEffects() &#123; while (nextEffect !== null) &#123; const current = nextEffect.alternate; // 处理...focus blur相关 不太需要关注（第一件事情） if (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== null) &#123; // ... &#125;else&#123; // ... &#125; const flags = nextEffect.flags; // 在commitBeforeMutationEffectOnFiber方法中 调用getSnapshotBeforeUpdate（第二件事情） if ((flags &amp; Snapshot) !== NoEffect) &#123; commitBeforeMutationEffectOnFiber(current, nextEffect); // commitBeforeMutationEffectOnFiber是commitBeforeMutationLifeCycles的别名 &#125; // 第三件事情：如果当前fiber节点的flags，包含了Passive（Passive是FunctionComponent中useEffect对应flags） // 调度useEffect的回调函数 if ((flags &amp; Passive) !== NoEffect) &#123; if (!rootDoesHavePassiveEffects) &#123; rootDoesHavePassiveEffects = true; // scheduleCallback方法由Scheduler模块提供，用于以某个优先级异步调度一个回调函数。 // 并没有直接执行flushPassiveEffects，而且将它放到了scheduleCallback的回调？会以一个优先级来异步执行一个回调函数，如果一个FunctionComponent存在useEffect，并且它的回调函数需要触发，那么它的回调会在 before mutation阶段 先被以 NormalSchedulerPriority的优先级调度，而整个commit阶段是同步执行的，所有useEffect的回调的执行是在 commit完成以后，再异步执行的。 scheduleCallback(NormalSchedulerPriority, () => &#123; // 触发useEffect的回调函数 // 被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects flushPassiveEffects(); return null; &#125;); &#125; &#125; nextEffect = nextEffect.nextEffect; &#125; &#125; 调用getSnapshotBeforeUpdatecommitBeforeMutationEffectOnFiber是commitBeforeMutationLifeCycles的别名。在该方法内会调用getSnapshotBeforeUpdate。 从Reactv16开始，componentWillXXX钩子前增加了UNSAFE_前缀。究其原因，是因为Stack Reconciler重构为Fiber Reconciler后，render阶段的任务可能中断&#x2F;重新开始，对应的组件在render阶段的生命周期钩子（即componentWillXXX）可能触发多次。这种行为和Reactv15不一致，所以标记为UNSAFE_。 为此，React提供了替代的生命周期钩子getSnapshotBeforeUpdate。getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，此时还没有见到页面的更新，由于commit阶段是同步的，所以不会遇到多次调用的问题。 commitBeforeMutationLifeCycles(commitBeforeMutationEffectOnFiber)function commitBeforeMutationLifeCycles( current: Fiber | null, finishedWork: Fiber, ): void &#123; // 判断 fiber节点的tag类型 switch (finishedWork.tag) &#123; case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: &#123; return; &#125; case ClassComponent: &#123; // ... // fiber节点的flags 包含 Snapshot // getSnapshotBeforeUpdate生命周期对应的flags if (finishedWork.flags &amp; Snapshot) &#123; if (current !== null) &#123; const prevProps = current.memoizedProps; const prevState = current.memoizedState; // 通过fiber节点的stateNode取到 对应的 React.Component实例 const instance = finishedWork.stateNode; // 调用class组件实例的getSnapshotBeforeUpdate方法 const snapshot = instance.getSnapshotBeforeUpdate( finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState, ); // ... instance.__reactInternalSnapshotBeforeUpdate = snapshot; &#125; &#125; return; &#125; case HostRoot: &#123; if (supportsMutation) &#123; if (finishedWork.flags &amp; Snapshot) &#123; const root = finishedWork.stateNode; clearContainer(root.containerInfo); &#125; &#125; return; &#125; case HostComponent: case HostText: case HostPortal: case IncompleteClassComponent: // Nothing to do for these component types return; &#125; &#125; 如何异步调度在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。 effectList中保存了需要执行副作用的Fiber节点。其中副作用包括 插入DOM节点（Placement） 更新DOM节点（Update） 删除DOM节点（Deletion） 除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值flags。useEffect是Passive。 在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。 如果在此时直接执行，rootWithPendingPassiveEffects === null。 那么rootWithPendingPassiveEffects会在何时赋值呢？ 在layout之后的代码片段中会根据rootDoesHavePassiveEffects === true?决定是否赋值rootWithPendingPassiveEffects。 const rootDidHavePassiveEffects = rootDoesHavePassiveEffects; if (rootDoesHavePassiveEffects) &#123; rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; pendingPassiveEffectsRenderPriority = renderPriorityLevel; &#125; 所以整个useEffect异步调用分为三步： before mutation阶段在scheduleCallback中调度flushPassiveEffects layout阶段之后将effectList赋值给rootWithPendingPassiveEffects scheduleCallback触发flushPassiveEffects，flushPassiveEffects内部遍历rootWithPendingPassiveEffects 为什么需要异步调用摘录自React文档effect 的执行时机： 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。 可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。 总结在before mutation阶段，会遍历effectList，依次执行： 处理DOM节点渲染&#x2F;删除后的 autoFocus、blur逻辑 调用getSnapshotBeforeUpdate生命周期钩子 调度useEffect mutation阶段mutation阶段也是遍历effectList，执行函数。这里执行的是commitMutationEffects。 nextEffect = firstEffect; do &#123; try &#123; commitMutationEffects(root, renderPriorityLevel); &#125; catch (error) &#123; invariant(nextEffect !== null, 'Should be working on an effect.'); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; while (nextEffect !== null); commitMutationEffectsfunction commitMutationEffects(root: FiberRoot, renderPriorityLevel) &#123; // 遍历effectList 链表上的节点 while (nextEffect !== null) &#123; const flags = nextEffect.flags; // 根据 ContentReset flags重置文字节点 if (flags &amp; ContentReset) &#123; // 是否重置文本节点 commitResetTextContent(nextEffect); &#125; // 是否有 ref的更新 if (flags &amp; Ref) &#123; const current = nextEffect.alternate; if (current !== null) &#123; commitDetachRef(current); &#125; &#125; // mutation阶段最重要的工作 // 判断flags是否有以下情况， 根据 flags 分别处理 const primaryflags = flags &amp; (Placement | Update | Deletion | Hydrating); switch (primaryflags) &#123; // 插入DOM case Placement: &#123; // 执行完commitPlacement方法后，DOM节点已经插入到页面中 commitPlacement(nextEffect); // 插入DOM // 为当前fiber节点删除flags nextEffect.flags &amp;= ~Placement; break; &#125; // 插入DOM 并 更新DOM case PlacementAndUpdate: &#123; // 同时存在Placement和Update情况 // 插入 commitPlacement(nextEffect); nextEffect.flags &amp;= ~Placement; // 更新 const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; // SSR case Hydrating: &#123; nextEffect.flags &amp;= ~Hydrating; break; &#125; // SSR case HydratingAndUpdate: &#123; nextEffect.flags &amp;= ~Hydrating; const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; // 更新DOM case Update: &#123; const current = nextEffect.alternate; commitWork(current, nextEffect); break; &#125; // 删除DOM // 对应FunctionComponent的fiber节点销毁，会执行useEffect返回的销毁函数 // classComponent节点销毁，会执行componentWillUnmount生命周期钩子。 // 如果是HostComponent，会解绑它的ref属性 case Deletion: &#123; commitDeletion(root, nextEffect, renderPriorityLevel); break; &#125; &#125; nextEffect = nextEffect.nextEffect; &#125; &#125; function commitWork(current: Fiber | null, finishedWork: Fiber): void &#123; // 是否支持Mutation环境 if (!supportsMutation) &#123; switch (finishedWork.tag) &#123; case FunctionComponent: case ForwardRef: case MemoComponent: case SimpleMemoComponent: case Block: &#123; if ( enableProfilerTimer &amp;&amp; enableProfilerCommitHooks &amp;&amp; finishedWork.mode &amp; ProfileMode ) &#123; try &#123; startLayoutEffectTimer(); commitHookEffectListUnmount( HookLayout | HookHasEffect, finishedWork, ); &#125; finally &#123; recordLayoutEffectDuration(finishedWork); &#125; &#125; else &#123; commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork); &#125; return; &#125; case Profiler: &#123; return; &#125; case SuspenseComponent: &#123; commitSuspenseComponent(finishedWork); attachSuspenseRetryListeners(finishedWork); return; &#125; case SuspenseListComponent: &#123; attachSuspenseRetryListeners(finishedWork); return; &#125; case HostRoot: &#123; if (supportsHydration) &#123; const root: FiberRoot = finishedWork.stateNode; if (root.hydrate) &#123; // We've just hydrated. No need to hydrate again. root.hydrate = false; commitHydratedContainer(root.containerInfo); &#125; &#125; break; &#125; case OffscreenComponent: case LegacyHiddenComponent: &#123; return; &#125; &#125; commitContainer(finishedWork); return; &#125; // 判断fiber节点的tag，做不同的处理 switch (finishedWork.tag) &#123; // FunctionComponent相关的类型——start case FunctionComponent: case ForwardRef: case MemoComponent: case SimpleMemoComponent: case Block: &#123; if ( enableProfilerTimer &amp;&amp; enableProfilerCommitHooks &amp;&amp; finishedWork.mode &amp; ProfileMode ) &#123; try &#123; startLayoutEffectTimer(); // 调用useLayoutEffect的销毁函数 commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork); &#125; finally &#123; recordLayoutEffectDuration(finishedWork); &#125; &#125; else &#123; commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork); &#125; return; &#125; // FunctionComponent相关的类型——结束 case ClassComponent: &#123; return; &#125; // DOM节点对应的fiber节点 case HostComponent: &#123; const instance: Instance = finishedWork.stateNode; if (instance != null) &#123; // Commit the work prepared earlier. const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps // as the newProps. The updatePayload will contain the real change in // this case. const oldProps = current !== null ? current.memoizedProps : newProps; const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components. const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any); finishedWork.updateQueue = null; if (updatePayload !== null) &#123; commitUpdate( instance, updatePayload, // 是当前fiber节点的updateQueue属性 type, oldProps, newProps, finishedWork, ); &#125; &#125; return; &#125; case HostText: &#123; const textInstance: TextInstance = finishedWork.stateNode; const newText: string = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps // as the newProps. The updatePayload will contain the real change in // this case. const oldText: string = current !== null ? current.memoizedProps : newText; commitTextUpdate(textInstance, oldText, newText); return; &#125; case HostRoot: &#123; if (supportsHydration) &#123; const root: FiberRoot = finishedWork.stateNode; if (root.hydrate) &#123; // We've just hydrated. No need to hydrate again. root.hydrate = false; commitHydratedContainer(root.containerInfo); &#125; &#125; return; &#125; case Profiler: &#123; return; &#125; case SuspenseComponent: &#123; commitSuspenseComponent(finishedWork); attachSuspenseRetryListeners(finishedWork); return; &#125; case SuspenseListComponent: &#123; attachSuspenseRetryListeners(finishedWork); return; &#125; case IncompleteClassComponent: &#123; return; &#125; case FundamentalComponent: &#123; if (enableFundamentalAPI) &#123; const fundamentalInstance = finishedWork.stateNode; updateFundamentalComponent(fundamentalInstance); return; &#125; break; &#125; case ScopeComponent: &#123; if (enableScopeAPI) &#123; const scopeInstance = finishedWork.stateNode; prepareScopeUpdate(scopeInstance, finishedWork); return; &#125; break; &#125; case OffscreenComponent: case LegacyHiddenComponent: &#123; const newState: OffscreenState | null = finishedWork.memoizedState; const isHidden = newState !== null; hideOrUnhideAllChildren(finishedWork, isHidden); return; &#125; &#125; &#125; // ReactDOMHostConfig.js export function commitUpdate( domElement: Instance, updatePayload: Array&lt;mixed>, type: string, oldProps: Props, newProps: Props, internalInstanceHandle: Object, ): void &#123; updateFiberProps(domElement, newProps); // 更新DOM的属性 updateProperties(domElement, updatePayload, type, oldProps, newProps); &#125; commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作： 根据ContentReset flags重置文字节点 更新ref 根据flags分别处理，其中flags包括(Placement | Update | Deletion | Hydrating) 我们关注步骤三中的Placement | Update | Deletion。Hydrating作为服务端渲染相关，我们先不关注。 commitPlacement方法的逻辑function commitPlacement(finishedWork: Fiber): void &#123; // 如果当前环境不支持Mutation，直接返回（ReactDOM环境支持Mutation） if (!supportsMutation) &#123; return; &#125; // Recursively insert all host nodes into the parent. // 根据fiber节点 找到离它最近的HostComponent 节点 const parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together. let parent; let isContainer; const parentStateNode = parentFiber.stateNode; switch (parentFiber.tag) &#123; case HostComponent: parent = parentStateNode; isContainer = false; break; case HostRoot: parent = parentStateNode.containerInfo; isContainer = true; break; case HostPortal: parent = parentStateNode.containerInfo; isContainer = true; break; case FundamentalComponent: if (enableFundamentalAPI) &#123; parent = parentStateNode.instance; isContainer = false; &#125; // eslint-disable-next-line-no-fallthrough default: // 省略... &#125; if (parentFiber.flags &amp; ContentReset) &#123; // Reset the text content of the parent before doing any insertions resetTextContent(parent); // Clear ContentReset from the effect tag parentFiber.flags &amp;= ~ContentReset; &#125; // 找到当前fiber节点 对应 Host类型的兄弟节点 const before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its // children to find all the terminal nodes. // if else里面两个方法执行的逻辑类似 if (isContainer) &#123; insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent); &#125; else &#123; insertOrAppendPlacementNode(finishedWork, before, parent); &#125; &#125; function insertOrAppendPlacementNodeIntoContainer( node: Fiber, before: ?Instance, parent: Container, ): void &#123; const &#123;tag&#125; = node; const isHost = tag === HostComponent || tag === HostText; if (isHost || (enableFundamentalAPI &amp;&amp; tag === FundamentalComponent)) &#123; const stateNode = isHost ? node.stateNode : node.stateNode.instance; // 如果当前fiber节点的 兄弟节点存在，就会执行insertInContainerBefore if (before) &#123; insertInContainerBefore(parent, stateNode, before); // insertInContainerBefore方法最终调用的就是 insertBefore &#125; else &#123; // before不存在 执行 appendChildToContainer(parent, stateNode); &#125; &#125; else if (tag === HostPortal) &#123; // If the insertion itself is a portal, then we don't want to traverse // down its children. Instead, we'll get insertions from each child in // the portal directly. &#125; else &#123; const child = node.child; if (child !== null) &#123; insertOrAppendPlacementNodeIntoContainer(child, before, parent); let sibling = child.sibling; while (sibling !== null) &#123; insertOrAppendPlacementNodeIntoContainer(sibling, before, parent); sibling = sibling.sibling; &#125; &#125; &#125; &#125; function insertOrAppendPlacementNode( node: Fiber, before: ?Instance, parent: Instance, ): void &#123; const &#123;tag&#125; = node; const isHost = tag === HostComponent || tag === HostText; if (isHost || (enableFundamentalAPI &amp;&amp; tag === FundamentalComponent)) &#123; const stateNode = isHost ? node.stateNode : node.stateNode.instance; if (before) &#123; insertBefore(parent, stateNode, before); &#125; else &#123; appendChild(parent, stateNode); &#125; &#125; else if (tag === HostPortal) &#123; // If the insertion itself is a portal, then we don't want to traverse // down its children. Instead, we'll get insertions from each child in // the portal directly. &#125; else &#123; const child = node.child; if (child !== null) &#123; insertOrAppendPlacementNode(child, before, parent); let sibling = child.sibling; while (sibling !== null) &#123; insertOrAppendPlacementNode(sibling, before, parent); sibling = sibling.sibling; &#125; &#125; &#125; &#125; // 一直递归向上查找，一直找到为止 function getHostParentFiber(fiber: Fiber): Fiber &#123; let parent = fiber.return; while (parent !== null) &#123; if (isHostParent(parent)) &#123; return parent; &#125; parent = parent.return; &#125; &#125; // 这个方法复杂，双层循环 function getHostSibling(fiber: Fiber): ?Instance &#123; let node: Fiber = fiber; siblings: while (true) &#123; // If we didn't find anything, let's try the next sibling. while (node.sibling === null) &#123; if (node.return === null || isHostParent(node.return)) &#123; // If we pop out of the root or hit the parent the fiber we are the // last sibling. return null; &#125; node = node.return; &#125; node.sibling.return = node.return; node = node.sibling; while ( node.tag !== HostComponent &amp;&amp; node.tag !== HostText &amp;&amp; node.tag !== DehydratedFragment ) &#123; // If it is not host node and, we might have a host node inside it. // Try to search down until we find one. if (node.flags &amp; Placement) &#123; // If we don't have a child, try the siblings instead. continue siblings; &#125; // If we don't have a child, try the siblings instead. // We also skip portals because they are not part of this host tree. if (node.child === null || node.tag === HostPortal) &#123; continue siblings; &#125; else &#123; node.child.return = node; node = node.child; &#125; &#125; // Check if this host node is stable or about to be placed. if (!(node.flags &amp; Placement)) &#123; // Found it! return node.stateNode; &#125; &#125; &#125; insertInContainerBefore、appendChild、appendChildToContainer和insertBefore方法逻辑// ReactDOMHostConfig.js export function insertInContainerBefore( container: Container, child: Instance | TextInstance, beforeChild: Instance | TextInstance | SuspenseInstance, ): void &#123; if (container.nodeType === COMMENT_NODE) &#123; (container.parentNode: any).insertBefore(child, beforeChild); &#125; else &#123; container.insertBefore(child, beforeChild); &#125; &#125; export function appendChild( parentInstance: Instance, child: Instance | TextInstance, ): void &#123; // parent节点对应 DOM 的appendChild方法 parentInstance.appendChild(child); &#125; export function appendChildToContainer( container: Container, child: Instance | TextInstance, ): void &#123; let parentNode; if (container.nodeType === COMMENT_NODE) &#123; parentNode = (container.parentNode: any); parentNode.insertBefore(child, container); &#125; else &#123; parentNode = container; parentNode.appendChild(child); &#125; const reactRootContainer = container._reactRootContainer; if ( (reactRootContainer === null || reactRootContainer === undefined) &amp;&amp; parentNode.onclick === null ) &#123; // TODO: This cast may not be sound for SVG, MathML or custom elements. trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement)); &#125; &#125; export function insertBefore( parentInstance: Instance, child: Instance | TextInstance, beforeChild: Instance | TextInstance | SuspenseInstance, ): void &#123; parentInstance.insertBefore(child, beforeChild); &#125; Placement effect当Fiber节点含有Placement flags，意味着该Fiber节点对应的DOM节点需要插入到页面中。调用的方法为commitPlacement。 该方法所做的工作分为三步： 获取父级DOM节点。其中finishedWork为传入的Fiber节点。 const parentFiber = getHostParentFiber(finishedWork); // 父级DOM节点 const parentStateNode = parentFiber.stateNode; 获取Fiber节点的DOM兄弟节点 const before = getHostSibling(finishedWork); 根据DOM兄弟节点是否存在决定调用parentNode.insertBefore或parentNode.appendChild执行DOM插入操作。 // parentStateNode是否是rootFiber if (isContainer) &#123; insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent); &#125; else &#123; insertOrAppendPlacementNode(finishedWork, before, parent); &#125; 值得注意的是，getHostSibling（获取兄弟DOM节点）的执行很耗时，当在同一个父Fiber节点下依次执行多个插入操作，getHostSibling算法的复杂度为指数级。 这是由于Fiber节点不只包括HostComponent，所以Fiber树和渲染的DOM树节点并不是一一对应的。要从Fiber节点找到DOM节点很可能跨层级遍历。在DOM树中，li的父级是div，在fiber树中，li的fiber节点对应的 fiber 父节点是Item。Item的父级fiber节点才是div。 考虑如下例子： function Item() &#123; return &lt;li>&lt;li>; &#125; function App() &#123; return ( &lt;div> &lt;Item/> &lt;/div> ) &#125; ReactDOM.render(&lt;App/>, document.getElementById('root')); 对应的Fiber树和DOM树结构为： // Fiber树 child child child child rootFiber -----> App -----> div -----> Item -----> li // DOM树 #root ---> div ---> li 当在div的子节点Item前插入一个新节点p，即App变为： function App() &#123; return ( &lt;div> &lt;p>&lt;/p> &lt;Item/> &lt;/div> ) &#125; 对应的Fiber树和DOM树结构为： // Fiber树 child child child rootFiber -----> App -----> div -----> p | sibling child | -------> Item -----> li // DOM树 #root ---> div ---> p | ---> li 此时DOM节点 p的兄弟节点为li，而Fiber节点 p对应的兄弟DOM节点为： fiberP.sibling.child 即fiber p的兄弟fiber Item的子fiber li Update effect当Fiber节点含有Update flags，意味着该Fiber节点需要更新。调用的方法为commitWork，他会根据Fiber.tag分别处理。 你可以在这里看到commitWork源码 这里我们主要关注FunctionComponent和HostComponent。 FunctionComponent mutation当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有useLayoutEffect hook的销毁函数。 你可以在这里看到commitHookEffectListUnmount源码 所谓“销毁函数”，见如下例子： useLayoutEffect(() => &#123; // ...一些副作用逻辑 return () => &#123; // ...这就是销毁函数 &#125; &#125;) 你不需要很了解useLayoutEffect，我们会在下一节详细介绍。你只需要知道在mutation阶段会执行useLayoutEffect的销毁函数。 HostComponent mutation当fiber.tag为HostComponent，会调用commitUpdate。 你可以在这里看到commitUpdate源码 最终会在updateDOMProperties中将render阶段 completeWork中为Fiber节点赋值的updateQueue对应的内容渲染在页面上。 for (let i = 0; i &lt; updatePayload.length; i += 2) &#123; const propKey = updatePayload[i]; const propValue = updatePayload[i + 1]; // 处理 style if (propKey === STYLE) &#123; setValueForStyles(domElement, propValue); // 处理 DANGEROUSLY_SET_INNER_HTML &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML) &#123; setInnerHTML(domElement, propValue); // 处理 children &#125; else if (propKey === CHILDREN) &#123; setTextContent(domElement, propValue); &#125; else &#123; // 处理剩余 props setValueForProperty(domElement, propKey, propValue, isCustomComponentTag); &#125; &#125; Deletion effect当Fiber节点含有Deletion flags，意味着该Fiber节点对应的DOM节点需要从页面中删除。调用的方法为commitDeletion。 你可以在这里看到commitDeletion源码 该方法会执行如下操作： 递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount生命周期钩子，从页面移除Fiber节点对应DOM节点 解绑ref 调度useEffect的销毁函数 总结从这节我们学到，mutation阶段会遍历effectList，依次执行commitMutationEffects。该方法的主要工作为“根据flags调用不同的处理函数处理Fiber。 layout阶段该阶段之所以称为layout，因为该阶段的代码都是在DOM渲染完成（mutation阶段完成）后执行的。 该阶段触发的生命周期钩子和hook可以直接访问到已经改变后的DOM，即该阶段是可以参与DOM layout的阶段。 概览与前两个阶段类似，layout阶段也是遍历effectList，执行函数。 具体执行的函数是commitLayoutEffects。 root.current = finishedWork; nextEffect = firstEffect; do &#123; try &#123; commitLayoutEffects(root, lanes); &#125; catch (error) &#123; invariant(nextEffect !== null, \"Should be working on an effect.\"); captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; &#125; &#125; while (nextEffect !== null); nextEffect = null; commitLayoutEffects代码如下： 你可以在这里看到commitLayoutEffects源码 function commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) &#123; while (nextEffect !== null) &#123; const effectTag = nextEffect.effectTag; // 调用生命周期钩子和hook if (effectTag &amp; (Update | Callback)) &#123; const current = nextEffect.alternate; // 最重要的是调用这个方法 commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes); &#125; // 处理赋值ref if (effectTag &amp; Ref) &#123; commitAttachRef(nextEffect); &#125; nextEffect = nextEffect.nextEffect; &#125; &#125; commitLayoutEffects一共做了两件事： commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作） commitAttachRef（赋值 ref） commitLayoutEffectOnFibercommitLayoutEffectOnFiber方法会根据fiber.tag对不同类型的节点分别处理。 commitLayoutEffectOnFiber源码（commitLayoutEffectOnFiber为别名，方法原名为commitLifeCycles） componentDidMount和componentDidUpdate是在layout阶段同步执行的。 function commitLifeCycles( finishedRoot: FiberRoot, current: Fiber | null, finishedWork: Fiber, committedLanes: Lanes, ): void &#123; switch (finishedWork.tag) &#123; case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: &#123; // At this point layout effects have already been destroyed (during mutation phase). // This is done to prevent sibling component effects from interfering with each other, // e.g. a destroy function in one component should never override a ref set // by a create function in another component during the same commit. if ( enableProfilerTimer &amp;&amp; enableProfilerCommitHooks &amp;&amp; finishedWork.mode &amp; ProfileMode ) &#123; try &#123; startLayoutEffectTimer(); // HookLayout是useLayoutEffect对应的flags commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); &#125; finally &#123; recordLayoutEffectDuration(finishedWork); &#125; &#125; else &#123; // HookLayout是useLayoutEffect对应的flags commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); &#125; schedulePassiveEffects(finishedWork); return; &#125; case ClassComponent: &#123; // 获取 ClassComponent的实例 const instance = finishedWork.stateNode; if (finishedWork.flags &amp; Update) &#123; // current为空 if (current === null) &#123; if ( enableProfilerTimer &amp;&amp; enableProfilerCommitHooks &amp;&amp; finishedWork.mode &amp; ProfileMode ) &#123; try &#123; startLayoutEffectTimer(); // 执行ClassComponent实例的钩子componentDidMount instance.componentDidMount(); &#125; finally &#123; recordLayoutEffectDuration(finishedWork); &#125; &#125; else &#123; // 执行ClassComponent实例的钩子componentDidMount instance.componentDidMount(); &#125; &#125; else &#123; // current存在的情况 const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps); const prevState = current.memoizedState; if ( enableProfilerTimer &amp;&amp; enableProfilerCommitHooks &amp;&amp; finishedWork.mode &amp; ProfileMode ) &#123; try &#123; startLayoutEffectTimer(); // 执行ClassComponent实例的钩子componentDidUpdate instance.componentDidUpdate( prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate, ); &#125; finally &#123; recordLayoutEffectDuration(finishedWork); &#125; &#125; else &#123; // 执行ClassComponent实例的钩子componentDidUpdate instance.componentDidUpdate( prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate, ); &#125; &#125; &#125; // TODO: I think this is now always non-null by the time it reaches the // commit phase. Consider removing the type check. const updateQueue: UpdateQueue&lt; *, > | null = (finishedWork.updateQueue: any); if (updateQueue !== null) &#123; // ClassComponent commitUpdateQueue(finishedWork, updateQueue, instance); &#125; return; &#125; case HostRoot: &#123; // TODO: I think this is now always non-null by the time it reaches the // commit phase. Consider removing the type check. const updateQueue: UpdateQueue&lt; *, > | null = (finishedWork.updateQueue: any); if (updateQueue !== null) &#123; let instance = null; if (finishedWork.child !== null) &#123; switch (finishedWork.child.tag) &#123; case HostComponent: instance = getPublicInstance(finishedWork.child.stateNode); break; case ClassComponent: instance = finishedWork.child.stateNode; break; &#125; &#125; // HostRoot commitUpdateQueue(finishedWork, updateQueue, instance); &#125; return; &#125; case HostComponent: &#123; const instance: Instance = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted // (eg DOM renderer may schedule auto-focus for inputs and form controls). // These effects should only be committed when components are first mounted, // aka when there is no current/alternate. if (current === null &amp;&amp; finishedWork.flags &amp; Update) &#123; const type = finishedWork.type; const props = finishedWork.memoizedProps; commitMount(instance, type, props, finishedWork); &#125; return; &#125; case HostText: &#123; // We have no life-cycles associated with text. return; &#125; case HostPortal: &#123; // We have no life-cycles associated with portals. return; &#125; case Profiler: &#123; if (enableProfilerTimer) &#123; const &#123;onCommit, onRender&#125; = finishedWork.memoizedProps; const &#123;effectDuration&#125; = finishedWork.stateNode; const commitTime = getCommitTime(); if (typeof onRender === 'function') &#123; if (enableSchedulerTracing) &#123; onRender( finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions, ); &#125; else &#123; onRender( finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, ); &#125; &#125; if (enableProfilerCommitHooks) &#123; if (typeof onCommit === 'function') &#123; if (enableSchedulerTracing) &#123; onCommit( finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', effectDuration, commitTime, finishedRoot.memoizedInteractions, ); &#125; else &#123; onCommit( finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', effectDuration, commitTime, ); &#125; &#125; // Schedule a passive effect for this Profiler to call onPostCommit hooks. // This effect should be scheduled even if there is no onPostCommit callback for this Profiler, // because the effect is also where times bubble to parent Profilers. enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor. // Do not reset these values until the next render so DevTools has a chance to read them first. let parentFiber = finishedWork.return; while (parentFiber !== null) &#123; if (parentFiber.tag === Profiler) &#123; const parentStateNode = parentFiber.stateNode; parentStateNode.effectDuration += effectDuration; break; &#125; parentFiber = parentFiber.return; &#125; &#125; &#125; return; &#125; case SuspenseComponent: &#123; commitSuspenseHydrationCallbacks(finishedRoot, finishedWork); return; &#125; case SuspenseListComponent: case IncompleteClassComponent: case FundamentalComponent: case ScopeComponent: case OffscreenComponent: case LegacyHiddenComponent: return; &#125; &#125; commitHookEffectListMount遍历所有useLayoutEffect，依次执行它的回调函数。在mutation阶段会执行useLayoutEffect的销毁函数，在layout阶段会依次遍历useLayoutEffect的create()方法，也就是它的回调函数。所有useLayoutEffect在commmit阶段，先执行所有的销毁函数，再依次执行所有的回调函数，这整个步骤都是同步执行的。// tag是HookLayout，是useLayoutEffect对应的flags function commitHookEffectListMount(tag: number, finishedWork: Fiber) &#123; const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any); const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null; if (lastEffect !== null) &#123; const firstEffect = lastEffect.next; let effect = firstEffect; do &#123; if ((effect.tag &amp; tag) === tag) &#123; // Mount const create = effect.create; effect.destroy = create(); &#125; effect = effect.next; &#125; while (effect !== firstEffect); &#125; &#125; schedulePassiveEffectsfunction schedulePassiveEffects(finishedWork: Fiber) &#123; const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any); const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null; if (lastEffect !== null) &#123; const firstEffect = lastEffect.next; let effect = firstEffect; do &#123; const &#123;next, tag&#125; = effect; if ( (tag &amp; HookPassive) !== NoHookEffect &amp;&amp; (tag &amp; HookHasEffect) !== NoHookEffect ) &#123; enqueuePendingPassiveHookEffectUnmount(finishedWork, effect); enqueuePendingPassiveHookEffectMount(finishedWork, effect); &#125; effect = next; &#125; while (effect !== firstEffect); &#125; &#125; commitUpdateQueue在commitLifeCycles方法中，finishedWork.tag为ClassComponent和HostRoot都会执行commitUpdateQueue。对应ClassComponent，调用this.setState的第二个参数，也就是传入给this.setState回调函数时，this.setState回调函数会在layout阶段执行。对于HostRoot，我们执行ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;), function)的第三个参数，回调函数function。当我们首屏渲染时，页面完成了渲染，第三个参数回调函数会在layout阶段执行。 // ReactUpdateQueue.old.js export function commitUpdateQueue&lt;State>( finishedWork: Fiber, finishedQueue: UpdateQueue&lt;State>, instance: any, ): void &#123; // Commit the effects const effects = finishedQueue.effects; finishedQueue.effects = null; if (effects !== null) &#123; // 遍历effects，并执行effects下的callback for (let i = 0; i &lt; effects.length; i++) &#123; const effect = effects[i]; const callback = effect.callback; if (callback !== null) &#123; effect.callback = null; callCallback(callback, instance); &#125; &#125; &#125; &#125; 对于ClassComponent，他会通过current === null?区分是mount还是update，调用componentDidMount或componentDidUpdate。 触发状态更新的this.setState如果赋值了第二个参数回调函数，也会在此时调用。 this.setState(&#123; xxx: 1 &#125;, () => &#123; console.log(\"i am update~\"); &#125;); 对于FunctionComponent及相关类型，他会调用useLayoutEffect hook的回调函数，调度useEffect的销毁与回调函数 相关类型指特殊处理后的FunctionComponent，比如ForwardRef、React.memo包裹的FunctionComponent switch (finishedWork.tag) &#123; // 以下都是FunctionComponent及相关类型 case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: &#123; // 执行useLayoutEffect的回调函数 commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); // 调度useEffect的销毁函数与回调函数 schedulePassiveEffects(finishedWork); return; &#125; 你可以从这里看到这段代码 在上一节介绍Update effect时介绍过，mutation阶段会执行useLayoutEffect hook的销毁函数。 结合这里我们可以发现，useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。 而useEffect则需要先调度，在Layout阶段完成后再异步执行。 这就是useLayoutEffect与useEffect的区别。 对于HostRoot，即rootFiber，如果赋值了第三个参数回调函数，也会在此时调用。 ReactDOM.render(&lt;App />, document.querySelector(\"#root\"), function() &#123; console.log(\"i am mount~\"); &#125;); commitAttachRefcommitLayoutEffects会做的第二件事是commitAttachRef。 你可以在这里看到commitAttachRef源码 function commitAttachRef(finishedWork: Fiber) &#123; const ref = finishedWork.ref; if (ref !== null) &#123; const instance = finishedWork.stateNode; // 获取DOM实例 let instanceToUse; switch (finishedWork.tag) &#123; case HostComponent: instanceToUse = getPublicInstance(instance); break; default: instanceToUse = instance; &#125; if (typeof ref === \"function\") &#123; // 如果ref是函数形式，调用回调函数 ref(instanceToUse); &#125; else &#123; // 如果ref是ref实例形式，赋值ref.current ref.current = instanceToUse; &#125; &#125; &#125; 代码逻辑很简单：获取DOM实例，更新ref。 current Fiber树切换至此，整个layout阶段就结束了。 在结束本节的学习前，我们关注下这行代码： root.current = finishedWork; 你可以在这里看到这行代码 在双缓存机制一节我们介绍过，workInProgress Fiber树在commit阶段完成渲染后会变为current Fiber树。这行代码的作用就是切换fiberRootNode指向的current Fiber树。 那么这行代码为什么在这里呢？（在mutation阶段结束后，layout阶段开始前。） 我们知道componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的。 componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的。 总结从这节我们学到，layout阶段会遍历effectList，依次执行commitLayoutEffects。该方法的主要工作为“根据effectTag调用不同的处理函数处理Fiber并更新ref。 useEffect 和 useLayoutEffect的区别useLayoutEffect依赖某个state变化而触发时，是同步执行的，在useLayoutEffect中setsState是同步的，需要添加条件判断特定state，执行特定的逻辑（useLayoutEffect可以拿到最新的state） useEffect 和 useLayoutEffect的区别, useEffect的回调是异步更新的","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【React源码】React的render阶段","slug":"front_end/react-render","date":"2022-06-19T19:25:33.000Z","updated":"2022-10-13T17:15:34.844Z","comments":true,"path":"2022/06/20/front_end/react-render/","link":"","permalink":"http://example.com/2022/06/20/front_end/react-render/","excerpt":"","text":"render阶段render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用，这取决于本次更新是同步更新还是异步更新。在这两个方法中会调用如下两个方法： // performSyncWorkOnRoot会调用该方法 function workLoopSync() &#123; while (workInProgress !== null) &#123; performUnitOfWork(workInProgress); &#125; &#125; // performConcurrentWorkOnRoot会调用该方法 function workLoopConcurrent() &#123; // shouldYield()的返回值为true，代表需要中止循环 React18 while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; performUnitOfWork(workInProgress); &#125; &#125; 可以看到，他们唯一的区别是是否调用shouldYield方法。如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历。 workInProgress代表当前已创建的workInProgress fiber工作树。 performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。 Fiber Reconciler（React16）是从Stack Reconciler（React15）重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。 “递”阶段 首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用 beginWork 方法。 beginWork作用：会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。 “归”阶段在“归”阶段会调用 completeWork 处理Fiber节点。当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !&#x3D;&#x3D; null），会进入其兄弟Fiber的“递”阶段。如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。 “递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。 例子以上一节的例子举例： function App() &#123; return ( &lt;div> 奔跑的 &lt;span>蜗牛&lt;/span> &lt;/div> ) &#125; ReactDOM.render(&lt;App />, document.getElementById(\"root\")); 对应的Fiber树结构： render阶段会依次执行： 1. rootFiber beginWork 2. App Fiber beginWork 3. div Fiber beginWork 4. &quot;奔跑的&quot; Fiber beginWork 5. &quot;奔跑的&quot; Fiber completeWork 6. span Fiber beginWork 7. span Fiber completeWork 8. div Fiber completeWork 9. App Fiber completeWork 10. rootFiber completeWork 之所以没有 “蜗牛” Fiber 的 beginWork&#x2F;completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。不会为唯一纯文本的子节点创建一个独立的fiber节点。 如果将performUnitOfWork转化为递归版本，大体代码如下： function performUnitOfWork(fiber) &#123; // 执行beginWork if (fiber.child) &#123; performUnitOfWork(fiber.child); &#125; // 执行completeWork if (fiber.sibling) &#123; performUnitOfWork(fiber.sibling); &#125; &#125; beginWork从传参看beginWork方法执行function beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes, ): Fiber | null &#123; // ...省略函数体 &#125; 其中传参： current：当前组件对应的Fiber节点在上一次更新时的Fiber节点，即workInProgress.alternate workInProgress：当前组件对应的Fiber节点 renderLanes：优先级相关，在讲解Scheduler时再讲解 除rootFiber以外， 组件mount时，由于是首次渲染，是不存在当前组件对应的Fiber节点在上一次更新时的Fiber节点，即mount时current === null。 组件update时，由于之前已经mount过，所以current !== null。 所以我们可以通过current === null ?来区分组件是处于mount还是update。 基于此原因，beginWork的工作可以分为两部分： update时：如果current存在，在满足一定条件时可以复用current节点，这样就能克隆current.child作为workInProgress.child，而不需要新建workInProgress.child。 mount时：除fiberRootNode以外，current === null。会根据fiber.tag不同，创建不同类型的子Fiber节点 function beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null &#123; // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点） if (current !== null) &#123; var oldProps = current.memoizedProps; var newProps = workInProgress.pendingProps; // 当前 fiber节点是否有变化， // 新旧props是否相等，是否有context的变化 if (oldProps !== newProps || hasContextChanged() || ( workInProgress.type !== current.type)) &#123; // type是否改变 didReceiveUpdate = true; &#125; else &#123; // Neither props nor legacy context changes. Check if there's a pending // update or context change. var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes); if (!hasScheduledUpdateOrContext &amp;&amp; // If this is the second pass of an error or suspense boundary, there // may not be work scheduled on `current`, so we check for this flag. (workInProgress.flags &amp; DidCapture) === NoFlags) &#123; // No pending updates or context. Bail out now. didReceiveUpdate = false; return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes); &#125; if ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123; // This is a special case that only exists for legacy mode. // See https://github.com/facebook/react/pull/19216. didReceiveUpdate = true; &#125; else &#123; // An update was scheduled on this fiber, but there are no new props // nor legacy context. Set this to false. If an update queue or context // consumer produces a changed value, it will set this to true. Otherwise, // the component will assume the children have not changed and bail out. didReceiveUpdate = false; &#125; &#125; // 本次更新中： didReceiveUpdate代表当前fiber节点 是否有变化， didReceiveUpdate = true &#125; else &#123; didReceiveUpdate = false; // ...省略 &#125; // mount时：根据tag不同，创建不同的子Fiber节点 switch (workInProgress.tag) &#123; case IndeterminateComponent: // ...省略 case LazyComponent: // ...省略 case FunctionComponent: // ...省略 case ClassComponent: // ...省略 case HostRoot: // ...省略 case HostComponent: // ...省略 case HostText: // ...省略 // ...省略其他类型 &#125; &#125; update时我们可以看到，满足如下情况时didReceiveUpdate === false（即可以直接复用前一次更新的子Fiber，不需要新建子Fiber） oldProps === newProps &amp;&amp; workInProgress.type === current.type，即props与fiber.type不变 !includesSomeLane(renderLanes, updateLanes)，即当前Fiber节点优先级不够，会在讲解Scheduler时介绍 if (current !== null) &#123; const oldProps = current.memoizedProps; const newProps = workInProgress.pendingProps; if ( oldProps !== newProps || hasLegacyContextChanged() || (__DEV__ ? workInProgress.type !== current.type : false) ) &#123; didReceiveUpdate = true; &#125; else if (!includesSomeLane(renderLanes, updateLanes)) &#123; didReceiveUpdate = false; switch (workInProgress.tag) &#123; // 省略处理 &#125; return bailoutOnAlreadyFinishedWork( current, workInProgress, renderLanes, ); &#125; else &#123; didReceiveUpdate = false; &#125; &#125; else &#123; didReceiveUpdate = false; &#125; mount时当不满足优化路径时，我们就进入第二部分，新建子Fiber。 我们可以看到，根据fiber.tag不同，进入不同类型Fiber的创建逻辑。 可以从ReactWorkTags.js看到tag对应的组件类型 // mount时：根据tag不同，创建不同的Fiber节点 switch (workInProgress.tag) &#123; case IndeterminateComponent: // ...省略 case LazyComponent: // ...省略 case FunctionComponent: // ...省略 case ClassComponent: // ...省略 case HostRoot: // ...省略 case HostComponent: // ...省略 case HostText: // ...省略 // ...省略其他类型 &#125; 对于我们常见的组件类型，如（FunctionComponent&#x2F;ClassComponent&#x2F;HostComponent），最终会进入reconcileChildren方法。 reconcileChildren从该函数名就能看出这是Reconciler模块的核心部分。那么他究竟做了什么呢？ 对于mount的组件，他会创建新的子Fiber节点，并返回新的子fiber 对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点 // 当 某个节点 不存在对应 的current节点时，它是不会被标记 flags的， export function reconcileChildren( current: Fiber | null, workInProgress: Fiber, nextChildren: any, // 子fiber 对应的JSX对象 renderLanes: Lanes ) &#123; if (current === null) &#123; // 对于mount的组件 // 不会为 `Fiber节点`带上`flags`属性 workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes, ); &#125; else &#123; // 对于update的组件 // 为生成的`Fiber节点`带上`flags`属性 首屏渲染时，只有 页面的根节点走这里，为APP组件标记 flags workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes, ); &#125; &#125; // 这两个方法在ReactChildFiber中实现如下：传入不同的布尔值 // export const reconcileChildFibers = ChildReconciler(true); // export const mountChildFibers = ChildReconciler(false); 从代码可以看出，和beginWork一样，他也是通过current === null ?区分mount与update。 不论走哪个逻辑，最终他会生成新的子Fiber节点并赋值给workInProgress.child，作为本次beginWork返回值，并作为下次performUnitOfWork执行时workInProgress的传参。 mountChildFibers与reconcileChildFibers这两个方法的逻辑基本一致。唯一的区别是：reconcileChildFibers会为生成的Fiber节点带上flags属性，而mountChildFibers不会。 ChildReconciler方法// shouldTrackSideEffects是布尔值，是否追踪副作用， function ChildReconciler(shouldTrackSideEffects) &#123; // 删除一个child时 function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void &#123; if (!shouldTrackSideEffects) &#123; // 不追踪副作用直接return return; &#125; const last = returnFiber.lastEffect; if (last !== null) &#123; last.nextEffect = childToDelete; returnFiber.lastEffect = childToDelete; &#125; else &#123; returnFiber.firstEffect = returnFiber.lastEffect = childToDelete; &#125; childToDelete.nextEffect = null; // 要追踪副作用，最终它会为需要删除的fiber节点的 flags赋值为Deletion childToDelete.flags = Deletion; &#125; // 省略很多function... // 需要将当前fiber节点 对应的DOM节点插入到页面中 function placeChild( newFiber: Fiber, lastPlacedIndex: number, newIndex: number, ): number &#123; newFiber.index = newIndex; if (!shouldTrackSideEffects) &#123; // 不需要追踪副作用，直接return return lastPlacedIndex; &#125; const current = newFiber.alternate; if (current !== null) &#123; const oldIndex = current.index; if (oldIndex &lt; lastPlacedIndex) &#123; // This is a move. // 需要追踪，为flags 赋值为Placement // Placement作用在ReactFiberFlags查看 newFiber.flags = Placement; return lastPlacedIndex; &#125; else &#123; // This item can stay in place. return oldIndex; &#125; &#125; else &#123; // This is an insertion. newFiber.flags = Placement; return lastPlacedIndex; &#125; &#125; // 省略很多function... &#125; Flagsrender 阶段（reconciler 协调阶段）的工作是在内存中进行，不会执行具体的DOM操作，当工作结束后会通知Renderer（commit 渲染阶段）需要执行的DOM操作。要执行DOM操作的具体类型就保存在fiber.flags中。 你可以从ReactFiberFlags.js看到Flags对应的DOM操作，该文件保存了所有的标记，fiber标记的，用到了二进制数据，位运算等 render 阶段需要做的就是为 需要执行DOM操作的fiber节点打上标记，比如一个fiber节点对应的DOM节点需要插入到页面中，为当前fiber节点打上Placement标记。 比如： // ReactFiberFlags.js export type Flags = number; // Don't change these two values. They're used by React Dev Tools. export const NoFlags = /* */ 0b000000000000000000; export const PerformedWork = /* */ 0b000000000000000001; // 当前 fiber节点 对应的DOM需要插入到页面中 export const Placement = /* */ 0b00000000000010; // 当前 fiber节点 对应的DOM需要更新 export const Update = /* */ 0b00000000000100; // 当前 fiber节点 对应的DOM需要插入到页面中并更新 export const PlacementAndUpdate = /* */ 0b00000000000110; // 当前 fiber节点 对应的DOM需要删除 export const Deletion = /* */ 0b00000000001000; // 为什么需要用二进制的形式表示Flags？ // 比如一个fiber节点对应的DOM需要 先Placement再Update // 可以由 Flags 与 Placement、Update进行位运算，为fiber.flags切换标记 通过二进制表示flags，可以方便的使用位操作为fiber.flags赋值多个effect。 那么，如果要通知Renderer将Fiber节点对应的DOM节点插入页面中，需要满足两个条件： fiber.stateNode存在，即Fiber节点中保存了对应的DOM节点 (fiber.flags &amp; Placement) !== 0，即Fiber节点存在Placement flags 我们知道，mount时，fiber.stateNode === null，且在reconcileChildren中调用的mountChildFibers不会为Fiber节点赋值flags。那么首屏渲染如何完成呢？ 针对第一个问题，fiber.stateNode会在completeWork中创建，我们会在下一节介绍。 第二个问题的答案十分巧妙：假设mountChildFibers也会赋值flags，那么可以预见mount时整棵Fiber树所有节点都会有Placement flags。那么commit阶段在执行DOM操作时每个节点都会执行一次插入操作，这样大量的DOM操作是极低效的。 为了解决这个问题，在mount时只有rootFiber会赋值Placement flags，在commit阶段只会执行一次插入操作。 根Fiber节点 Demo借用上一节的Demo，第一个进入beginWork方法的Fiber节点就是rootFiber，他的alternate指向current rootFiber（即他存在current）。 由于存在current，rootFiber在reconcileChildren时会走reconcileChildFibers逻辑。 而之后通过beginWork创建的Fiber节点是不存在current的（即 fiber.alternate === null），会走mountChildFibers逻辑 beginWork流程图 reconcileChildFibers // reconcileChildFibers 会为fiber节点标记flags function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) &#123; // 判断当前child的类型，对不同的类型做不同的处理 var isUnkeyedTopLevelFragment = typeof newChild === 'object' &amp;&amp; newChild !== null &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === null; if (isUnkeyedTopLevelFragment) &#123; newChild = newChild.props.children; &#125; // Handle object types if (typeof newChild === 'object' &amp;&amp; newChild !== null) &#123; switch (newChild.$$typeof) &#123; // React.Element case REACT_ELEMENT_TYPE: return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes)); case REACT_PORTAL_TYPE: return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes)); case REACT_LAZY_TYPE: &#123; var payload = newChild._payload; var init = newChild._init; // TODO: This function is supposed to be non-recursive. return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes); &#125; &#125; // 当前newChild是一个数组，一个节点 包含多个子节点 if (isArray(newChild)) &#123; return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes); &#125; if (getIteratorFn(newChild)) &#123; return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes); &#125; throwOnInvalidObjectType(returnFiber, newChild); &#125; // 文本节点 当做SingleTextNode处理 if (typeof newChild === 'string' || typeof newChild === 'number') &#123; return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes)); &#125; &#123; if (typeof newChild === 'function') &#123; warnOnFunctionType(returnFiber); &#125; &#125; // Remaining cases are all treated as empty. return deleteRemainingChildren(returnFiber, currentFirstChild); &#125; reconcileSingleElement // reconcileSingleElement function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) &#123; var key = element.key; var child = currentFirstChild; // 在这个方法中，会判断它的child是否存在 while (child !== null) &#123; // TODO: If key === null and child.key === null, then this only applies to // the first item in the list. if (child.key === key) &#123; var elementType = element.type; // 判断它的类型 if (elementType === REACT_FRAGMENT_TYPE) &#123; if (child.tag === Fragment) &#123; deleteRemainingChildren(returnFiber, child.sibling); var existing = useFiber(child, element.props.children); existing.return = returnFiber; &#123; existing._debugSource = element._source; existing._debugOwner = element._owner; &#125; return existing; &#125; &#125; else &#123; if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path: isCompatibleFamilyForHotReloading(child, element)) || // Lazy types should reconcile their resolved type. // We need to do this after the Hot Reloading check above, // because hot reloading has different semantics than prod because // it doesn't resuspend. So we can't let the call below suspend. typeof elementType === 'object' &amp;&amp; elementType !== null &amp;&amp; elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp; resolveLazy(elementType) === child.type) &#123; deleteRemainingChildren(returnFiber, child.sibling); var _existing = useFiber(child, element.props); _existing.ref = coerceRef(returnFiber, child, element); _existing.return = returnFiber; &#123; _existing._debugSource = element._source; _existing._debugOwner = element._owner; &#125; return _existing; &#125; &#125; // Didn't match. deleteRemainingChildren(returnFiber, child); break; &#125; else &#123; deleteChild(returnFiber, child); &#125; child = child.sibling; &#125; if (element.type === REACT_FRAGMENT_TYPE) &#123; var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key); created.return = returnFiber; return created; &#125; else &#123; /** * 最终进入createFiberFromElement方法， * 通过React.Element数据来创建一个fiber节点 */ var _created4 = createFiberFromElement(element, returnFiber.mode, lanes); _created4.ref = coerceRef(returnFiber, currentFirstChild, element); _created4.return = returnFiber; return _created4; &#125; &#125; createFiberFromElement function createFiberFromElement(element, mode, lanes) &#123; var owner = null; &#123; owner = element._owner; &#125; var type = element.type; var key = element.key; var pendingProps = element.props; // createFiberFromTypeAndProps var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes); &#123; fiber._debugSource = element._source; fiber._debugOwner = element._owner; &#125; return fiber; &#125; createFiberFromTypeAndProps判断type的类型 function createFiberFromTypeAndProps(type, // React$ElementType key, pendingProps, owner, mode, lanes) &#123; var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy. var resolvedType = type; if (typeof type === 'function') &#123; if (shouldConstruct$1(type)) &#123; fiberTag = ClassComponent; &#123; resolvedType = resolveClassForHotReloading(resolvedType); &#125; &#125; else &#123; &#123; resolvedType = resolveFunctionForHotReloading(resolvedType); &#125; &#125; &#125; else if (typeof type === 'string') &#123; // HostComponent fiberTag = HostComponent; &#125; else &#123; getTag: switch (type) &#123; case REACT_FRAGMENT_TYPE: return createFiberFromFragment(pendingProps.children, mode, lanes, key); case REACT_DEBUG_TRACING_MODE_TYPE: fiberTag = Mode; mode |= DebugTracingMode; break; case REACT_STRICT_MODE_TYPE: fiberTag = Mode; mode |= StrictLegacyMode; if ((mode &amp; ConcurrentMode) !== NoMode) &#123; // Strict effects should never run on legacy roots mode |= StrictEffectsMode; &#125; break; case REACT_PROFILER_TYPE: return createFiberFromProfiler(pendingProps, mode, lanes, key); case REACT_SUSPENSE_TYPE: return createFiberFromSuspense(pendingProps, mode, lanes, key); case REACT_SUSPENSE_LIST_TYPE: return createFiberFromSuspenseList(pendingProps, mode, lanes, key); case REACT_OFFSCREEN_TYPE: return createFiberFromOffscreen(pendingProps, mode, lanes, key); case REACT_LEGACY_HIDDEN_TYPE: return createFiberFromLegacyHidden(pendingProps, mode, lanes, key); case REACT_SCOPE_TYPE: // eslint-disable-next-line no-fallthrough case REACT_CACHE_TYPE: &#123; return createFiberFromCache(pendingProps, mode, lanes, key); &#125; // eslint-disable-next-line no-fallthrough default: &#123; if (typeof type === 'object' &amp;&amp; type !== null) &#123; switch (type.$$typeof) &#123; case REACT_PROVIDER_TYPE: fiberTag = ContextProvider; break getTag; case REACT_CONTEXT_TYPE: // This is a consumer fiberTag = ContextConsumer; break getTag; case REACT_FORWARD_REF_TYPE: fiberTag = ForwardRef; &#123; resolvedType = resolveForwardRefForHotReloading(resolvedType); &#125; break getTag; case REACT_MEMO_TYPE: fiberTag = MemoComponent; break getTag; case REACT_LAZY_TYPE: fiberTag = LazyComponent; resolvedType = null; break getTag; &#125; &#125; var info = ''; &#123; if (type === undefined || typeof type === 'object' &amp;&amp; type !== null &amp;&amp; Object.keys(type).length === 0) &#123; info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.'; &#125; var ownerName = owner ? getComponentNameFromFiber(owner) : null; if (ownerName) &#123; info += '\\n\\nCheck the render method of `' + ownerName + '`.'; &#125; &#125; throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info)); &#125; &#125; &#125; // 接下来回创建 对应的createFiber节点 var fiber = createFiber(fiberTag, pendingProps, key, mode); fiber.elementType = type; fiber.type = resolvedType; fiber.lanes = lanes; &#123; fiber._debugOwner = owner; &#125; return fiber; &#125; // createFiber源码 const createFiber = function( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ): Fiber &#123; // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors return new FiberNode(tag, pendingProps, key, mode); &#125;; // FiberNode 描述fiber节点，上面有非常多的属性 总结当某个节点进入beginWork时，它最终的目的是创建当前fiber节点的第一个子fiber节点。首先，它会在updateHostComponent判断当前节点的类型，进入不同update的逻辑，在update的逻辑里（reconcileChildern）中，判断当前WorkInProgerss Fiber 是否存在对应的current fiber，来决定是否标记flags，接着会进入 reconcile的逻辑（reconcileChildernFibers），判断当前fiber节点的childern是什么类型，来执行不同的创建操作。如果是hostComponent，最终会创建它的子fiber节点 completeWork在completeWork中，会根据workInProgress fiber节点的elementType，处理不同的case。h1、div等节点是HostComponent。以HostComponent为例讲解（即原生DOM元素对应的Fiber节点） function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes, ): Fiber | null &#123; const newProps = workInProgress.pendingProps; // 对于其他很多类型的 Component是不处理的，如FunctionComponent，没有completeWork的逻辑 switch (workInProgress.tag) &#123; case IndeterminateComponent: case LazyComponent: case SimpleMemoComponent: case FunctionComponent: case ForwardRef: case Fragment: case Mode: case Profiler: case ContextConsumer: case MemoComponent: return null; case ClassComponent: &#123; // ...省略 return null; &#125; case HostRoot: &#123; // ...省略 updateHostContainer(workInProgress); return null; &#125; case HostComponent: &#123; popHostContext(workInProgress); var rootContainerInstance = getRootHostContainer(); var type = workInProgress.type; // 首屏渲染时，current是不存在的 // workInProgress.stateNode 是 该Fiber节点对应的DOM节点 判断是否存在 if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123; // update的情况 updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance); if (current.ref !== workInProgress.ref) &#123; markRef(workInProgress); &#125; &#125; else &#123; // 首屏渲染时，进入这里 mount的情况 if (!newProps) &#123; if (workInProgress.stateNode === null) &#123; throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.'); &#125; // This can happen when we abort work. bubbleProperties(workInProgress); return null; &#125; var currentHostContext = getHostContext(); // 跟SSR相关 var _wasHydrated = popHydrationState(workInProgress); if (_wasHydrated) &#123; if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) &#123; markUpdate(workInProgress); &#125; &#125; else &#123; // 为 HostCoomponent 对应的fiber节点 创建对应的DOM节点，就是在 createInstance 里创建 // 为fiber创建对应DOM节点 var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress); // 将创建好的 DOM节点， 插入到之前已经创建好的 DOM树中 appendAllChildren // // 将子孙DOM节点插入刚生成的DOM节点中 appendAllChildren(instance, workInProgress, false, false); // 将 DOM节点 挂载到 对应的fiber节点的stateNode属性上 workInProgress.stateNode = instance; // 为DOM节点设置一些属性 finalizeInitialChildren，newProps就是 该DOM的元素属性集 // 设置属性都是在 finalizeInitialChildren 方法中执行的 if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123; // 与update逻辑中的updateHostComponent类似的处理props的过程 markUpdate(workInProgress); &#125; &#125; if (workInProgress.ref !== null) &#123; // If there is a ref on a host node we need to schedule a callback markRef(workInProgress); &#125; &#125; bubbleProperties(workInProgress); return null; &#125; // ...省略 createInstance // 为对应的fiber节点 创建对应的DOM节点，就是在 createInstance 里创建 function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) &#123; var parentNamespace; &#123; // TODO: take namespace into account when validating. var hostContextDev = hostContext; validateDOMNesting(type, null, hostContextDev.ancestorInfo); if (typeof props.children === 'string' || typeof props.children === 'number') &#123; var string = '' + props.children; var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type); validateDOMNesting(null, string, ownAncestorInfo); &#125; parentNamespace = hostContextDev.namespace; &#125; // domElement 是DOM元素 var domElement = createElement(type, props, rootContainerInstance, parentNamespace); precacheFiberNode(internalInstanceHandle, domElement); updateFiberProps(domElement, props); return domElement; &#125; function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) &#123; setInitialProperties(domElement, type, props, rootContainerInstance); return shouldAutoFocusHostComponent(type, props); &#125; finalizeInitialChildren中调用的setInitialProperties方法 function setInitialProperties(domElement, tag, rawProps, rootContainerElement) &#123; // 首先判断 是否是自定义的标签 var isCustomComponentTag = isCustomComponent(tag, rawProps); &#123; validatePropertiesInDevelopment(tag, rawProps); &#125; // TODO: Make sure that we check isMounted before firing any of these events. var props; // 根据 HostComponent的 类型 进入不同的逻辑 switch (tag) &#123; case 'dialog': listenToNonDelegatedEvent('cancel', domElement); listenToNonDelegatedEvent('close', domElement); props = rawProps; break; case 'iframe': case 'object': case 'embed': // We listen to this event in case to ensure emulated bubble // listeners still fire for the load event. listenToNonDelegatedEvent('load', domElement); props = rawProps; break; case 'video': case 'audio': // We listen to these events in case to ensure emulated bubble // listeners still fire for all the media events. for (var i = 0; i &lt; mediaEventTypes.length; i++) &#123; listenToNonDelegatedEvent(mediaEventTypes[i], domElement); &#125; props = rawProps; break; case 'source': // We listen to this event in case to ensure emulated bubble // listeners still fire for the error event. listenToNonDelegatedEvent('error', domElement); props = rawProps; break; case 'img': case 'image': case 'link': // We listen to these events in case to ensure emulated bubble // listeners still fire for error and load events. listenToNonDelegatedEvent('error', domElement); listenToNonDelegatedEvent('load', domElement); props = rawProps; break; case 'details': // We listen to this event in case to ensure emulated bubble // listeners still fire for the toggle event. listenToNonDelegatedEvent('toggle', domElement); props = rawProps; break; case 'input': initWrapperState(domElement, rawProps); props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble // listeners still fire for the invalid event. listenToNonDelegatedEvent('invalid', domElement); break; case 'option': validateProps(domElement, rawProps); props = rawProps; break; case 'select': initWrapperState$1(domElement, rawProps); props = getHostProps$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble // listeners still fire for the invalid event. listenToNonDelegatedEvent('invalid', domElement); break; case 'textarea': initWrapperState$2(domElement, rawProps); props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble // listeners still fire for the invalid event. listenToNonDelegatedEvent('invalid', domElement); break; default: props = rawProps; &#125; // 判断props 是否合法 assertValidProps(tag, props); // 初始化DOM属性操作 setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag); switch (tag) &#123; case 'input': // TODO: Make sure we check if this is still unmounted or do any clean // up necessary since we never stop tracking anymore. track(domElement); postMountWrapper(domElement, rawProps, false); break; case 'textarea': // TODO: Make sure we check if this is still unmounted or do any clean // up necessary since we never stop tracking anymore. track(domElement); postMountWrapper$3(domElement); break; case 'option': postMountWrapper$1(domElement, rawProps); break; case 'select': postMountWrapper$2(domElement, rawProps); break; default: if (typeof props.onClick === 'function') &#123; // TODO: This cast may not be sound for SVG, MathML or custom elements. trapClickOnNonInteractiveElement(domElement); &#125; break; &#125; &#125; // Calculate the diff between the two objects. // 初始化DOM属性操作 setInitialDOMProperties源码 function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) &#123; // 遍历 props上的属性 for (var propKey in nextProps) &#123; if (!nextProps.hasOwnProperty(propKey)) &#123; continue; &#125; var nextProp = nextProps[propKey]; // 是否是 style属性 if (propKey === STYLE) &#123; &#123; if (nextProp) &#123; // 冻结对象 Object.freeze(nextProp); &#125; &#125; // Relies on `updateStylesByID` not mutating `styleUpdates`. setValueForStyles(domElement, nextProp); &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML) &#123; var nextHtml = nextProp ? nextProp[HTML$1] : undefined; if (nextHtml != null) &#123; setInnerHTML(domElement, nextHtml); &#125; &#125; else if (propKey === CHILDREN) &#123; // 是否是 children属性 if (typeof nextProp === 'string') &#123; // Avoid setting initial textContent when the text is empty. In IE11 setting // textContent on a &lt;textarea> will cause the placeholder to not // show within the &lt;textarea> until it has been focused and blurred again. // https://github.com/facebook/react/issues/6731#issuecomment-254874553 var canSetTextContent = tag !== 'textarea' || nextProp !== ''; if (canSetTextContent) &#123; setTextContent(domElement, nextProp); &#125; &#125; else if (typeof nextProp === 'number') &#123; setTextContent(domElement, '' + nextProp); &#125; &#125; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING); else if (propKey === AUTOFOCUS); else if (registrationNameDependencies.hasOwnProperty(propKey)) &#123; if (nextProp != null) &#123; if (typeof nextProp !== 'function') &#123; warnForInvalidEventListener(propKey, nextProp); &#125; if (propKey === 'onScroll') &#123; listenToNonDelegatedEvent('scroll', domElement); &#125; &#125; &#125; else if (nextProp != null) &#123; // 最终进入这里：该函数 内部，使用setAttribute 为DOM设置属性， completeWork执行完成 setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag); &#125; &#125; &#125; appendAllChildren的逻辑 var appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) &#123; // We only have the top Fiber that was created but we need recurse down its // children to find all the terminal nodes. var node = workInProgress.child; while (node !== null) &#123; if (node.tag === HostComponent || node.tag === HostText) &#123; appendInitialChild(parent, node.stateNode); &#125; else if (node.tag === HostPortal); else if (node.child !== null) &#123; node.child.return = node; node = node.child; continue; &#125; if (node === workInProgress) &#123; return; &#125; while (node.sibling === null) &#123; if (node.return === null || node.return === workInProgress) &#123; return; &#125; node = node.return; &#125; node.sibling.return = node.return; node = node.sibling; &#125; &#125;; createWorkInProgress：创建新的fiber节点 或者 基于current指向的 rootFiber 创建 WorkInProgress Fiber 树（复用） function createWorkInProgress(current, pendingProps) &#123; var workInProgress = current.alternate; // workInProgress不存在情况，首屏渲染 if (workInProgress === null) &#123; // 创建新的 Fiber节点 workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode); // 基于current 为 workInProgress 设置同名参数 workInProgress.elementType = current.elementType; workInProgress.type = current.type; workInProgress.stateNode = current.stateNode; &#123; // DEV-only fields workInProgress._debugSource = current._debugSource; workInProgress._debugOwner = current._debugOwner; workInProgress._debugHookTypes = current._debugHookTypes; &#125; workInProgress.alternate = current; current.alternate = workInProgress; &#125; else &#123; // workInProgress已存在 workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type. workInProgress.type = current.type; // We already have an alternate. // Reset the effect tag. workInProgress.flags = NoFlags; // The effects are no longer valid. workInProgress.subtreeFlags = NoFlags; workInProgress.deletions = null; &#123; // We intentionally reset, rather than copy, actualDuration &amp; actualStartTime. // This prevents time from endlessly accumulating in new commits. // This has the downside of resetting values for different priority renders, // But works for yielding (the common case) and should support resuming. workInProgress.actualDuration = 0; workInProgress.actualStartTime = -1; &#125; &#125; // Reset all effects except static ones. // Static effects are not specific to a render. // 复用 同名参数 workInProgress.flags = current.flags &amp; StaticMask; workInProgress.childLanes = current.childLanes; workInProgress.lanes = current.lanes; workInProgress.child = current.child; workInProgress.memoizedProps = current.memoizedProps; workInProgress.memoizedState = current.memoizedState; workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so // it cannot be shared with the current fiber. var currentDependencies = current.dependencies; workInProgress.dependencies = currentDependencies === null ? null : &#123; lanes: currentDependencies.lanes, firstContext: currentDependencies.firstContext &#125;; // These will be overridden during the parent's reconciliation workInProgress.sibling = current.sibling; workInProgress.index = current.index; workInProgress.ref = current.ref; &#123; workInProgress.selfBaseDuration = current.selfBaseDuration; workInProgress.treeBaseDuration = current.treeBaseDuration; &#125; &#123; workInProgress._debugNeedsRemount = current._debugNeedsRemount; switch (workInProgress.tag) &#123; case IndeterminateComponent: case FunctionComponent: case SimpleMemoComponent: workInProgress.type = resolveFunctionForHotReloading(current.type); break; case ClassComponent: workInProgress.type = resolveClassForHotReloading(current.type); break; case ForwardRef: workInProgress.type = resolveForwardRefForHotReloading(current.type); break; &#125; &#125; return workInProgress; &#125; // Used to reuse a Fiber for a second pass. root: 指向FiberRootFiber root.current: 指向是rootFiber updateupdate 归阶段 流程：completeWork。当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如： onClick、onChange等回调函数的注册 处理style prop 处理DANGEROUSLY_SET_INNER_HTML prop 处理children prop我们去掉一些当前不需要关注的功能（比如ref）。可以看到最主要的逻辑是调用updateHostComponent方法。// completeWork 的 updateHostComponent 和 beginWork中的不一样 if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123; // update的情况 updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance, ); &#125; 在updateHostComponent内部，被处理完的props会被赋值给workInProgress.updateQueue，并最终会在commit阶段被渲染在页面上。其中updatePayload为数组形式，他的偶数索引的值为变化的prop key，奇数索引的值为变化的prop value。workInProgress.updateQueue = (updatePayload: any); // props中的 childern 和 title属性 // updateQueue: ['childern', 5, 'title', 5] update流程结尾render阶段全部工作完成。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。 commitRoot(root); // 开启commit阶段 effectList（使用链表）至此render阶段的绝大部分工作就完成了。 还有一个问题：作为DOM操作的依据，commit阶段需要找到所有有flags的Fiber节点并依次执行flags对应操作。难道需要在commit阶段再遍历一次Fiber树寻找flags !&#x3D;&#x3D; null的Fiber节点么？ 这显然是很低效的。 为了解决这个问题，在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在flags的Fiber节点会被保存在一条被称为effectList的单向链表中。（是用链表来 连接 标记有flags的fiber节点， commit阶段直接使用链表） effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。 类似appendAllChildren，在“归”阶段，所有有flags的Fiber节点都会被追加在effectList中，最终形成一条以rootFiber.firstEffect为起点的单向链表。 nextEffect nextEffect rootFiber.firstEffect -----------> fiber -----------> fiber // 这样，在commit阶段只需要遍历effectList就能执行所有effect了。 completeWork流程图","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【React源码】React的设计理念","slug":"front_end/react-idea","date":"2022-05-14T08:15:20.000Z","updated":"2022-10-13T16:38:53.261Z","comments":true,"path":"2022/05/14/front_end/react-idea/","link":"","permalink":"http://example.com/2022/05/14/front_end/react-idea/","excerpt":"","text":"React简介 React 是用 JavaScript 构建快速响应的大型 Web 应用程序的前端框架，其设计理念就是快速响应。 React 吸收了函数式编程中代数效应的思想。从数据结构来讲，React 大量使用了链表，在调度阶段使用了小顶堆，并且使用了许多的闭包。 什么因素制约了 React 快速响应？什么因素导致应用不流畅呢？可能是因为进行了大量的计算，或者是因为当前网络状况不佳，正在等待请求的返回才能进一步操作导致不能快速响应等，可以说是计算能力和网络延迟的原因，制约了React快速响应，最终可归结为CPU的瓶颈和IO的瓶颈。 Reeact 为了践行快速响应的设计理念，是如何解决CPU和IO的瓶颈？ 主流的浏览器刷新频率为60Hz，也就是说每16.6ms（1000ms/60Hz=16.6ms）浏览器刷新一次。在这16.6ms过程中，会依次执行JS脚本、样式布局、样式绘制。如果JS脚本的执行时间超过了16.6ms，那么这一帧就没有时间留给样式布局、样式绘制。浏览器就会掉帧，表现形式就是浏览器的滚动不流畅、在输入框输入的字符不能及时的响应在页面上。对于这种情况，一般采用防抖（一段输入只会触发一次更新）和节流（限制触发更新的频率）来优化，本质上来说，这两个都是限制我们触发更新的频率，来减少掉帧的可能性，但是这是治标不治本的办法。随着我们输入的字符越来越多，我们每一次更新所需要的时间，都超过了浏览器一帧的时间时，那么使用防抖和节流也会造成浏览器的掉帧，那么有没有解决的办法呢？React给出的办法是将同步的更新改为异步更新。 简单来说，React 和浏览器做了一个约定，将自己一帧的时间预留给 React，React 利用这一部分时间来完成自己的工作，如果某个工作需要的时间特别长，超出了这个预留时间，React 会中断自己的工作，并将控制权交给浏览器，等到下一帧，浏览器给到自己预留的那部分时间到来之后，再继续之前被中断的工作，这样浏览器在每一帧都会有时间执行样式布局与样式绘制，这样就有可能减少掉帧的可能性。 所以，当采用了异步更新的形式，即使是更新了大量的节点，这样 CPU 密集型操作，React 也能有效的减少掉帧的可能性。 React是如何解决IO的瓶颈呢？ 比如需要等待数据请求的结果返回，才能做出进一步的响应的场景下，用户才能感知到快速响应呢？将人机交互的研究结果整合到真实的UI中，研究表明，在屏幕之间切换时显示过多的中间加载状态会使切换的速度变慢。对于UI交互来说，延迟显示中间加载的状态能让用户感觉更流畅。 React为了解决IO的瓶颈，以实现快速响应的理念，React更逐步在框架的层面实现异步可中断的更新机制，不管是CPU的瓶颈，还是IO的瓶颈，最重要的是实现一套异步的更新机制。 React设计理念的总结React设计理念是快速响应，制约快速响应的因素是CPU瓶颈与IO瓶颈，解决办法是实现异步可中断更新。 React架构React 从 v15 升级到 v16 后重构了整个架构。 React15 老架构React15架构分为两部分，分别是决定渲染什么组件（Reconciler 协调器）、将组件渲染到视图中（Renderer 渲染器）。对应于 Reconciler 协调器和 Renderer 渲染器，老的架构无法实现中断更新，需要新的 React16 架构，才能实现异步可中断更新。 Reconciler（协调器） 在 React 中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。 每当有更新发生时，Reconciler会做如下工作： 直接调用函数组件或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM 将虚拟 DOM 和上次更新时的虚拟 DOM 对比 通过对比找出本次更新中变化的虚拟 DOM 通知 Renderer（渲染器）将变化的虚拟 DOM 渲染到页面上 协调器负责决定本次更新有什么组件需要渲染，diff 算法就是发生在协调器中。在 diff 算法中，会将上一次更新的虚拟 DOM 与本次更新的 DOM 做一个对比，最终只有变化的部分会被渲染到视图中，diff 算法的官方名称是 reconcile，就是协调的意思，这也是协调器的由来。经过 diff 算法判定为本次需要更新的 虚拟DOM，会交给渲染器，渲染到视图中，不同的渲染器会将组件渲染到不同的宿主环境视图中。 Render（渲染器）在每次更新发生时，Renderer（渲染器）接到 Reconciler（协调器）通知，将变化的组件渲染在当前宿主环境。 ReactDOM 渲染器，渲染到浏览器； ReactNative 渲染器，渲染App原生组件； ReactTest 渲染器，渲染出纯JS对象用于测试； ReactArt 渲染器，渲染出Canvas、SVG。 React15架构的缺点采用递归执行更新，更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了浏览器间隔刷新一帧的时间（16.6ms），页面的交互就会出现卡顿。 React16 新架构（新的React架构） 由于更新是异步可中断的，在新的架构中，新增了一个模块来管理这些异步更新，每一个更新会被赋予一个优先级，高优先级的更新会被更快的调度。这个模块的被称为Scheduler（调度器）。 React16新的架构： Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler Reconciler（协调器）—— 负责找出变化的组件 Renderer（渲染器）—— 负责将变化的组件渲染到页面上 Scheduler（调度器）Scheduler（调度器）工作原理对于老的架构，更新会直接被 Reconciler（协调器）处理。在新的架构中，更新首先会被 Scheduler（调度器）处理，调度器会调度这些更新的优先级，更高优先级的更新会优先进入 Reconciler（协调器），在协调器正在执行 diff 算法时，如果此时产生了一个更高优先级的更新，那么正在协调器的协调的更新会被中断，由于调度器与协调器都是在内存中工作，不会执行具体的视图操作。即使有中断发生，用户也不会看到更新不完全的视图。当某次更新中，完成了在协调器的工作时，协调器会通知渲染器，本次更新有哪些组件，需要执行对应的视图操作，由渲染器来分别执行这些视图操作。对应我们常见的ReactDOM来说，这些视图操作包含了 DOM 节点的增删改查操作。当高优先级的更新最终完成了渲染，协调器又会调度新一轮的调度。 diff 算法的目的是创建一颗虚拟 DOM 树，每一个视图上存在的节点，都有一个虚拟 DOM 节点与其对应，被更新的节点会被打上Update标记（flags），最终协调器会将打了标记的虚拟 DOM 交给渲染器。 渲染器接收到通知后，会查看有哪些被打记号的虚拟DOM，被标记为Update的虚拟 DOM 节点对应的真实DOM会被渲染器执行更新DOM的操作。通过调度器、协调器、渲染器互相配合，React新的架构实现了异步可中断的更新。 Reconciler（协调器）当我们开启了Concurrent模式后（React18），更新工作中会调用workLoopConcurrent方法，从递归变成了可以中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。 function workLoopConcurrent() &#123; // workInProgress是当前fiber节点 while (workInProgress !== null &amp;&amp; !shouldYield()) &#123; workInProgress = performUnitOfWork(workInProgress); &#125; &#125; React 协调器（Reconciler）的新架构FiberReact 践行代数效应，那代数效应与Fiber架构有什么联系吗？代数效应是函数式编程中的概念，用于将副作用从函数调用中分离，使得函数的关注点保持纯粹。 为了演示代数效应，虚构的语法 perform、handle、resume。执行 getTotalPicNum 函数，perform 语法会被 try handle 捕获，在 handle 处理 case。 resume with num会回到 getPicNum 函数调用栈，再中断执行完任务，回到之前的getTotalPicNum调用栈后，会继续执行接下来return num1 + num2的工作。 参考代数效应// 异步可中断更新原理 function getTotalPicNum(user1, user2) &#123; const num1 = getPicNum(user1); const num2 = getPicNum(user2); return num1 + num2; &#125; function getPicNum(name)&#123; const picNum = perform name; return picNum; &#125; function run()&#123; try &#123; getTotalPicNum('SouthStar', 'Nanxing'); &#125; handle (who) &#123; switch (who) &#123; case 'SouthStar': resume with 123; case 'Nanxing': resume with 12; default: resume with 0; &#125; &#125; &#125; run() 代数效应与React关系：Hooks。比如useState的值如何保存在函数组件，我们不太需要关注，这个由 React 处理。还有就是请求数据的写法如果是同步的，至于如何异步的请求数据，中间的加载状态是如何展示的，这完全是交由 React 来处理。 Fiber 就是利用了代数效应的中断、恢复，来完成了异步可中断的更新。 Fiber 的中文名是纤程，与进程(Process)、线程(Thread)、协程(Coroutine)同为操作系统的程序的执行过程，纤程可以理解为协程的一种实现，在JS中协程已经有了一种实现，就是 generator。 React团队为什么不直接使用generator来实现异步的更新，而是自己去实现一套 Fiber 纤程呢？ generator和async&#x2F;await一样，具有传染性，当一个函数成为generator函数后，这个函数调用链上的其他函数也会受到影响。 设计Fiber架构的目的是：更新可以中断并继续，更新可以拥有不同的优先级，高优先级的更新可以打断低优先级的更新 使用generator可以达到更新可以中断并继续的目的，但是不能实现不同的优先级的更新，所有React团队决定重头实现一套Fiber架构。 Fiber架构Fiber的含义Fiber和JSX都可以理解为一种数据结构，在React16新架构中，Fiber节点就是虚拟DOM。Fiber包含三层含义： 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler，stack就是调用栈。React16的协调器Reconciler是基于Fiber节点实现，被称为Fiber Reconciler。 作为静态的数据结构来说，每个Fiber节点对应一个React element（React组件），保存了该组件的类型（函数组件&#x2F;类组件&#x2F;原生组件…）、对应的DOM节点等信息，这是的Fiber节点也就是我们所说的虚拟DOM。举个例子，有一个 App 组件，当首次调用ReactDOM.render时，会创建整个应用的根节点FiberRootNode，我们是可以多次调用ReactDOM.render，将不同的应用挂载到不同的应用节点下，每个应用都有自己的根RootFiber节点。在一个页面中，可以有多个RootFiber，但是只能有一个FiberRootNode来管理这些RootFiber。 Fiber的结构function FiberNode( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode, ) &#123; // 作为静态数据结构的属性 this.tag = tag; // 组件的类型，如function组件、class组件、DOM对应的Fiber节点（原生） this.key = key; // 我们常用的key属性 // 大部分情况elementType与type是一致的。在某些情况下，FunctionComponent被React.memo包裹时，它的elementType与type不同。 this.elementType = null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName this.type = null; // Fiber对应的真实DOM节点，对于HostComponent，指真实的DOM节点， this.stateNode = null; // 用于连接其他Fiber节点形成Fiber树 this.return = null; this.child = null; this.sibling = null; // 对于多个同级Fiber节点，代表它们插入DOM的位置索引 this.index = 0; this.ref = null; // 常用的ref属性 // 作为动态的工作单元的属性，保存本次更新造成的状态改变相关信息 this.pendingProps = pendingProps; this.memoizedProps = null; // 存放属性的 增删改 // 存在updateQueue时，会调用markUpdate，为workInProgress的flags 标记为Update this.updateQueue = null; this.memoizedState = null; this.dependencies = null; this.mode = mode; // HostComponent的副作用是增删查改，对应FunctionComponent使用了useEffect、useLayoutEffect this.flags = NoEffect; // 带有effect与副作用相关，标记flag的 fiber节点与fiber节点之间的 通过链表连接 this.nextEffect = null; this.firstEffect = null; this.lastEffect = null; // lanes属性与调度优先级相关 this.lanes = NoLanes; this.childLanes = NoLanes; // 指向该fiber在另一次更新时对应的fiber this.alternate = null; &#125; Fiber节点的连接 每个Fiber节点有个对应的React element，多个Fiber节点是如何连接形成树呢？靠如下三个属性： // 指向父级Fiber节点 this.return = null; // 指向第一个子Fiber节点 this.child = null; // 指向右边第一个兄弟Fiber节点 this.sibling = null; 组件结构如下： function App() &#123; return ( &lt;div> title &lt;span>标题&lt;/span> &lt;/div> ) &#125; 对应的Fiber树结构： 为什么父级指针叫做return而不是parent或者father呢？这是因为React15的stack Reconciler以递归的形式工作，当从根节点执行递归操作时，首先会从根节点递归向下到子节点，再从子节点一路向上归到根节点，所以在这个递归阶段，函数处理完子节点后，会返回它的父节点。在Fiber Reconciler使用遍历的形式使用可中断的递归，也复用了这种思想。这就是为什么采用return指向父节点。 RootFiber采用stateNode指向FiberRootNode 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作、要执行的副作用（需要被删除&#x2F;被插入页面中&#x2F;被更新…）。 Fiber架构的工作原理React如何更新页面？当首次调用ReactDOM.render时，会创建整个应用的根节点FiberRootNode（源码中叫fiberRoot），每次调用ReactDOM.render，都会常见当前应用的根节点rootFiber，其中FiberRootNode.current指向rootFiber（fiberRootNode.current &#x3D; rootFiber;），由于在首次渲染页面之前，页面是空白的，所以rootFiber没有子节点（页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点，即current Fiber树为空）。接下来进入首屏渲染的逻辑，不管是首屏渲染还是调用this.setState，或者是useState的setXXX方法创建的更新，都会从根节点rootFiber创建一颗fiber树，首先创建根节点的rootFiber节点，这两棵树中都存在着rootFiber节点，会用alternate属性连接，方便两个fiber直接共用一些属性，接下来采用深度优先遍历模拟递归的方式创建整颗fiber树. 现在我们拥有两颗Fiber树，左边代表页面内容的fiber树，称为current Fiber树。右侧由于触发了更新，在内存中构建的fiber树，称为workInProgress Fiber树，它是根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树。 当workInProgress Fiber树完成了渲染（即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后），此时FiberRootNode.current指向了workInProgress Fiber树的根节点rootFiber，于是workInProgress Fiber树的根节点rootFiber就变成了current Fiber树，FiberRootNode.current指向更新后的rootFiber。 接下来，我们点击p标签，触发一次更新，每次触发更新都会重新创建一颗workInProgress Fiber树。 可以将 current Fiber树的节点称为 current节点，此时 current 的 rootFiber的alternate属性已经指向了一个 rootFiber，所以在创建 workInProgress Fiber树 时会基于这个 rootFiber来创建。在本次更新中，除了rootFiber，APP 与 p 都有对应的current Fiber 存在（alternate指向该fiber在另一次更新时对应的fiber），这种将current Fiber 与本次更新返回的 JSX结构做对比，生成 workInProgress Fiber的过程，就是diff算法。所有首屏渲染与更新最大的区别在于：在创建Fiber树的过程中 是否有diff算法。 current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。 currentFiber.alternate === workInProgressFiber; workInProgressFiber.alternate === currentFiber; 当workInProgress Fiber树最终完成了渲染，FiberRootNode.current指向了workInProgress Fiber树的根节点，此时它就变成了current Fiber树。 React首屏渲染具体执行流程 调度阶段当首次调用ReactDOM.render时，会创建整个应用的根节点FiberRootNode，FiberRootNode方法就是创建整个FiberRootNode createHostRootFiber createFiber，它的参数tag为3由 createHostRootFiber中调用createFiber传入 协调阶段 scheduleUpdateOnFiber，调度这次更新，当调度成功后，我们会执行这次更新performSyncWorkOnRoot，也就是说从根节点开始这次更新 创建 workInProgress Fiber树 可以类比为递归的流程，beginWork为递过程，completeWork为归过程。 renderRootSync就是协调器的执行（render阶段），与它同级的commitRoot代表了这次渲染器的工作入口（commit阶段） 渲染器的工作入流程：将变化的节点渲染到视图上，before mutation阶段（渲染前），mutation阶段（渲染中），layout阶段（渲染后） JSXJSX用来描述React组件的内容，JSX的本质：JavsScript的语法扩展。 JSX和Fiber节点是同一个东西么，它们的关系？ React Component、React Element是同一个东西么，他们和JSX有什么关系？ babelJSX语法是如何在JavaScript（或者浏览器）中生效的？JSX会被编译为 React.createElement()，React.createElement()将返回一个叫作“React Element”的JS对象。 @babel&#x2F;plugin-transform-react-jsx 将jsx 进行编译 // &lt;div>1&lt;/div> 编译后 React.createElement(\"div\", null, \"1\"); React.createElement既然JSX会被编译为React.createElement，让我们看看他做了什么： // type节点类型，config组件的属性 export function createElement(type, config, children) &#123; // 用于存储后面需要用到的元素属性 let propName; // 用于存储元素属性的键值对集合 const props = &#123;&#125;; // 定义一些字段，key、ref是我们经常使用的 let key = null; // 作为保留属性传递 let ref = null; // 作为保留属性传递 let self = null; // __self作为保留属性传递 let source = null; // __source作为保留属性传递 if (config != null) &#123; // 将 config 处理后赋值给 props // ...省略 &#125; const childrenLength = arguments.length - 2; // 处理 children，会被赋值给props.children // ...省略 // ...省略 // 处理 defaultProps Resolve default props // defaultProps来自于React.createElement第一次参数type if (type &amp;&amp; type.defaultProps) &#123; const defaultProps = type.defaultProps; for (propName in defaultProps) &#123; if (props[propName] === undefined) &#123; props[propName] = defaultProps[propName]; &#125; &#125; &#125; return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, ); &#125; const ReactElement = function(type, key, ref, self, source, owner, props) &#123; const element = &#123; // 标记这是个 React Element $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, _owner: owner, &#125;; return element; &#125;; React.createElement最终会调用ReactElement方法返回一个包含组件数据的对象，该对象有个参数$$typeof: REACT_ELEMENT_TYPE标记了该对象是个React Element。 所以调用React.createElement返回的对象就是React Element么？ React提供了验证合法React Element的全局API React.isValidElement (opens new window)，我们看下他的实现： export function isValidElement(object) &#123; return ( typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE ); &#125; 可以看到，$$typeof === REACT_ELEMENT_TYPE的非null对象就是一个合法的React Element。换言之，在React中，所有JSX在运行时的返回结果（即React.createElement()的返回值&#x2F;调用结果）都是React Element。 JSX与 Fiber的关系：创建Fiber节点的依据就是 组件返回的JSX对象，JSX是一种描述当前组件内容的数据结构。在更新时，依据存在了一颗current Fiber树，所以在生成 workInProgress Fiber树 时，将组件返回的JSX对象，与这个组件对应的 current Fiber节点做对比，根据对比的结果生成workInProgress Fiber树。这就是JSX与 Fiber的关系，JSX最终会被编译为 React.createElement方法的执行。理论上来说，只要改变React.createElement的方法，就能改变页面最终的渲染结果。 REACT_DEVTOOLS_GLOBAL_HOOK__REACT_DEVTOOLS_GLOBAL_HOOK__对象含有一个renderers，渲染器，急速React-DOM。 参考 React理念 React15架构 React16架构 Fiber架构的实现原理 Fiber架构的工作原理","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"React+Mobx6.0","slug":"front_end/react-mobx6","date":"2022-04-16T18:05:10.000Z","updated":"2022-07-07T16:32:29.036Z","comments":true,"path":"2022/04/17/front_end/react-mobx6/","link":"","permalink":"http://example.com/2022/04/17/front_end/react-mobx6/","excerpt":"","text":"mobx入门 在 Mobx6 中不推荐使用装饰器语法，因为它不是 ES 标准 mobx：mobx 核心库 mobx-react-lite：仅支持函数组件 mobx-react：既支持函数组件也支持类组件 下载 npm install mobx@6.5.0 mobx-react-lite@3.3.0 mobx核心概念 observable state：被 Mobx 跟踪的状态。 action：允许修改状态的方法，在严格模式下只有 action 方法被允许修改状态。 computed：根据应用程序状态派生的新值，计算值。 mobx 每次都是修改的同一个状态对象，基于响应式代理，也就是 Object.defineProperty 代理 get、set 的处理，get 时把依赖收集起来，set 修改时通知所有的依赖做更新。 mobx基础实践 Mobx官方文档 React+Mobx6从入门到实践 查看mobx的proxy对象的数据import &#123; toJS &#125; from \"mobx\"; console.log(toJS(user.name)); 持久化存储mobx-persist-store解决页面刷新的时候数据会丢失的情况 mobx-persist-store文档 makePersistable实践import &#123; makeAutoObservable, action, toJS &#125; from \"mobx\"; import &#123; makePersistable, isHydrated &#125; from \"mobx-persist-store\"; // 引入相关api // import localForage from \"localforage\"; // localforage前端数据存储 class User &#123; token: string; constructor() &#123; // 自动将已经存在的对象属性并且使得它们可观察，makeAutoObservable 不能被用于带有super的类或子类。 makeAutoObservable(this, &#123;&#125;, &#123; autoBind: true &#125;); // 数据持久化存储，在构造函数内使用 makePersistable makePersistable(this, &#123; // 保存的name，用于在storage中的名称标识，只要不和storage中其他名称重复就可以 name: \"userInfo\", // 注意：不写在这里面的字段将不会被保存，刷新页面也将丢失：get字段例外。get数据会在数据返回后再自动计算 properties: [\"token\"], // 保存的位置：看自己的业务情况选择，可以是localStorage，sessionstorage // localForage, window.localStorage storage: window.localStorage, // 还有一些其他配置参数，例如数据过期时间 expireIn: 86400000, // 以毫秒为单位，一天过期 removeOnExpiration: true, // 到期删除 stringify: false, // 是否转化成json字符串 &#125;).then(action((persistStore) => &#123; // persist完成的回调，在这里可以执行一些拿到数据后需要执行的操作，如果在页面上要判断是否成persist，使用isHydrated console.log(persistStore.isHydrated); &#125;)) &#125; // 注意这个字段的使用：在页面useEffect的时候，如果你没有添加依赖数组（初始化执行） // 那么你可能拿不到computed计算的数据（原因是这时候还没有persist结束）所以这个属性还是比较重要的 // 因为它可以在页面上做判断，当页面load完成，get数据计算完成之后，isHydrated会置为true get isHydrated() &#123; return isHydrated(this); &#125; /** * computed */ get token() &#123; return this.token; &#125; /** * action */ setToken(val) &#123; this.token = val || \"\"; &#125; &#125; export default new User(); 使用持久数据 useEffect(() => &#123; if (user.isHydrated) &#123; // ... 这个时候就可以拿到user里缓存的值 &#125; return () => &#123; // ... &#125; // eslint-disable-next-line &#125;, [user.isHydrated]) Redux和Mobx的区别 Mobx是学习成本低，比较简单，自由度更高（可直接修改状态）；Redux写起来有点繁琐，创建store，编写reducer，触发action等等。 Mobx比较推荐面向对象编程的写法；Redux则是推荐函数式编程，如reducer就是一个纯函数。 Mobx中的数据可读可写，并且不一定需要 action 修改状态，可直接修改状态；Redux是单一数据源，State 是只读的。 参考：Redux和Mobx的区别","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"如何搭建一个通用的基础组件库","slug":"engineering/component-library","date":"2022-03-29T20:39:18.000Z","updated":"2022-07-10T09:18:13.112Z","comments":true,"path":"2022/03/30/engineering/component-library/","link":"","permalink":"http://example.com/2022/03/30/engineering/component-library/","excerpt":"","text":"前言作为一名前端程序员，一直以来，我都只是停留在会使用各种优秀的组件库，包括开源和公司内部自研的，从来没有了解过这些组件库是如何开发的。直到现在，自己参考了多个开源组件库，由浅入深，尝试去实现一个简单的组件库，学习和探索组件库设计以及开发思路。 技术选择经过查阅资料，觉得dumi非常的合适。dumi是专门为组件开发场景而生的文档工具，开箱即用，支持TypeScript 和 Markdown，可以将更多的精力集中在组件开发上，核心技术栈为：React + TypeScript + less + dumi 环境准备安装初始化项目$ mkdir project-name &amp;&amp; cd project-name # 创建空目录 组件开发脚手架$ npx @umijs/create-dumi-lib --site # 初始化一个站点模式的组件库开发脚手架 # or $ yarn create @umijs/dumi-lib --site 目录结构说明 运行 执行 npm install，安装依赖。 执行 npm run start 或 npx dumi dev ，开始调试组件或编写文档，预览效果如下图： 组件的开发全局样式搭建新建src/style文件夹，放在全局的样式文件。其中theme文件下放通用的基础样式，global.less中引用style/inde.less的样式，dumi默认引入全局样式global.less。 定义基础样式 基础色彩样式，primary、default、success、warning、danger、info； 字体样式，默认font-family、默认font-size(1rem)、默认font-weight(400)、字体颜色、h1-h6(h6 默认是 1rem)； 超链接样式(默认primary，无下划线)； line-height(行高默认是字体的1.5倍大小)； body(字体大小是1rem、背景白色、字体淡黑色)； border边框(宽度1px、颜色@gray-300、radius是0.25rem)； 盒子阴影(@box-shadow: 0 0.5rem 1rem rgba(@black, 0.15))； 约定单个组件的文件结构以button组件为例，其中src/button/style/index.less为单个组件的内部样式文件，需要在src/style/index.less中引入，目录结构如下： 组件的开发步骤组件正确的开发流程：组件属性的分析 -&gt; 组件的开发 -&gt; (上生产环境需要组件测试) -&gt; 组件的使用说明文档 组件的分析：去定义一些接口或者类型别名，接口是用来描述props，声明组件的时候通过泛型传入； 组件的开发：不同的组件有不同的实现方式，相似的组件可以复用，编写组件基础样式； 组件的使用说明：描述一些需要通过props传入组件的属性，方便定制不同场景； Button按钮类型声明类型声明在src/button/interface.ts文件中写入，设置不同按钮的大小、按钮的主题类型、按钮的原生类型等 // 按钮大小 export type ButtonSize = 'lg' | 'md' | 'sm'; // 按钮的主题类型 export type ButtonType = 'primary' | 'default' | 'danger' | 'link' | 'info' | 'dashed' | 'warning'; // 按钮的原生类型 export type ButtonHTMLTypes = 'submit' | 'button' | 'reset'; export interface BaseButtonProps &#123; className?: string; /** 按钮禁用 */ disabled?: boolean; /** 按钮大小 */ size?: ButtonSize; /** 按钮类型 */ type?: ButtonType; /** 按钮children */ children: React.ReactNode; /** type为link时的url */ href?: string; &#125; // button 和 a链接 的原生属性太多了，可以直接把全部属性加上 // 从哪里可以找到button所有的props？react已经提供好的 // 合并交叉类型 type NativeButtonProps = &#123; htmlType?: ButtonHTMLTypes; target?: string; onClick?: React.MouseEventHandler&lt;HTMLElement>; &#125; &amp; BaseButtonProps &amp; Omit&lt;React.ButtonHTMLAttributes&lt;HTMLElement>, 'type'>; // ButtonHTMLAttributes&lt;HTMLElement> 所有button属性 type AnchorButtonProps = &#123; href?: string; onClick?: React.MouseEventHandler&lt;HTMLElement>; &#125; &amp; BaseButtonProps &amp; Omit&lt;React.AnchorHTMLAttributes&lt;HTMLElement>, 'type'>; // AnchorHTMLAttributes&lt;HTMLElement> 所有a标签属性 // Partial&lt;T> 将类型的属性变成可选，只支持处理第一层的属性 export type ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps>; Button按钮实现在src/button/index.tsx写入核心代码，需要考虑padding的大小、lineHeight高度、color颜色、textAlien文字居中、box-shadow盒子阴影，disabled时的特殊样式，鼠标的cursor的变化。 使用button标签和a标签实现； Button Size的大小其实就是padding控制，font-size不同、border的不同； Button Type是变化background-color、border-color、字体颜色color； 添加不同的状态：hover之后要颜色发生一定的变化，focus颜色变化，disabled颜色也发生变化(cursor: not-allowed和opacity: .65)。import React from 'react'; import classNames from 'classnames'; import &#123; ButtonProps &#125; from './interface'; const Button: React.FC&lt;ButtonProps> = (props) => &#123; // className用户自定义的 const &#123; type, className, disabled, size, children, href, ...restProps &#125; = props; // yolo-btn yolo-btn-lg yolo-btn-primary // 因为我们的key是变化的，所有用[`$&#123; &#125;`] const classes = classNames('yolo-btn', className, &#123; [`yolo-btn-$&#123;type&#125;`]: type, [`yolo-btn-$&#123;size&#125;`]: size, disabled: type === 'link' &amp;&amp; disabled, &#125;); if (type === 'link' &amp;&amp; href) &#123; return ( &lt;a className=&#123;classes&#125; href=&#123;href&#125; &#123;...restProps&#125;> &#123;children&#125; &lt;/a> ); &#125; else &#123; return ( &lt;button className=&#123;classes&#125; disabled=&#123;disabled&#125; &#123;...restProps&#125;> &#123;children&#125; &lt;/button> ); &#125; &#125;; Button.defaultProps = &#123; disabled: false, type: 'default', &#125;; export default Button; Button使用说明src/button/index.md 按钮的类型按钮分为七种类型 type，默认是 default。 default | primary | info | warning | danger | dashed | link import React from 'react'; import &#123; Button &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;div id=\"button-demo-display-type\"> &lt;Button type=\"default\">default&lt;/Button> &lt;Button type=\"primary\">primary&lt;/Button> &lt;Button type=\"info\">info&lt;/Button> &lt;Button type=\"warning\">warning&lt;/Button> &lt;Button type=\"danger\">danger&lt;/Button> &lt;Button type=\"dashed\">dashed&lt;/Button> &lt;Button type=\"link\" href=\"https://github.com/izph\"> link &lt;/Button> &lt;/div> ); &#125;; 按钮尺寸尺寸 size分为 lg | md | sm，即大、中、小，默认的尺寸是中。 import React from 'react'; import &#123; Button &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;div id=\"button-demo-display-size\"> &lt;Button size=\"lg\" type=\"primary\"> Large &lt;/Button> &lt;Button size=\"md\" type=\"danger\"> Medium &lt;/Button> &lt;Button size=\"sm\" type=\"warning\"> Small &lt;/Button> &lt;/div> ); &#125;; 按钮的禁用状态添加 disabled属性即可让按钮处于禁用状态，同时按钮样式也会改变。 import React from 'react'; import &#123; Button &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;div id=\"button-demo-display-size\"> &lt;Button type=\"primary\" disabled> primary &lt;/Button> &lt;Button type=\"danger\" disabled> danger &lt;/Button> &lt;Button disabled>default&lt;/Button> &lt;Button type=\"link\" disabled> link &lt;/Button> &lt;/div> ); &#125;; API通过设置 Button的属性来产生不同的按钮样式，按钮的属性说明如下： 属性 说明 类型 默认值 type 设置按钮类型 default、primary、info、 warning、danger、dashed、link default size 设置按钮大小 lg、md、sm，非必填 md disabled 按钮禁用状态 boolean false href 点击跳转的地址，指定此属性 button的行为和 a 链接一致 string - onClick 点击按钮时的回调 (event) =&gt; void - Button文档预览 Progress进度条类型声明类型声明在src/progress/interface.ts文件中写入，设置进度条主题颜色的类型、进度条组件的类型ProgressProps。percent代表当前进度条的百分比，strokeHeight设置高度，showText是否显示百分比数字。 import React from 'react'; export type ProgressThemeProps = | 'primary' | 'secondary' | 'success' | 'info' | 'warning' | 'danger' | 'light' | 'dark'; export interface ProgressProps &#123; /* 百分比 */ percent: number; /* 设置高度 */ strokeHeight?: number; /* 是否显示百分比文字 */ showText?: boolean; /* 用户自定义样式 */ style?: React.CSSProperties; /* 进度条主题颜色 */ theme?: ProgressThemeProps; &#125; Progress进度条实现在src/progress/index.tsx写入核心代码，根据传入的数字，来控制一个进度条长度；最外面有一个灰色progress-outer，它的高度可以配置，progress-outer内有一个子元素progress-inner，通过该元素的width来显示当前进度颜色，这个宽度是继承父元素progress-outer的，并悬浮到progress-outer上；通过在progress-inner设置flex布局，flex-end表示子项目从后往前排列，设置百分比数字显示在进度条右边，百分比数字也是支持显示和隐藏。 // progress/index.tsx import React, &#123; FC &#125; from 'react'; import &#123; ProgressProps &#125; from './interface'; /* percent: number 百分比 strokeHeight: number 高度 showText: boolean 是否显示百分比数字 theme: string 进度条主题色 style: React.CSSProperties 用户自定义样式 */ const Progress: FC&lt;ProgressProps> = (&#123; percent, strokeHeight, showText, style, theme, ...restProps &#125;) => &#123; return ( &lt;div className=\"yolo-progress\" style=&#123;style&#125; &#123;...restProps&#125;> &#123;/* 灰色最外层 */&#125; &lt;div className=\"yolo-progress-outer\" style=&#123;&#123; height: `$&#123;strokeHeight&#125;px` &#125;&#125;> &lt;div className=&#123;`yolo-progress-inner color-$&#123;theme&#125;`&#125; style=&#123;&#123; width: `$&#123;percent&#125;%` &#125;&#125;> &#123;showText &amp;&amp; &lt;span className=\"inner-text\">&#123;`$&#123;percent&#125;%`&#125;&lt;/span>&#125; &lt;/div> &lt;/div> &lt;/div> ); &#125;; /* 初始化默认值 */ Progress.defaultProps = &#123; strokeHeight: 15, showText: true, theme: 'primary', &#125;; export default Progress; Progress进度条说明文档src/progress/index.md 基本使用基本样式分为 7 种，默认类型为 primary。 primary | secondary | success | info | warning | danger | dark import React from 'react'; import &#123; Progress &#125; from 'yolo-ui'; export default () => ( &lt;div> &lt;Progress percent=&#123;20&#125; /> &lt;br /> &lt;Progress theme=\"secondary\" percent=&#123;30&#125; /> &lt;br /> &lt;Progress theme=\"success\" percent=&#123;40&#125; /> &lt;br /> &lt;Progress theme=\"info\" percent=&#123;50&#125; /> &lt;br /> &lt;Progress theme=\"warning\" percent=&#123;60&#125; /> &lt;br /> &lt;Progress theme=\"danger\" percent=&#123;70&#125; /> &lt;br /> &lt;Progress theme=\"dark\" percent=&#123;80&#125; /> &lt;br /> &lt;Progress theme=\"primary\" percent=&#123;100&#125; /> &lt;/div> ); 自定义高度import React from 'react'; import &#123; Progress &#125; from 'yolo-ui'; export default () => ( &lt;div> &lt;Progress percent=&#123;20&#125; strokeHeight=&#123;15&#125; /> &lt;br /> &lt;Progress theme=\"success\" percent=&#123;40&#125; strokeHeight=&#123;20&#125; /> &lt;br /> &lt;Progress theme=\"warning\" percent=&#123;60&#125; strokeHeight=&#123;30&#125; /> &lt;br /> &lt;Progress theme=\"danger\" percent=&#123;70&#125; strokeHeight=&#123;40&#125; /> &lt;/div> ); 是否显示百分比文字通过设置 showText属性。 import React from 'react'; import &#123; Progress &#125; from 'yolo-ui'; export default () => ( &lt;div> &lt;Progress percent=&#123;30&#125; showText=&#123;false&#125; /> &lt;br /> &lt;Progress theme=\"success\" percent=&#123;40&#125; strokeHeight=&#123;20&#125; showText=&#123;true&#125; /> &lt;br /> &lt;Progress theme=\"warning\" percent=&#123;60&#125; strokeHeight=&#123;30&#125; showText=&#123;true&#125; /> &lt;/div> ); API 属性 说明 类型 默认值 theme 主题颜色 primary | secondary | success | info | warning | danger | dark，非必填 primary percent 百分比 number - strokeHeight 进度条高度 number - showText 是否显示百分比文字 boolean true style 自定义样式 React.CSSProperties - Progress文档预览 Switch开关类型声明类型声明在src/switch/interface.ts文件中写入，checked属性是最开始是否被选中，disabled是否可以被禁用，onText开启状态的文本，offText关闭状态的文本，size是组件的尺寸大小，theme组件的颜色，onChange是状态切换时执行的回调函数。 import React from 'react'; export type SwitchSize = 'default' | 'sm'; export type SwitchChangeEventHandler = ( checked: boolean, event: React.MouseEvent&lt;HTMLButtonElement> | React.KeyboardEvent&lt;HTMLButtonElement>, ) => void; export interface SwitchProps &#123; /* 用户自定义样式 */ style?: React.CSSProperties; /** 是否被选中 */ checked?: boolean; /* 用户自定义类名 */ className?: string; /** 组件的尺寸 */ size?: SwitchSize; /** 是否被禁用 */ disabled?: boolean; /** 开启状态的文本 */ onText?: string; /** 关闭状态的文本 */ offText?: string; /** 状态切换时的回调 */ onChange?: SwitchChangeEventHandler; &#125; Switch开关实现在src/switch/index.tsx写入核心代码，基于button标签实现的，它有两个子元素div和span。div是一个白色的滑块，使用绝对定位，通过计算left值实现左右的切换，例如点击的时候，滑块的left值是left: calc(100% - 20px);，通过calc计算出的，这就是左右滑动的核心。同时还需要考虑background-color和background-image的优先级问题，最后span标签用来显示文本。 // switch/index.tsx import React, &#123; useState &#125; from 'react'; import classNames from 'classnames'; import &#123; SwitchProps &#125; from './interface'; /** * switch * @param &#123;checked&#125; bool 是否被选中 * @param &#123;disabled&#125; bool 是否被禁用 * @param &#123;onText&#125; string 开启状态的文本 * @param &#123;offText&#125; string 关闭状态的文本 * @param &#123;onChange&#125; func 状态切换时的回调 * @param &#123;size&#125; string Switch组件的尺寸大小 * @param &#123;theme&#125; string 组件的颜色 */ const Switch: React.FC&lt;SwitchProps> = (props) => &#123; const &#123; size, checked, disabled, onText, offText, onChange, className, style, ...restProps &#125; = props; /** * 设置初始背景色 */ const defaultStyle = &#123; ...style, backgroundColor: style?.backgroundColor || '#0099ff' &#125; const [isChecked, setChecked] = useState&lt;boolean>(!!checked); const classes = classNames('yolo-switch', className, &#123; 'yolo-switch-checked': !!isChecked, 'yolo-switch-disabled': disabled, [`yolo-switch-$&#123;size&#125;`]: size, &#125;); const handleClick = (e: React.MouseEvent&lt;HTMLButtonElement>) => &#123; if (!disabled) &#123; onChange &amp;&amp; onChange(!isChecked, e); setChecked(!isChecked); &#125; &#125;; return ( &lt;button type=\"button\" className=&#123;classes&#125; onClick=&#123;handleClick&#125; style=&#123;defaultStyle&#125; &#123;...restProps&#125; > &lt;div className=\"yolo-switch-handle\">&lt;/div> &lt;span className=\"yolo-switch-inner\">&#123;isChecked ? onText : offText&#125;&lt;/span> &lt;/button> ); &#125;; export default Switch; Switch说明文档src/switch/index.md 基本使用import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch checked /> &lt;br /> &lt;br /> &lt;Switch/> &lt;/> ); &#125;; 禁止使用import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch disabled /> &lt;br /> &lt;br /> &lt;Switch disabled checked /> &lt;/> ); &#125;; 定制主题颜色import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch checked style=&#123;&#123; backgroundColor: 'green'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'red'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'yellow'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'pink'&#125;&#125;/> &lt;br /> &lt;br /> &lt;Switch checked style=&#123;&#123;backgroundColor: 'blue'&#125;&#125;/> &lt;/> ); &#125;; 组件尺寸import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch checked size=\"sm\" /> &lt;br /> &lt;br /> &lt;Switch checked /> &lt;/> ); &#125;; 开关内容import React from 'react'; import &#123; Switch &#125; from 'yolo-ui'; export default () => &#123; return ( &lt;> &lt;Switch onText=&#123;'开'&#125; offText=&#123;'关'&#125; onChange=&#123;(checked, e) => &#123; console.log(checked, e); &#125;&#125; checked /> &lt;/> ); &#125;; API 参数 说明 类型 默认值 style 自定义样式，backgroundColor可自定义颜色 string #09f checked 是否被选中 boolean false size 开关大学 default | sm - disabled 是否被禁用 boolean false onText 开启状态的文本 string | ReactNode - offText 关闭状态的文本 string | ReactNode - onChange 选中值发生变化时触发 function(checked: boolean, event: Event) - Switch文档预览 代码打包输出和发布组件库的入口文件 组件库的入口文件为 src/index.ts 组件库的全局样式文件为 src/style/index.less或者 src/global.less，两者都可以用来全局样式的提取。 组件的打包在根目录新建tsconfig.build.json文件&#123; \"compilerOptions\": &#123; \"outDir\": \"dist\", // 编译之后的存放路径 \"module\": \"ESNext\", \"target\": \"ES5\", // 指定编译之后的目标版本 \"declaration\": true, // 为每一个js文件生成 .d.ts类型声明文件 \"jsx\": \"react\", \"moduleResolution\": \"node\", // classic 和 Node \"allowSyntheticDefaultImports\": true // true 支持 defalut 引入的方式 &#125;, \"include\": [\"src/\"], \"exclude\": [\"src/**/style\", \"src/**/*.md\"] &#125; 在package.json文件中添加命令分别安装lessc和rimraf依赖，lessc将less转化为css，rimraf用来删除dist目录。 &#123; \"scripts\": &#123; \"clean\": \"rimraf ./dist\", \"build:lib\": \"npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css\", \"build-ts\": \"tsc -p tsconfig.build.json\", \"build-css\": \"lessc ./src/style/index.less ./dist/index.css\", &#125; &#125; 在执行build-ts发生了很多个报错如下，经过在stackoverflow上查找相关资料得知，是 @types/react-router-dom和 @types/react-router的版本太低了导致了，把这两个依赖升级到最新版本后，就可以正常打包了。 xxx/node_modules/@types/react-router-dom/index.d.ts(59,34): error TS2694: Namespace '\"/node_modules/history/index\"' has no exported member 'LocationState'. 本地测试(npm link) 在yolo-ui的根目录下执行npm link命令，npm link的作用是可以让未发布的npm包，做本地测试，映射脚本； 在yolo-ui-test（create-react-app生成的测试项目）工程下执行npm link yolo-ui； 在yolo-ui-test的package.json中加入yolo-ui依赖。 &#123; \"dependencies\": &#123; \"yolo-ui\": \"^0.1.0\" &#125;, &#125; 分别在 App.tsx和 index.tsx引入组件和组件的样式 // App.tsx import &#123; Button &#125; from 'yolo-ui'; function App() &#123; return ( &lt;div className=\"App\"> &lt;Button type=\"primary\">Hello Yolo&lt;/Button> &lt;/div> ); &#125; export default App; // index.tsx import \"yolo-ui/dist/index.css\"; 测试结果如下，本地测试没问题。 将yolo-ui发布到npm 切换npm的源镜像为npm的原生源 在命令行工具执行npm adduser，填写username、password and email 登录(sign in) 在package.json添加一些必要信息 &#123; \"files\": [ \"dist\" ], // 发布哪些文件到npm // 添加prepublish命令 \"scripts\": &#123; \"clean\": \"rimraf ./dist\", \"build:lib\": \"npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css\", \"build-ts\": \"tsc -p tsconfig.build.json\", \"build-css\": \"lessc ./src/style/index.less ./dist/index.css\", \"prepublish\": \"npm run build:lib\" &#125;, &#125; 执行npm publish即可发布到npm 此外，还可以在peerDependencies中告诉用户，要使用某某依赖需要安装什么依赖，如下：要使用yolo-ui库，需要安装react和react-dom的16.8.0版本以上。当npm i yolo-ui时，peerDependencies里面的依赖不会被安装，会有一个日志输出，npm warning会提示用户需要安装react和react-dom的依赖。 // package.json &#123; \"peerDependencies\": &#123; \"react\": \"≥16.8.0\", \"react-dom\": \"≥16.8.0\" &#125;, &#125; yolo-ui静态文档上传至阿里云服务器购买服务器本人买的是阿里云服务器 远程登录服务器桌面(windows) 在window桌面上按 win + R，输入 mstsc，进入远程桌面连接 如果没有添加windows凭据的，先在 控制面板-&gt;凭据管理器-&gt;windows凭据里添加服务器的凭据 输入账号和密码即可登录服务器远程桌面 安装node环境 将node的安装包上传到云服务器，并安装，node -v可以查看版本和是否安装成功 启动静态服务器 在根目录下 npm init -y，初始化 package.json文件，新建index.js文件 上传静态文件docs-dist（dumi 打包的产物）到根目录，docs-dist文件内容如下： 安装 koa和 koa-static，用来启动一个静态资源服务器。 在index.js写入代码： const Koa = require('koa'); const path = require('path'); const static = require('koa-static'); const app = new Koa(); // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './docs-dist'; app.use(static( path.join(__dirname, staticPath) )) app.listen(80, () => &#123; console.log('server is running, port is 80'); &#125;) 在根目录下执行 node index.js，开启服务器成功 最后在浏览器地址输入云服务器ip地址即可访问 域名的注册和备案nginx开启静态服务，并配置二级域名访问安装nginx（windows版） 进入nginx官网下载安装包: nginx下载 解压下载完成的nginx压缩包 打开cmd，进入nginx安装包根路径 输入命令nginx -t：检查nginx是否配置成功 输入命令start nginx：启动nginx服务 nginx其他常用命令 修改了配置文件，如nginx.conf，要使修改生效，重启Nginx服务 nginx -s reload 关闭nginx服务 nginx -s quit 强制关闭Nginx服务 nginx -s stop nginx.conf配置文件 nginx的配置在根目录conf文件夹下的nginx.conf文件中 server：代理服务器，可以设定多个代理服务器（每一个server就是一个虚拟服务器），请求进来之后由server的server_name决定该请求访问哪一个服务。 以下是在阿里云服务器nginx配置不同域名，访问不同的静态资源的例子，比如访问home和detial，我们只需要把静态文件分别放到C:/v1/home和C:/v1/detial目录下，即可通过http://home.xxxxx.com和http://detial.xxxxx.com分别访问对应的静态资源。 与此同时，需要在云服务器官网添加记录，二级域名的home和detial的解析设置 server &#123; # 设置监听端口 listen 80; server_name home.xxxxx.com; # 设置url编码格式，解决参数中文乱码问题 charset utf-8; location &#x2F; &#123; root C:&#x2F;v1&#x2F;home; # 设置 root-指定请求资源在服务器上的真实路径，可以写相对路径（相对于nginx安装目录）也可写绝对路径； index index.html index.htm; # 指定访问主页，会在root设定目录下去找，后面可跟多个页面，依次查找，找到一个即返回； &#125; &#125; server &#123; # 设置监听端口 listen 80; server_name detial.xxxxx.com; # 设置url编码格式，解决参数中文乱码问题 charset utf-8; location &#x2F; &#123; root C:&#x2F;v1&#x2F;detial; index index.html index.htm; &#125; &#125; YoloUI预览地址YoloUI官网 参考 dumi官方网站 ant-design arco-design monki-ui 最详细的React组件库搭建总结 Nginx在windows下的安装、运行，以及配置文件讲解","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"Koa 基础开发","slug":"front_end/koa-base","date":"2022-02-20T19:35:10.000Z","updated":"2022-07-22T17:11:59.201Z","comments":true,"path":"2022/02/21/front_end/koa-base/","link":"","permalink":"http://example.com/2022/02/21/front_end/koa-base/","excerpt":"","text":"koa官网文档 koa是一个基于http模块进行封装的框架，koa本身没有内置任何中间件，需要手动下载中间件（约定了中间件的写法），可以用来做服务端接口，也可以做接口的转发和聚合，RPC服务组装、SSR。 koa导出的是一个类，需要通过new 来实例化，koa也是继承了Events模块，性能非常好，代码量少，易于定制，很多框架都是基于koa进行定制开发（egg，thinkjs、midway都是基于koa2）。 基于koa框架的web开发要点ES6语法、异步流程控制、数据库操作、API接口转发、HTTP集成、Koa中间件 koa与express的区别 koa中间件可以对请求和响应同时进行拦截，express只能对请求进行拦截，而且是有顺序的，不能对响应进行拦截。 koa和express都内置了cookies模块、http模块，此外，express还内置了路由、视图模块。相对于express，koa还是比较轻量的。 koa中间件写法 中间件可以分为全局中间件和局部中间件，局部中间件在对应的路由里生效，比如静态资源服务，在特定的路由才执行 中间件是框架的扩展机制，对请求响应过程中加入中间件，应对处理复杂的业务逻辑。挂载在入口文件的中间件，会按照顺序执行。 koa中间件是洋葱模型，跳转的信号是next()，通过compose实现，最终的返回值是一个 function(context, next)。compose([fl, f2,..,fn])转化为了f1(..f(n-1)(fn(noop())) 在koa引入的中间件，需要使用app.use将中间件挂载到app上app.use(async (ctx, next) => &#123; console.log(1) await next() console.log(2) &#125;) app.use(async (ctx, next) => &#123; console.log(3) await next() console.log(4) &#125;) // 输出的结果是1342 koa中间件的工作过程中间件类似一个过滤器，koa中间件的工作大致过程可以分为三部分： 处理请求前先完成一些准备工作。 进行业务逻辑处理或通过next将业务交由下一个中间件处理。 后面的中间件完成处理后会进行回溯，执行处理后的操作。 ctx 参数ctx头部信息 设置头部信息：ctx.header(ctx.headers) 获取头部信息：ctx.get(&#39;key&#39;) ctx.method，获取请求方法 ctx.status或者ctx.response.status，获取状态码和设置状态码 ctx.type，设置Content-Type ctx.response.header &#x3D; ctx.request.header &#x3D; ctx.header ctx.req &#x3D; ctx.res &#x3D; ctx.request &#x3D; ctx.response ctx地址参数koa解析http://127.0.0.1:3000/api/v1/getUser?a=1&amp;b=2#abc地址后，会将返回的结果赋值给ctx对象。 API 示例值 ctx.href（不包括hash） http://127.0.0.1:3000/api/v1/getUser?a=1&amp;b=2 ctx.path &#x2F;api&#x2F;v1&#x2F;getUser ctx.url &#x2F;api&#x2F;v1&#x2F;getUser?a&#x3D;1&amp;b&#x3D;2 ctx.search ?a&#x3D;1&amp;b&#x3D;2 ctx.querystring a&#x3D;1&amp;b&#x3D;2 ctx.query &#123;&quot;a&quot;: &quot;1&quot;,&quot;b&quot;: &quot;2&quot;&#125; ctx.origin http://127.0.0.1:3000 ctx.host 127.0.0.1:3000 ctx.hostname 127.0.0.1 ctx.protocol http ctx.secure（https为true） false 获取不同的参数 参数名称 描述 Express获取方法 Koa获取方法 依赖模块 params 具名参数，比如/users/:id req.params ctx.params Koa需要依赖koa-router内置的ctx.params，而Express中有内置路由，无须依赖 query 查询字符串?a=1&amp;b=2 req.query ctx.query 内置，无须依赖 body 带有body请求的POST类方法，请求体body内容 req.body ctx.request.body Express依赖bodyparser模块，Koa依赖koa-bodyparser模块 koa写入Koa框架本身集成了Cookie的中间件，方法如下，options对象用于配置 ctx.cookies.get(name, [options]) ctx.cookies.set(name, value, [options]) options对象用于配置 maxAge: 一个数字, 表示从 Date.now() 得到的毫秒数, 表示多少毫秒后失效 expires: 一个 Date 对象, 表示 cookie 的到期日期 (默认情况下在会话结束时过期). path: 一个字符串, 表示 cookie 的路径 (默认是&#x2F;). domain: 一个字符串, 指示 cookie 的域 (无默认值). secure: 一个布尔值, 表示 cookie 是否仅通过 HTTPS 发送 (HTTP 下默认为 false, HTTPS 下默认为 true). httpOnly: 一个布尔值, 客户端无法操作cookie (默认为 true). sameSite: 一个布尔值或字符串, 表示该 cookie 是否为 “相同站点” cookie (默认为 false). 可以设置为 ‘strict’, ‘lax’, ‘none’, 或 true (映射为’strict’). signed: 一个布尔值, 表示是否要对 cookie 进行签名 (默认为 false). 此签名密钥用于检测下次接收 cookie 时的篡改. overwrite: 一个布尔值, 表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（无论路径或域）是否在设置此Cookie 时从 Set-Cookie 消息头中过滤掉. cookie的value默认是不能中文，可以使用buffer将中文转化后使用（通用的方法） // 设置signed: true 必须要app.keys = ['xxx'] 设置加密秘钥 // app.keys = ['xxx'] ctx.cookies.set('name', 'value', &#123; // signed: true, httpOnly: true, maxAge: 1000 * 30, // 30秒过期 &#125;); Cookie例子const Koa = require('koa') const app = new Koa() const Router = require('koa-router') const router = new Router() router.get('/setCookie', async (ctx) => &#123; ctx.cookies.set( 'id', '123456', &#123; domain: '127.0.0.1', // cookie所在的domain(域名) expires: new Date('2022-10-01'), // cookie的失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 &#125; ) ctx.body = `设置成功` &#125;) router.get('/getCookie', async (ctx) => &#123; const cookie = ctx.cookies.get('id') console.log(cookie) ctx.body = `cookie为：$&#123;cookie&#125;` &#125;) // 加载路由中间件 app.use(router.routes()) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) koa-router中间件const Koa = require('koa'); const app = new Koa(); const router = require('koa-router')() // 指定路由前缀 // router.prefix('/users') router.get('/', async (ctx, next) => &#123; ctx.body = '&lt;h1>koa-router&lt;/h1>' // 返回HTML // ctx.body = 'koa-router' // 返回 文本 // ctx.body = &#123; a: 1, b: 2&#125; // 返回json // await ctx.render('index', &#123; title: 'hello koa2'&#125;) &#125;) // 将路由挂载到app上 app.use(router.routes()).(router.allowedMethods()); app.listen(8888); ctx.body的工作原理根据body的类型设置对应的Content-Type，根据Content-Type调用res.write，将数据写入浏览器。可以知道，赋予ctx.body不同类型的值时会返回不同的结果： 为ctx.body赋值JSON对象时，服务器会返回JSON接口； 为ctx.body赋值字符串时，服务器会返回 HTML文本； ctx.render是因为添加了koa-views 中间件而绑定到ctx上的，原本的ctx上是没有render函数的。也就是说，我们可以通过中间件在ctx上绑定我们要使用的功能对象方法。 koa-router路由实现原理 本质上就是对ctx.path进行封装。定义路由，路由的路径会被转义成正则表达式，匹配请求，使用中间件进行处理。 koa-router的核心是路由的解析，使用的是path-to-regexp模块（express也使用了该模块），express路由和koa-router路由的区别是中间件的写法不同 匹配请求时，只和路径有关。qureyString参数是不会考虑在内的。比如 router.get('/v1') // GET /v1?name=zhongph 也会匹配上 具名参数，:xxx会被从正则表达式提前处理，具名参数通过ctx.params.xxx获取 router.get('/user/:id', (ctx, next) => &#123; console.log(ctx.params.id) &#125;) 路由也是中间件，可以定义多个中间件，在这个例子里，第一个中间件根据ID查询到的用户，先被绑定到了ctx对象上，然后交给了下一个中间件进行处理。接着，第二个中间件根据第一个中间件产生的ctx.user完成某些内容，最终决定返回何值。 router.get('/users/:id', function (ctx, next)&#123; return User.find0ne (ctx.params.id).then(function (user) &#123; ctx.user = user; return next(); &#125;) &#125;, function (ctx)&#123; console.log(ctx.user); // &#123; id: '001', name:\"zhongph\" &#125; &#125; ) koa-static静态服务静态服务器是通过静态HTTP服务器来提供HTML、JavaScript、CSS文件及图片的托管服务的.Node.js世界里的 koa-static、http-server等模块和常见的Apache、Nginx功能类似。线上通用做法是将静态资源放到CDN上，利用CDN就近访问来提高访问效率。实际开发环境，通过koa-static等模块能快速实现静态服务器功能。 // koa-static实现静态服务器，static 是一个函数，需要传一个静态资源的路径进去 const static = require('koa-static'); const path = require('path'); const Koa = require('koa'); const app = new Koa(); // 静态资源目录static 相对于 入口文件index.js的路径 const staticPath = './static'; // __dirname 是指 当前文件所在的目录 app.use(static(path.join(__dirname, staticPath))) app.listen(4000, (err, res) => &#123; console.log(\"server is running, port is 4000\"); &#125;); koa-static的做法是： 判断请求的文件是否存在，如果存在读取文件返回；如果请求的文件不存在，默认返回当前路径下的index.html 不要把static中间件放到Koa的全局中间件上（如果对于每个请求都要判断一次是不是静态资源，会影响QPS)，最好结合koa-router来处理，按需挂载 （QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准）const staticServer = require('koa-static'); const router = require('koa-router')(); router.get('/public/*', async (ctx, next) => &#123; ctx.url = path.basename(ctx.url) await next() &#125;, staticServer(resolve('./public'), &#123; gzip: true&#125;) ) koa-static的底层实现koa-static的底层使用的是koa-send koa-send原理 根据文件后缀名，进行设置 Content-Type。 以 stream 的形式为 ctx.body 赋值，这种方式比 fs.readFileSync 更高效。if (!ctx.type) &#123; ctx.type = type(path, encodingExt); &#125; ctx.body = fs.createReadStream(path); 其中 ctx.type是根据文件后缀来设置Content-Type的便捷方法，代码如下。// extname 和 basename 是path模块的方法 function type(file, ext)&#123; return ext !== '' ? extname(basename(file, ext)) : extname(file); &#125; 静态服务原理根目录下有static文件夹和index.js，static目录下有index.html文件、image和css文件夹，分别放置对应文件。 const Koa = require('koa') const fs = require('fs') const path = require('path') // 设置一个mime map，设计三种测试类型 const MIMES_MAP = &#123; 'css': 'text/css', 'html': 'text/html', 'jpg': 'image/jpeg' &#125; const app = new Koa() // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' // 解析资源类型 function parseMime(url) &#123; let extName = path.extname(url) extName = extName ? extName.slice(1) : 'unknown' return MIMES_MAP[extName] &#125; app.use(async (ctx) => &#123; // 静态资源目录在本地的绝对路径 let fullStaticPath = path.join(__dirname, staticPath) // 获取静态资源内容，有可能是文件内容，目录，或404 let content = fs.readFileSync(path.join(fullStaticPath, ctx.url), 'binary') // 解析请求内容的类型 let mime = parseMime(ctx.url) // 如果有对应的文件类型，就配置上下文的类型 if (mime) &#123; ctx.type = mime &#125; // 输出静态资源内容 if (mime &amp;&amp; mime.indexOf('image/') >= 0) &#123; // 如果是图片，则用node原生res，输出二进制数据 ctx.res.writeHead(200) ctx.res.write(content, 'binary') ctx.res.end() &#125; else &#123; // 其他则输出文本 ctx.body = content &#125; &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) koa-mountkoa-static不能用来设置请求前缀，如果想实现这个功能，就需要用到koa-mount，koa-mount是一个将中间件挂载到指定路径的Koa中间件，它可以挂载任意koa中间件。koa-mount和koa-static结合，就可以实现和Express一样的静态服务器带有请求前缀的功能，代码如下。 const Koa = require('koa'); const koaStatic = require('koa-static'); const mount = require('koa-mount'); const app = new Koa(); // app.use(koaStatic('.')) // 设置请求前缀 app.use(mount('/static', koaStatic('.')) app.listen (3000); // 访问 http:/127.0.0.1:3000/static/package.json koa-views koa-views是一个koa的动态模板引擎渲染中间件，主要用于简单的前后端不分离的项目。通过控制路由的方式，返回不同的页面。以前的服务端渲染页面，如JSP&#x2F;PHP，就是指模板引擎。 模板引擎采取了一种复用思想，通过定义模板，在使用时和数据一起编译，生成HTML页面，以便浏览器渲染。编译(模板＋数据) = HTML，模板是不可变的，可变的是数据，然而数据是从哪里来的呢? 可以从数据库读取，可以访问接口获得，甚至可以模拟，具体取决于业务场景。 模板推荐：ejs、pug（jade） const views = require('koa-views'); // 通过app.use绑定到app上，实际上是给app对象增加ctx.render方法的绑定 app.use(views(__dirname + '/views', &#123; extension: 'pug' &#125;)) // 模板文件：views/index，相对位置在views目录下 router.get('/', async (ctx, next) => &#123; await ctx.render('index', &#123; title: 'hello koa2'&#125;) // ctx.render渲染模板 &#125;) 这里的ctx.render就是用于渲染模板的方法，它有两个参数。 index: 模板，采用相对路径，对应的是views目录下的index.pug。 JSON对象: 需要传入到模板内的数据。 ctx.render 执行的操作： 通过文件读取 index.pug 模板。 使用 pug 模板引擎编译器将数据和模板内容编译为 HTML 字符串。 将 Content-Type 设置为 text&#x2F;html。 将 statusCode 状态码设置为200。 通过 http模块 底层的 res.write 和 res.end 方法将 HTML 字符串写入浏览器 模板引擎模板引擎的用途：用于动态渲染页面，与cli结合，作为模板使用 ejs 语句的需要有 &lt;% %&gt; （尖括号和百分号） 如果需要填入变量，需要在&lt;%添加一个等号，&lt;%&#x3D; &lt;ul> &lt;% user.forEach(function(user)&#123; %> &lt;li> &lt;%= user.name %>&lt;/li> &lt;% &#125;) %> &lt;/ul> pug （安装npm i -s pug）pug的基本使用：在这段模板定义代码里，if语句首先判断user对象是否存在，如果存在就显示&lt;h2&gt;标签，并把user.name作为变量嵌入&lt;h2&gt;标签的显示内容里。 //- user.pug if user h2= user.name pug的编译：使用 pug-cli 或 pug-server 可以自动将模板文件编译为HTML文件，并提供HTTP静态服务。此外，在线转化工具 html2jade，它可以将已有的HTML 代码转换为pug模板，非常的使用。 使用模板引擎（pug）时要注意： 引用公共模块时使用include。实现父子布局继承时使用extends。 定义布局模板时使用Layout，布局留空时使用block。缩进时使用Tab键而非空格。 不管有没有属性，标签和value之间都要有空格。 可以通过预编译来提高模板执行效率。 编译pug const pug = require('pug'); const fs = require('fs'); // 通过fs.readFileSync读取模板文件 // 当读取到的内容通过 toString 转化为字符串 const user_pug_str = fs.readFileSync('./user.pug').toString(); // pug.render方法进行编译，编译后的结果是HTML代码 var user_html = pug.render(user_pug_str, &#123; user: &#123; name: 'yolo' &#125; &#125;) console.log(user_html) // 编译结果 &lt;h2>yolo&lt;/h2> for循环显示列表 //- list.pug ul each item in users li= item.name pug模板引擎规则 标签属性 p#root.container //- 等价于 p(id='root', class='container') //- &lt;p id='root' class='container'>&lt;/p> 标签内容value，标签与内容之间有空格 p this is a tag //- &lt;p>this is a tag&lt;/p> 层级嵌套原理：利用缩进来判断包含关系。缩进方式有两种：使用空格和使用Tab建（推荐Tab键） &lt;ul class=\"parent\"> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;/ul> //- pug写法 ul.parent li 1 li 2 li 3 变量 //- 代码里等号，表示后面接的是变量，子类extends继承该布局时，name变量在子页面里也可以使用 p= name //- 插写法 p #&#123; name &#125; //- 不转义代码 !&#123; html &#125; !&#123; \"&lt;script>&lt;/script>\" &#125; if和each //- user.pug if user h2= user.name //- list.pug index是下标 ul each item, index in users li= item.name 布局 //- extends指明了当前pug页面需要继承哪个layout布局 extends ../layout //- 实现block模块，名字必须和layout里一致 block left_content block main_content 内嵌sctipt代码，script后面的点 .必须要有 script. function test()&#123;&#125; koa-compose可以将多个中间件合并成一个中间件 const compose= require('koa-compose') module.exports = (ctx, next) => &#123; return compose([ (ctx,next) => &#123; //中间件 return next() &#125; (ctx, next) => &#123; //中间件 return next() &#125; ])(ctx, next) &#125; koa-bodyparserkoa-bodyparser中默认只支持JSON、form两种格式的解析，其他类型的解析需要在enableTypes中配置，如&#39;text/plain&#39;配置为text。 const bodyparser = require('koa-bodyparser') // 将bodyparser挂载到app上 app.use(bodyparser( // 配置更多的类型 enableTypes: ['json', 'form', 'text'] )) // 访问 body参数 ctx.request.body // 如果post请求后面拼接了参数， 也可以通过ctx.query获取 @koa&#x2F;cors跨域问题 // 安装 @koa/cors 或者 koa2-cors（很久没有更新） // npm i koa2-cors const cors = require('@koa/cors') // https://www.npmjs.com/package/@koa/cors // 这里cors中间件一定要写在路由之前 app.use(cors()); app.use(router.routes(), router.allowedMethods()) @koa-multer（文件上传模块）文件上传有两种方式: 调用CDN的 SDK将文件直接从前端上传到CDN上； 采用常规上传方式，先将文件上传到Node.js服务器，再由 Node.js服务器转存到CDN； 二者的差别在于是否需要通过服务器对文件进行定制，如果没有这样的需求，直接上传就是很不错的方式。 @koa-multer是一个非常便于使用的文件上传模块，使用@koa-multer可以解析body中的流，并将其保存成文件。@koa-multer不会处理multipart&#x2F;form-data以外的任何表单 @koa&#x2F;multer文件上传 const Koa = require('koa') const Router = require('koa-router') const route = new Router() const multer = require('@koa/multer') const path = require('path') //上传⽂件存放路径、及⽂件命名 const storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, path.join(__dirname ,'/public')) &#125;, filename: function (req, file, cb) &#123; let type = file.originalname.split('.')[1] cb(null, `$&#123;file.fieldname&#125;-$&#123;Date.now().toString(16)&#125;.$&#123;type&#125;`) &#125; &#125;) //⽂件上传限制 const limits = &#123; fields: 10, // ⾮⽂件字段的数量 fileSize: 500 * 1024, //⽂件⼤⼩单位 b files: 1 // ⽂件数量 &#125; const upload = multer(&#123;storage,limits&#125;) // 在路由中，可通过 ctx.file 获取上传完毕的⽂件信息，多⽂件上传可通过 ctx.files 获取 route.post('/user/file', async (ctx,next)=>&#123; // file名字前后端要一致 let err = await upload.single('file')(ctx, next) .then(res=>res) .catch(err=>err) if(err)&#123; ctx.body = &#123; code:0, msg : err.message &#125; &#125;else&#123; ctx.body = &#123; code:1, data:ctx.file &#125; &#125; &#125;) &#125;) app.use(router.routes()).use(router.allowedMethods()) app.listen(3000) 文件上传koa-body和koa-send 后端逻辑const Koa = require('koa') const path = require('path') const fs = require('fs') const static = require('koa-static') const Router = require('koa-router') // koa文件上传用到的 中间件 const koaBody = require('koa-body'); // koa文件 下载 用到的 中间件 const send = require('koa-send'); const app = new Koa() const router = new Router() const staticPath = './static' app.use(koaBody(&#123; multipart: true, formidable: &#123; maxFileSize: 200 * 1024 * 1024 // 设置上传文件大小最大限制，默认2M &#125; &#125;)); // 静态服务器 app.use(static( path.join(__dirname, staticPath) )) app.use(router.routes()) router.post('/upload', async (ctx) => &#123; // 获取文件对象 const file = ctx.request.files.file // 读取文件内容 const data = fs.readFileSync(file.path); // 保存到服务端 fs.writeFileSync(path.join(__dirname, file.name), data); ctx.body = &#123; message: '上传成功！' &#125;; &#125;) router.get('/download/:name', async (ctx) => &#123; const name = ctx.params.name; const path = `$&#123;name&#125;`; ctx.attachment(path); await send(ctx, path); &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) 在koa中发起请求（node-fetch和axios）node-fetch node-fetch// npm i --save-dev node-fetch const fetch = require('node-fetch') fetch('http://127.0.0.1:3000/users/post', &#123; method: 'POST', body: JSON.stringify(&#123; username: 'yourUsername', password: 'yourPassword' &#125;), headers:&#123; 'Content-Type': 'application/json' &#125; &#125;).then(function(res) &#123; return res.json(); &#125;.then(function (json)&#123; console.log(json) &#125; 前端上传文件例子&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>上传&lt;/title> &lt;/head> &lt;body> &lt;input type=\"file\" /> &lt;button>点击上传&lt;/button> &lt;/body> &lt;script> document.querySelector('button').onclick = function () &#123; // 这里会获取一个 files 数组对象 因为是单文件上传取第一个即可 let file = document.querySelector('input').files[0]; let xhr = new XMLHttpRequest(); xhr.open('post', '/upload', true); xhr.onload = function () &#123; let res = JSON.parse(xhr.responseText); console.log(res); &#125; let form = new FormData(); form.append('file', file); // 对应 key value xhr.send(form); &#125; &lt;/script> &lt;/html> API访问鉴权：JSON Web Tokens(JWT)直接使用原始的JWT进行鉴权 客户端申请令牌时，使用jwt.sign进行签名，并将签名结果返回客户端； 签名体(payload）会包含用户的必要信息，以便通过 jwt.verify进行校验时能获得该信息，作为后面的查询依据； 当API请求携带令牌时，需要先使用jwt.verify进行校验，成功后才能根据用户信息查询并返回数据。 const jwt = require('jsonwebtoken'); const secret = 'secretxxx'; var token = jwti.sign(&#123; data: &#123; user_id: 100000, username: 'yolo', user_email:'yolo.com' &#125;, secret, &#123; expiresIn: '1h'&#125;); &#125;) // 获取令牌信息 // 检查PoST的信息、URL查询参数、头部信息 const token = ctx.request.body.token || ctx.query.token || ctx.headers['x-access-token'] // 验证 try&#123; var decoded = jwt.verify(token, secret) console.log(decoded); &#125;catch (err) &#123; &#125; 使用koa-jwt模块const jwt = require('koa-jwt'); router.get('/api', jwt(&#123; secret: 'secretXXX'&#125;), (ctx, next) => &#123; &#125;) koa-etag（ETag处理）ETag 是前端缓存优化的重要部分。ETag 在服务器端生成后，客户端将通过If-Match或If-None-Match条件判断请求来验证资源是否被修改，其中比较常用的是If-None-Match。如果资源没有被修改则返回304状态码，如果被修改则返回正常值。一般的静态 HTTP服务器都会根据文件内容来判断文件是否被修改，进而决定是否需要给客户端返回新内容。在Koa里，我们需要使用koa-conditional-get和 koa-etag插件来提供ETag 功能，示例如下。 这里定义的变量etag就是在Koa中用于生成ETag 的中间件。 ETag缓存是通过conditional-get拦截才能生效的。 koa-conditional-get 一定要放在koa-etag 前面。 const conditional = require('koa-conditional-get'); const etag = require('koa-etag'); t机市用 // etag模块 通常和 conditional-get 模块一起使用 app.use(conditional()); app.use(etag()); koa-session(会话session)koa-session + ioredis app.js入口文件const Koa = require('koa'); const fs = require('fs'); const Router = require('koa-router') const bodyParser = require('koa-bodyparser') const session = require('koa-session'); const Store = require('./store') // shortid 工具生成id const shortid = require('shortid'); const app = new Koa(); const router = new Router() const redisConfig = &#123; redis: &#123; port: 6379, host: '127.0.0.1', password: '', &#125;, &#125;; const sessionConfig = &#123; // cookie 键名 key: 'koa:session', // 过期时间为一天 maxAge: 86400000, // 不做签名 signed: false, // 提供外部 Store store: new Store(redisConfig), // key 的生成函数 genid: () => shortid.generate(), &#125;; app.use(session(sessionConfig, app)); app.use(bodyParser()); app.use(router.routes()); router.get('/', async (ctx) => &#123; ctx.set(&#123; 'Content-Type': 'text/html' &#125;); ctx.body = fs.readFileSync('./index.html'); &#125;) // 当用户登录时，走这里 router.post('/login', async (ctx) => &#123; const postData = ctx.request.body // 获取用户的提交数据 if (ctx.session.usr) &#123; ctx.body = `欢迎, $&#123;ctx.session.usr&#125;`; &#125; else &#123; ctx.session = postData; ctx.body = '您第一次登录系统'; &#125; &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) store.js// Node const Redis = require('ioredis'); class RedisStore &#123; constructor(redisConfig) &#123; this.redis = new Redis(redisConfig); &#125; // 获取 async get(key) &#123; const data = await this.redis.get(`SESSION:$&#123;key&#125;`); return JSON.parse(data); &#125; // 设置 async set(key, sess, maxAge) &#123; await this.redis.set( `SESSION:$&#123;key&#125;`, JSON.stringify(sess), 'EX', maxAge / 1000 ); &#125; // 销毁 async destroy(key) &#123; return await this.redis.del(`SESSION:$&#123;key&#125;`); &#125; &#125; module.exports = RedisStore; 前端登录逻辑&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>登录&lt;/title> &lt;/head> &lt;body> &lt;div> &lt;label for=\"user\">用户名：&lt;/label> &lt;input type=\"text\" name=\"user\" id=\"user\"> &lt;/div> &lt;div> &lt;label for=\"psd\">密码：&lt;/label> &lt;input type=\"password\" name=\"psd\" id=\"psd\"> &lt;/div> &lt;button type=\"button\" id=\"login\">登录&lt;/button> &lt;h1 id=\"data\">&lt;/h1> &lt;script> const login = document.getElementById('login'); login.addEventListener('click', function (e) &#123; const usr = document.getElementById('user').value; const psd = document.getElementById('psd').value; if (!usr || !psd) &#123; return; &#125; //采用 fetch 发起请求 const req = fetch('http://localhost:4000/login', &#123; method: 'post', body: `usr=$&#123;usr&#125;&amp;psd=$&#123;psd&#125;`, headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125;) req.then(stream => stream.text() ).then(res => &#123; document.getElementById('data').innerText = res; &#125;) &#125;) &lt;/script> &lt;/body> &lt;/html> koa-generic-session + koa-redis(基于redis存储) 依赖Redis，因此需要先启动Redis服务器。 通过ctx.session进行会话信息处理。 TTL是Session Store的超时时间，这个值一般是30min。 const Koa = require('koa') const session = require('koa-generic-session') const RedisStore = require('koa-redis') const app = new Koa() // app.env 默认是 NODE_ENV 或 \"development\" // app.proxyIpHeader 代理 ip 消息头, 默认为 X - Forwarded - For // app.maxIpsCount 从代理 ip 消息头读取的最大 ips, 默认为 0(代表无限) // app.keys 签名的 cookie 密钥数组 app.keys = ['keys', 'keykeys']; //加入全局中间件 app.use(session(&#123; store: new RedisStore(), ttl: 30 * 60 * 1000 // 半小时 &#125;)) // Session Store其实就是将会话存储在不同持久化存储中以后抽象出来的通用层，其基本的存、取和销毁操作如下。 // - get(sid): 根据sid来获取会话信息。 // - set(sid, sess, ttl): 通过sid设置会话信息，ttl指的是会话可存活时间(ms // - destroy(sid): 根据sid销毁会话。 // 在路由中可以直接通过ctx.session对后面的中间件进行操作 app.use (ctx => &#123; switch (ctx, path)&#123; case '/get': ctx.session.user = &#123; name: 'yolo' &#125; ctx.body = ctx.session.user break; case '/remove': ctx.session =null ctx.body = \"removed\" break &#125; app.listen (8080) koa-session例子 后端使用koa-sessionconst Koa = require('koa'); const fs = require('fs'); const Router = require('koa-router'); const bodyParser = require('koa-bodyparser'); const session = require('koa-session'); const app = new Koa(); const router = new Router(); const sessionConfig = &#123; // cookie 键名 key: 'koa:session', // 过期时间为一天 maxAge: 86400000, // maxAge: session 最大存活周期, 单位 ms, 默认一天。 // 不做签名 signed: false, // signed: 默认 true, 会自动给cookie加上一个sha256的签名, 防止篡改和伪造 Cookie 。 // autoCommit: 默认 true, 自动将 session 及 sessionid 提交至 header 返回给客户端。 当触发 manuallyCommit 时失效。 // overwrite: 默认 true, 是否允许重写。 // httpOnly: 默认 true, 防止XSS攻击, 防止恶意脚本代码劫持 session。 // rolling: 默认 false, 每次响应刷新 session 有效期。 // renew: 默认 false, 在 session 过期时刷新有效期。 // secure: 默认 false, 只在 https 中传输。 // sameSite: 默认 null, 不设置 // store: new sessionStore(redis)，外部存储 &#125;; // logger app.use(async (ctx, next) => &#123; await next(); // 响应时间 const rt = ctx.response.get('X-Response-Time'); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`); &#125;); // x-response-time app.use(async (ctx, next) => &#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`); &#125;); app.use(session(sessionConfig, app)); app.use(bodyParser()) app.use(router.routes()) router.get('/', async (ctx) => &#123; ctx.set(&#123; 'Content-Type': 'text/html' &#125;); ctx.body = fs.readFileSync('./index.html'); &#125;) // 当用户登录时，走这里 router.post('/login', async (ctx) => &#123; const postData = ctx.request.body // 获取用户的提交数据 if (ctx.session.usr) &#123; ctx.body = `欢迎, $&#123;ctx.session.usr&#125;`; &#125; else &#123; ctx.session = postData; ctx.body = '您第一次登录系统'; &#125; &#125;) app.listen(4000, () => &#123; console.log('server is running, port is 4000') &#125;) log4js(日志处理) log4js const log4js = require(\"log4js\"); const logger = log4js.getLogger(); logger.level = \"debug\"; logger.debug(\"Some debug messages\"); 参考 koa官网文档 《Koa开发 入门、进阶与实战》 《Node.js12 实战》 《狼叔卷2》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://example.com/tags/Koa/"}]},{"title":"Node 知识梳理（一）","slug":"front_end/node-base","date":"2022-01-05T22:15:33.000Z","updated":"2022-07-08T14:22:02.526Z","comments":true,"path":"2022/01/06/front_end/node-base/","link":"","permalink":"http://example.com/2022/01/06/front_end/node-base/","excerpt":"","text":"Node 是一个基于谷歌V8引擎的一个JavaScript运行环境（runtime运行时），是服务端的运行环境。 Node 的特点是事件驱动、非阻塞式 I&#x2F;O（input&#x2F;output）、单线程。触发一次事件，执行回调，是事件驱动的一种体现。 Node的使用场景 I&#x2F;O 密集型场景 提供http接口，组装数据 RPC服务，RPC（Remote Procedure Call远程过程调用），RPC服务也是采用的TCP，出名的RPC服务有Google的gRPC、阿里的Dubble 基础工具：构建工具（webpack、vite）、搭建脚手架（cra、vue-cli、umi）等 BFF：接口聚合、转发 Serverless（无服务器架构）：函数即服务，写一个函数就可以实现一个 API 接口给到前端 Microservices（微服务）：小型服务、以独立进程运行、可以使用不同语言 Node.js 架构（node底层原理） Node.js内置模块（标准库）： http、fs、buffer、path、stream。 Node bindings（桥梁）：是JavaScript与 C++ 连接的桥梁，对底层模块进行封装，为内置模块的提供 API 接口。 Node底层模块 V8：Google开源的高性能JavaScript引擎，使用 C++ 开发，并且应用于谷歌浏览器 Libuv：提供Event Loop 事件循环和线程池，提供事件驱动的 I&#x2F;O 库。它是使用 C 和 C++ 语言为 Node.js 所开发的，同时也是 I&#x2F;O 操作的核心部分，例如读取文件和 OS 交互（几乎所有和操作系统打交道的部分离不开libuv的支持） C-ares（异步 DNS 解析库） Low-Level Components：提供了http 解析、OpenSSL、数据压缩（zlib）等功能。 Node EventLoop（事件循环）node中的事件循环的顺序：外部输入数据(incoming) –&gt; 轮询阶段(poll) –&gt; 检查阶段(check)–&gt; 关闭事件回调阶段(close callbacks) –&gt; 定时器检测阶段(timers) –&gt; I&#x2F;O事件回调阶段(I&#x2F;O callbacks) –&gt; 闲置阶段(idle, prepare) –&gt; 轮询阶段(按照该顺序反复运行) 每个阶段都有一个先入先出的队列，这个队列存有要执行的回调函数 ┌───────────────────────────┐ ┌─>│ timers │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ I/O callbacks │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ │ │ idle, prepare │ │ └─────────────┬─────────────┘ ┌───────────────┐ │ ┌─────────────┴─────────────┐ │ incoming: │ │ │ poll │&lt;─────┤ connections, │ │ └─────────────┬─────────────┘ │ data, etc. │ │ ┌─────────────┴─────────────┐ └───────────────┘ │ │ check │ │ └─────────────┬─────────────┘ │ ┌─────────────┴─────────────┐ └──┤ close callbacks │ └───────────────────────────┘ Node事件循环各阶段概述绝大部分异步任务都是在timers、poll、check这3个阶段处理的。 timers 这个阶段执行 setTimeout() 和 setInterval() 的回调，并且是由 poll 阶段控制的。 在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行，如果操作系统很忙，那么计时器的回调函数就会被推迟执行 I&#x2F;O callbacks 处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调（执行一些系统操作的回调函数） 闲置阶段：idle（空闲），prepare 仅在内部使用。 poll（轮询阶段）：处理大部分的事件，如看看有没有文件可以读，有没有请求可以处理，检查一下最近的计时器，看看有没有需要过会儿去执行的 callback。poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情 回到 timer 阶段执行回调 执行 I&#x2F;O 回调 并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 check（检查） 执行 setImmediate() 的回调 close callbacks 执行 socket 的 close 事件回调，例如：socket.on(&#39;close&#39;, ...)，如果队列是空的，则跳过 Node 不会一直循环循环，如果发现没什么事儿做，就会停留在 poll（轮询）阶段，大部分事件都在 poll 阶段被处理，如文件、网络请求等 进程和线程 进程 进程可以说是计算机系统进行资源分配和调度的基本单位，启动一个服务、运行一个应用，就是开一个进程，进程是线程的容器。 例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程。在任务管理器查看任务进程，Nodejs JavaScript Runtime 一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。 同一块代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不相互影响的。 线程 线程是属于进程的，进程可以调用线程去执行一些子任务，一个进程是可以拥有多个线程的。 同一进程中的多条线程可以共享该进程中的全部系统资源。 同一进程中的多个线程有各自的调用栈（call stack），本地存储（thread-local storage)等。 线程可以分为单线程（JavaScript）和多线程（Java）。 单线程 单线程就是一个进程只开一个线程，Javascript 就是属于单线程，程序顺序执行，前面一个执行完之后，后面才可以执行。 在使用单线程编码时不要有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理，适当地使用异步操作。 多线程 多线程就是，一个进程可以开启多线程，Java 就是多线程编程语言的一种，可以有效避免代码阻塞导致的后续请求无法处理。 多线程创建新的线程来切换开销，由于每创建一个线程就会占用一定的内存，当应用程序并发大了之后，内存将会很快耗尽。 Node模块机制 Node.js 模块采用Commonjs规范，Node.js的系统模块采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到 binding_cache缓存中。 在 Node.js 中模块加载一般会经历 3 个步骤，路径分析、文件定位、编译执行。按照模块的分类，按照以下顺序进行优先加载： 如果有 ./从当前目录查找，相对路径文件模块 如果没有 ./，先从系统模块，再从node_modules下查找 （nodejs模块系统） 系统缓存：模块被执行之后会进行缓存，首先是先进行缓存加载，判断缓存中是否有值（require.cache查看已缓存的模块，返回值为对象）。因为 Node.js 默认先从缓存中加载模块，一个模块被加载一次之后，就会在缓存中维持一个副本，如果遇到重复加载的模块会直接提取缓存中的副本，也就是说在任何时候每个模块都只在缓存中有一个实例。 系统模块：也就是原生模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了 路径分析、文件定位，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。 文件模块（开发者自己编写的模块）：优先加载 .、..、/ 开头的，如果文件没有加上扩展名，会依次按照 .js、.json、.node 进行扩展名补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在，从性能优化的角度来看待，.json、.node最好还是加上文件的扩展名。 目录做为模块：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个包来处理，Node 这块采用了 Commonjs 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 (&quot;main&quot;: &quot;lib/index.js&quot;) 描述的入口文件进行加载，也没加载到，则会抛出默认错误: Error: Cannot find module &#39;lib/index.js&#39; node_modules 目录加载：对于系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录进行查找，直到系统的根目录 Node常用模块 模块名称 功能描述 buffer 实现数据缓冲区，Buffer一般用于处理二进制数据，也可以处理字符编码 child_process （实现多进程任务）创建子进程，实现子进程和主进程之间的通信 cluster 可以简化多进程、并行化程序的开发难度，利用多核CPU 实现并行，轻松构建一个用于负载均衡的集群。著名的pm2模块就使用了cluster实现 console 和浏览里的用法一样，比如console.log、console.dir等 crypto 对OpenSSL里的 HMAC、Cipher、Decipher等算法进行加解密封装，一般用户在进行密码处理时都会用到该模块 dns 域名解析，主要API是 lookup和 resolve events 事件处理，EventEmitter的核心功能就是对事件触发和事件监听器功能进行封装 fs 文件系统模块，主要针对目录、文件进行操作，开发中使用极其广泛 http Node.js里使用多的模块，可以非常构建Web应用服务，搭建HTTP服务端和客户端，是Web框架的底层核心库 http2 下一代HTTP协议，在Node.js 8里是需要通过flag开启的体验功能 https HTTPS实现，是HTTP的安全加强版 process全局对象Node.js 中的进程 process 是一个全局对象，无需 require 直接使用（global.process &#x3D; process），process对象是EventEmitter的实例 process.title：终端上显示的标题 process.version：nodejs的版本号 process.versions：nodejs依赖模块的版本信息 process.env：环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息，还可以往process.env上挂载其他常量。 process.nextTick：表示在事件循环（EventLoop）的下一次循环中调用 callback 回调函数，要注意的是它总会在I&#x2F;O操作（比如查询数据）之前先执行 process.pid：获取当前进程id process.ppid：当前进程对应的父进程 process.cwd()：获取当前进程工作目录 process.argv: 返回当前命令行指令参数，是一个数组，process.argv[2] process.execPath：获取当前进程的这个可执行文件的绝对路径 process.exit([code])：终止当前进程并返回给定的 code，默认是0 process.exitCode：可以自定义退出进程时node shell捕获到的状态码（可以自定义退出进程时node shell捕获到的状态码） process.chdir(directory)：改变进程的当前进程的工作目录（该目录必须已存在），若操作失败则抛出异常 process.platform：获取当前进程运行的操作系统平台 process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 process.moduleLoadList：当前进程已加载的模块列表，nodejs模块系统。NativeModule原生模块 process.config：当前nodejs构建时使用的配置信息，可以辅助定位 process.on(&#39;exit&#39;, callback)：当进程将要退出时触发。 ‘exit’的回调结束后，主进程将不再运行 process.on(&#39;SIGINT&#39;, callback)：捕获当前进程接收到的信号 process.abort()：触发node的abort事件，退出当前进程，执行该函数后，后面的代码不执行。 process.kill(pid, [signal])：结束对应某pid的进程并发送一个信号 进程事件：process.on(&#39;uncaughtException&#39;, cb) 捕获异常信息、process.on(&#39;exit&#39;, cb)进程推出监听 三个标准流：process.stdout 标准输出、process.stdin 标准输入、process.stderr 标准错误输出 process.envprocess.env属性返回一个包含用户环境信息的对象。在node环境中，当我们打印process.env时，发现它并没有NODE_ENV这一个属性。实际上，process.env.NODE_ENV是在package.json的scripts命令中注入的，也就是NODE_ENV并不是node自带的，而是由用户定义的，至于为什么叫NODE_ENV，应该是约定成俗的吧。 child_process（创建子进程）Node.js 提供了 child_process 内置模块，用于创建子进程 child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。 child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。 child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I&#x2F;O 重定向和文件查找这样的行为 child_process.fork()：衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。 path主要作用就是处理文件的目录和路径，在前端项目webpack配置文件中经常用到。 path.join()拼接多个路径片段，还原成完整可用路径 path.join('a/b', 'c', 'index.html'); // a/b/c/index.html path.join('/a/b', 'c', 'index.html'); // /a/b/c/index.html path.join('a/b', 'c', '../', 'index.html'); // a/b/index.html path.resove()返回一个绝对路径 path.resove(); // 获取绝对路径 path.resove(__dirname, 'c', 'index.html'); basename()获取路径中基础名称 path.basename(__filename); // test.js // 传入第二个参数如果匹配会省略后缀，不匹配仍旧返回真实的后缀 path.basename(__filename, '.js'); // test path.basename('/a/b/c'); // c path.basename('/a/b/c/'); // c path.extname()获取路径中的扩展名称 path.extname('/src/index.html'); // .html path.parse()解析路径 const obj = path.parse('/src/index.html'); /** * root: / * dir: /src * base: index.html * ext: .html * name: index */ fs(读取文件)events（事件模块） 在 Node.js 中一个很重要的模块 Events（EventEmitter 事件触发器），EventEmitter 本质上就是观察者模式的实现。net、http、fs、stream、process 等模块，express、koa 框架都依赖了Events。 EventEmitter 对象的事件触发 emit 和监听 on 是同步的，事件的回调是异步的。 在 Node.js 的事件机制中主要有三类角色: 事件(Event)、事件发射器(EventEmitter)、事件监听器(Event Listener)。 Event EventEmitter 提供了 on()、once()、removeListener() 等方法来对事件进行监听移除，可同时注册多个同名的事件。其中once(): 当触发多次相同名称事件，通过 once 添加的侦听器只会执行一次。 EventEmitter 会按照监听器注册的顺序同步地调用所有监听器，所以必须确保事件的排序正确。提前触发未监听的事件，不会报错，并且不会执行监听的回调函数。 // 基本使用 const EventEmitter = require('events').EventEmitter; const emitter = new EventEmitter(); emitter.on(\"起床\", function(time) &#123; console.log(`早上 $&#123;time&#125; 开始起床，新的一天加油！`) &#125;); emitter.emit(\"起床\", \"6:00\"); // 在 Koa 中 new 一个 app 对象，通过 app.emit() 触发一个事件，实现在整个系统中进行传递。 const Koa = require('koa'); const app = new Koa(); app.on(\"koa\", function() &#123; console.log(\"在 Koa 中使用 EventEmitter\"); &#125;); app.emit(\"koa\"); // 通过Object.setPrototypeOf() 来实现的继承 function MyEmitter()&#123; EventEmitter.call(this); &#125; Object.setPrototypeOf(MyEmitter.prototype, EventEmitter.prototype); Object.setPrototypeOf(MyEmitter, EventEmitter); 默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告。 但是，并不是所有的事件都要限制 10 个监听器。 emitter.setMaxListeners() 方法可以为指定的 EventEmitter 实例修改限制。 // 操作最大事件监听个数 // 设置同类型事件监听最大个数 EventEmitter.prototype.setMaxListeners = function (count) &#123; this._count = count; &#125; // 获取同类型事件监听最大个数 EventEmitter.prototype.getMaxListeners = function () &#123; return this._count || EventEmitter.defaultMaxListeners; &#125; error事件当EventEmitter 实例出错时，应该触发error事件。如果没有为error事件注册监听器，则当error事件触发时，会抛出错误、打印堆栈跟踪，并退出Node.js进程。 const EventEmitter = require ('events'); class MyEmitter extends EventEmitter &#123;&#125; const myEmitter = new MyEmitter (); // 模拟触发error事件 myEmitter.emit('error', new Error('错误信息')); // 抛出错误 myEmitter.emit('error', (err) => &#123; console.log(err)) &#125;); Buffer（缓冲区） Buffer 用于读取或操作二进制数据流，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来。 如用于操作网络协议、数据库、图片和文件I&#x2F;O 等一些需要大量二进制数据的场景，专门存放二进制数据的缓存区。 Buffer 作为存在于全局对象上，使用时无需 require 引入模块即可使用。 Buffer 在创建时大小已经被确定且是无法调整的，在内存分配这块 Buffer 是由 C++ 层面提供而不是 V8。 Buffer应用场景Buffer的应用场景有以下几种。 在使用net或 http模块来接收网络数据时，可用 Buffer作为数据结构进行传输，即 data事件的参数。 用于大文件的读取和写入。以前fs读取的内容是string，后来都改用Buffer，在大文件读取上，性能和内存有明显优势。 用于字符转码、进制转换。Unicode 编码虽然能满足绝大部分场景，但有时候还是不够的，由于Node.js内置的转换编码并不支持GBK，因此如果要处理编码为GBK的文档，就需要iconv和 iconv-lite来补充一部分，string decoder模块提供了一个 API，用于把 Buffer对象解码成字符串，但会保留编码过的多字节UTF-8与UTF-16字符。 用作数据结构，处理二进制数据，也可以处理字符编码。 Buffer与字符串的传输速度buffer比string快。在 HTTP 传输中传输的是二进制数据，上面例子中的 &#x2F;string 接口直接返回的字符串，这时候 HTTP 在传输之前会先将字符串转换为 Buffer 类型，以二进制数据传输，通过流（Stream）的方式一点点返回到客户端。但是直接返回 Buffer 类型，则少了每次的转换操作，对于性能也是有提升的。在一些 Web 应用中，对于静态数据可以预先转为 Buffer 进行传输，可以有效减少 CPU 的重复使用（重复的字符串转 Buffer 操作）。 buffer模块与Buffer的关系Buffer是全局global上的一个引用，指向的其实是buffer.Buffer const buffer = require('buffer'); console.log(buffer.Buffer === Buffer); //true 创建Buffer Buffer.from()，第一个参数是内容，第二个是按什么格式转。Buffer.from不支持传入数字，传入数字可以采用传入数组的，存入的一组数据最好是：全部落在0到255区间 或者全部落在-128到127，这是因为不同的数字读取时应该调用不同的方法。Buffer.from(1234); // throw new errors.TypeError const buf = Buffer.from([1, 2, 3, 4]); console.log(buf); // &lt;Buffer 01 02 03 04> 显示的是16进制的 Buffer.alloc()，第一个参数是长度，第二个具体buffer内容const b2 = Buffer.alloc(10); // 创建一个大小为 10 个字节的缓冲区 console.log(b2); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00> // 尝试分配一个大小为 2048 的 Buffer 对象 Buffer.alloc(2 * 1024) // 打印buffer，将每个字符串对应的ASCII码的十进制，转化为16进制的，比如 H 'H'.charCodeAt()// ASCII码：'72' 'H'.charCodeAt().toString(16) // '72'的16进制 '48' Buffer 字符编码通过使用字符编码，可实现 Buffer 实例与 JavaScript 字符串之间的相互转换。如果不传递 encoding 默认按照 UTF-8 格式转换存储 &#39;ascii&#39;仅适用于 7 位 ASCII 数据，此编码速度很快，如果设置则会剥离高位。 &#39;utf8&#39;多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8。 &#39;base64&#39;Base64 编码。。 &#39;binary&#39;一种将 Buffer 编码成单字节编码字符串的方法。 &#39;hex&#39;将每个字节编码成两个十六进制的字符。const buf = Buffer.from('hello world', 'utf8'); console.log(buf.toString('hex')); // 68656c6c6f20776f726c64 console.log(buf.toString('utf8')); // hello world 字符串与 Buffer 类型互转字符串转 Buffer（将字符串数据写入缓冲区）const b3 = Buffer.from('123456789', 'utf8'); console.log(b3) // &lt;Buffer 31 32 33 34 35 36 37 38 39> console.log(b3.length) // 9 Buffer 转换为字符串（从缓冲区读取string数据）使用 buf.toString([encoding], [start], [end]) 方法，默认编码仍为 UTF-8 const b3 = Buffer.from('123456789', 'utf8'); console.log(b3.toString()) // 123456789 console.log(b3.toString('utf8', 0, 5)) // 1234 将buffer转换成JSON对象buf.toJSON()，返回一个JSON对象。当字符串化一个buffer实例是，JSON.stringify()会隐式地调用该toJSON()。 const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); const json = JSON.stringify(buf); // 输出: &#123; \"type\": \"Buffer\", \"data\": [ 1,2,3,4,5] &#125; console.log(json); const copy = JSON.parse(json,(key, value) =>&#123; return value &amp;&amp; value.type === 'Buffer' ? Buffer.from(value.data) :value; &#125;); // 输出:&lt;Buffer 01 02 03 04 05> console.log(copy); buffer缓冲区的合并Buffer.concat(list[, totalLength]) list &lt;Buffer[]&gt; 要连接的 Buffer。 totalLength &lt;integer&gt; 连接时list中Buffer 实例的总长度，如果未提供 totalLength，则从 list 中的 Buffer 实例通过相加其长度来计算 返回: &lt;Buffer&gt; const buf1 = Buffer.alloc(10); const buf2 = Buffer.alloc(14); const buf3 = Buffer.alloc(18); const totalLength = buf1.length + buf2.length + buf3.length; console.log(totalLength); // 打印: 42 const bufA = Buffer.concat([buf1, buf2, buf3], totalLength); console.log(bufA); // 打印: &lt;Buffer 00 00 00 00 ...> console.log(bufA.length); // 打印: 42 缓冲区的拷贝Buffer.copy(buf) 缓冲区的比较Buffer.compare(buf1, buf2) 缓冲区的裁剪 buf.slice([start[, end]]) 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切 转换过程中为什么出现乱码？字符串中有中文，一个中文在UTF-8下占用3个字节。转成buffer后，再从buffer转成字符串时，如果字符被截断则容易出现乱码。 const buf = Buffer.from('前端开发'); console.log(buf); // &lt;Buffer e5 89 8d e7 ab af e5 bc 80 e5 8f 91> console.log(buf.length); // 12，一个中文在UTF-8下占用3个字节 console.log(buf.toString('UTF-8', 0, 8)); // 前端� Stream（流）Stream在 Node.js 中继承自EventEmitter，它有4种基本流类型。 Readable: 可读操作类型，可以产出数据，这些数据可以被传送到其他流中，只需要调用pipe方法即可。 Writable: 可写操作类型，只能流进不能流出。 Duplex: 可读可写操作类型（net.Socket）。 Transform: 转换类型，可以写入数据，然后读出结果。 node.js创建的流都是运作在字符串和buffer上的。Stream作为读写方法是最好的。可写流和可读流都会在内部的缓冲区中存储数据，可以分别使用 writable.writableBuffer 或 readable.readableBuffer 来获取。 流中的缓冲区 可写流和可读流都会在内部的缓冲区中存储数据，可以 writable.writableBuffer 或 readable.readableBuffer 来获取。 可缓冲的数据大小取决于传入流构造函数的 highWaterMark 选项。对于普通的流，highWaterMark 指定了字节的总数。对于对象模式的流，highWaterMark 指定了对象的总数。 当调用 stream.push(chunk) 时，数据会缓冲在可读流中。如果流的消费者没有调用 stream.read()，则数据会保留在内部队列中直到被消费。 一旦内部的可读缓冲的总大小达到 highWaterMark 指定的或值时，流会停止从底层资源读取数据，直到当前缓冲的数据被消贺（也就是说，流会停止调用内部的用于填充可读缓冲的 readable._read())。 当调用 writable.write(chunk）时，数据会被缓冲在可写流中。当内部的缓冲区的总大小小于 highWaterMark 设置的阈值时，调用 writable.write() 会返回true。一旦内部缓冲的大小达到或超过 highWaterMark 时，则会返回false。 因为双工流和转换流都是可读又可写的，所以它们各自维护着两个相互独立的内部缓冲区用于读取和写入，这使得它们在维护数据流时，读取和写入两边可以各自独立地运作。例如，net.Socket实例是双工流，它的可读端可以消费从socket接收的数据，而可写端则可以将数据写入到socket。因为数据写入到socket的速度可能比接收数据的速度快或慢，所以在读写两端独立地进行操作（或缓冲）就显得很重要了。 const fs = require('fs'); var source = fs.readFileSync('/path/to/source', (encoding: 'utf8')); fs.writeFileSync('/path/to/dest', source); // 等价于 // pipe是用来传递 上一个流的输出 并将其作为 下一个流的输入的链式方法。 fs.createReadstream('/path/to/source').pipe(fs.createWriteStream('/path/to/dest')); 可读流Node. js可读流是对提供数据的来源的一种抽象。所有可读流都实现了stream.Readable类定义的接口。可读流常见的例子包括客户端的HTTP响应、服务器的HTTP请求、fs的读取流、zlib流、crypto流、TCP socket、子进程 stdout 与 stderr、process.stdin。 stream.Readable类事件 close 事件close 事件在流被关闭时触发。表明不会再触发其他事件，也不会再发生操作。不是所有可读流都会触发close事件。如果使用 emitClose 选项创建可读流，则它将始终发出close事件。 data 事件data事件是在流将数据块传送给消费者后触发。对于非对象模式的流，数据块可以是字符串或 Buffer。对于对象模式的流，数据块可以是除了 null 的任何 JavaScript 值。当调用 readable.pipe()、readable.resume() 或绑定监听器到 data 事件时，流会转换到流动模式。当调用 readable.read() 且有数据块返回时，也会触发data 事件。如果使用 readable.setEncoding() 为流指定了默认的字符编码，则监听器回调传入的数据为字符串，否则传入的数据为 Buffer。 end 事件end 事件只有在数据被完全消费掉后才会触发。要想触发该事件，可以将流转换到流动模式，或反复调用 stream.read() 直到数据被消费完。 error 事件error事件通常是在当流因底层内部出错而不能产生数据，或推送无效的数据块时触发，监听器回调将传递一个 Error对象。 pause 事件调用 stream.pause() 并且 readsFlowing 不为 false 时，会发出 pause 事件。 readable 事件readable 事件在当流中有数据可供读取时触发。 const readable = getReadableStreamSomehow(); readable.on('readable', function()&#123; let data; // 有数据可读 while(data = this.read())&#123; console.log(data); &#125; &#125;) 当到达流数据的尽头时，readable 事件也会触发，但是在 end 事件之前触发。readable 事件表明流有新的动态，要么有新的数据，要么到达流的尽头。对于前者，stream.read() 会返回可用的数据。对于后者，stream.read() 会返回null。 stream.Readable类方法1.destroyreadable.destroy([error])方法用于销毁流，并触发error事件和close事件。调用后，可读流将释放所有的内部资源，且忽视后续的 push() 调用。实现流时不应该重写这个方法，而是重写 readable._destroy()。 2.isPausedreadable.isPaused() 方法用于返回可读流当前的操作状态。主要用于 readable.pipe() 底层的机制，大多数情况下无须直接使用该方法。 pause 与 resumereadable.pause() 方法使流动模式的流停止触发data事件，并切换到流动模式。任何可用的数据都会保留在内部缓存中。相对的，readable.resume() 将被暂停的可读流恢复触发data事件，并将流切换到流动模式，在readable事件使用不生效。 pipereadable.pipe(destination[, options])方法用于绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。 将可读流的所有数据通过管道推送到write-data.txt文件：const fs = require('fs'); const readable = fs.createReadStream('data.txt'); const writable = fs.createWriteStream('write-data.txt'); // readable的所有数据都推送到'write-data.txt' readable.pipe(writable); 可以在单个可读流上绑定多个可写流readable.pipe(writable1).pipe(writable2); 默认情况下，当来源可读流触发end事件时，目标可写流也会调用stream.end()结束写入。若要禁用这种默认行为，end选项应设为 false，这样目标流就会保持打开。reader.pipe (writer, &#123; end: false &#125;); reader.on ('end', () => &#123; writer.end ('结束'); &#125; 如果可读流发生错误，目标可写流不会自动关闭，需要手动关闭所有流以避免内存泄漏。process.stderr 和 process.stdout 可写的流在 Node.js 进程退出之前永远不会关闭。 read readable.read([size])方法用于从内部缓冲拉取并返回数据。其中，size指定要读取的数据的字节数。如果没有指定size参数，则返回内部缓冲中的所有数据。该方法如果没有可读的数据，则返回null。默认情况下，readable.read()返回的数据是Buffer对象，除非使用readable.setEncoding()指定字符编码或流处于对象模式。如果可读的数据不足size个字节，则返回内部缓冲剩余的数据，如果流已经结束则返回null。 readable.read()应该只对处于暂停模式的可读流调用。在流动模式中，readable.read()会自动调用直到内部缓冲的数据完全耗尽。 如果readable.read()返回一个数据块，则data事件也会触发。 end事件触发后再调用stream.read([size])会返回null，不会抛出错误。 const fs = require('fs'); const readable = fs.createReadStream('data.txt'); // 设置字符编码 readable.setEncoding('utf-8'); // 读取数据 readable.on('readable', () => &#123; let chunk; while (null !== (chunk = readable.read(10))) &#123; console.log(`接收到 $&#123;chunk.length&#125; 字节的数据`); console.log(`接收到的数据是： $&#123;chunk&#125;`); &#125; &#125;); readable.on('end', () => &#123; console.log('结束'); &#125;); 上述示例中，使用readable.read()处理数据时，while循环是必需的。只有在readable.read()返回null之后，才会发出readable事件; readable.setEncoding()用于设置字符编码。默认情况下没有设置字符编码，流数据返回的是 Buffer对象。如果设置了字符编码，则流数据返回指定编码的字符串。例如，本例中调用readable.setEncoding(&#39;utf-8&#39;)会将数据解析为UTF-8数据，并返回字符串。如果调用readable.setEncoding(hex)则会将数据编码成十六进制字符串。 readable.unpipe([destination])解绑之前使用 stream.pipe() 绑定的可写流。如果没有指定目标可写流，则解绑所有管道，如果指定了目标可写流但它没有建立管道，则不起作用。const fs = require('fs'); const readable = fs.createReadStream('data.txt'); const writable = fs.createWriteStream('write-data.txt'); // readable的所有数据都推送到'write-data.txt' readable.pipe(writable); setTimeout(() => &#123; console.log('停止写入数据'); readable.unpipe(writable); console.log('手动关闭文件流'); writable.end(); &#125;, 3); 两种读取模式流动模式或者暂停模式 可读流运作于流动模式(flowing)或暂停模式(paused)两种模式之一。 在流动模式中，数据自动从底层系统读取，并通过EventEmitter 接口的事件尽口能快地被提供给应用程序。 在暂停模式中，必须显式调用stream.read()读取数据块。所有可读流都开始于暂停模式，可以通过以下方式切换到流动模式。 添加data事件句柄。 调用stream.resume()。·调用stream.pipe()。可读流可以通过以下方式切换回暂停模式。 如果没有管道目标，则调用stream.pause()。 如果有管道目标，则移除所有管道目标。调用stream.unpipe()可以移除多个管道目标。 只有提供了消费或忽略数据的机制后，可读流才会产生数据。如果消费的机制被禁用或移除，则可读流会停止产生数据。 为了向后兼容，移除data事件句柄不会自动地暂停流。如果有管道目标，一旦目标变为drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。 如果可读流切换到流动模式，且没有可用的“消费者”来处理数据，则数据将会丢失。例如，当调用readable.resume() 时，没有监听data事件或data事件句柄已移除。 添加readable事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。如果 readable 事件句柄被移除，且存在data事件句柄，则流会再次开始流动。 可写流可写流是对数据要被写入的目的地的一种抽象。所有可写流都实现了stream.Writable类定义的接口。可写流常见的例子包括客户端的HTTP请求、服务器的HTTP响应、fs的写入流、zlib流、crypto流、TCP socket、子进程stdin、process.stdout、process.stderr。上面的一些例子事实上是实现了可写流接口的双工流。 stream.Writable类事件stream.Writable类定义了如下事件。 close事件当流及其任何底层资源（如文件描述符）已关闭时，将发出close事件。该事件表明不会发出更多事件，也不会进一步计算。如果使用emitClose选项创建可写流，它将始终发出close事件。 drain事件如果对stream.write(chunk)的调用返回false，则在适合继续将数据写入流时将发出drain事件。 error事件如果在写入管道数据时发生错误，则会发出error事件。调用时，监听器回调会传递一个Error参数。发出error事件时，流不会关闭。 finish事件调用stream.end()方法后会发出finish事件，并且所有数据都已刷新到底层系统。 const fs = require('fs'); const writable = fs.createWriteStream('write-data.txt'); for (let i = 0; i &lt; 10; i++) &#123; writable.write(`写入 #$&#123;i&#125;!\\n`); &#125; writable.end('写入结尾\\n'); writable.on('finish', () => &#123; console.log('写入已完成'); &#125;) pipe事件在可读流上调用stream.pipe()方法时会发出pipe事件，并将此可写流添加到其目标集。 unpipe事件当在可读流上调用stream.unpipe()时触发。当可读流通过管道流向可写流发生错误时，也会触发unpipe事件。 stream.Writable类方法 corkwritable.cork()方法用于强制把所有写入的数据都缓冲到内存中。当调用stream.uncork()或stream.end()时，缓冲的数据才会被输出。 当写入大量小块数据到流时，内部缓冲可能失效，从而导致性能下降，writable.cork()主要用于避免这种情况。对于这种情况，实现了writable._writev()的流可以用更优的方式对写入的数据进行缓冲。 destroywritable.destroy([error])方法用于销毁流。在调用该方法之后，可写流已结束，随后对write()或end()的调用都将导致ERR_STREAM_DESTROYED错误。如果数据在关闭之前应该刷新，则应使用end()方法而不是destroy()方法，或者在销毁流之前等待drain事件。实现者不应该重写此方法，而是实现writable._destroy()。 end调用writable.end([chunk][, encoding][, callback])方法表示不再将数据写入Writable。该方法的参数如下。 chunk&lt;string&gt;|&lt;Buffer&gt;|&lt;Uint8Array&gt;/&lt;any&gt;:要 写入的可选数据。对于不在对象模式下运行的流，块必须是字符串、Buffer 或 Uint8Array。对于对象模式流，块可以是除null 之外的任何JavaScript 值。 encoding&lt;string&gt;: 如果设置了编码，则 chunk 是一个字符串。 callback&lt;Function&gt;: 流完成时的可选回调。 调用writable.end()方法表示不再将数据写入Writable。可选的块和编码参数允许在关闭流之前立即写入最后一个额外的数据块。如果提供，则附加可选回调函数作为finish事件的监听器。 调用stream.end()后调用stream.write()方法将引发错误。 setDefaultEncodingwritable.setDefaultEncoding(encoding)为可写流设置默认的编码。 uncorkwritable.uncork()方法用于将调用stream.cork()后缓冲的所有数据输出到目标。当使用writable.cork() 和 writable.uncork() 来管理流的写入缓冲时，建议使用 process.nextTick() 来延迟调用 writable.uncork()。通过这种方式，可以对单个Node.js事件循环中调用的所有 writable.write() 进行批处理。 stream.cork (); stream.write ('一些'); stream.write('数据'); process.nextTick(()=> stream.uncork()); 如果一个流上多次调用 writable.cork()，则必须调用同样次数的 writable.uncork() 才能输出缓冲的数据。 stream.cork(); stream.write ('一些' ); stream.cork(); stream.write('数据'); process.nextTick(()=> &#123; stream.uncork (); //数据不会被输出,直到第二次调用uncork() stream.uncork(); &#125;); writewritable.write(chunk[, encoding][, callback]) 写入数据到流，并在数据被完全处理之后调用callback。如果发生错误，则callback可能被调用也可能不被调用。为了可靠地检测错误，可以为error事件添加监听器。该方法的参数如下。 chunk&lt;string&gt;|&lt;Buffer&gt;|&lt;Uint8Array&gt;|&lt;any&gt;: 要写入的数据。对于非对象模式的流，chunk 必须是字符串、Buffer 或 Uint8Array。对于对象模式的流，chunk 可以除null外的是任何 JavaScript 值。 encoding&lt;string&gt;: 如果chunk是字符串，则指定字符编码。 callback&lt;Function&gt;: 当数据块被输出到目标后的回调函数。 writable.write(): 写入数据到流，并在数据被完全处理之后调用callback。如果发生错误，则callback可能被调用也可能不被调用。为了可靠地检测错误，可以为error事件添加监听器。 在接收了chunk后，如果内部的缓冲小于创建流时配置的highWaterMark, 则返回true。如果返回false，则应该停止向流写入数据，直到drain事件被触发。 当流还未被排空时，调用write()会缓冲chunk，并返回false。一旦所有当前缓冲的数据块都被排空了(被操作系统接收并传输)，则触发drain事件。建议一旦write()返回false，则不再写入任何数据块，直到drain事件被触发。当流还未被排空时，也是可以调用write()， Node.js 会缓冲所有被写入的数据块，直到达到最大内存占用，这时它会无条件中止，甚至在它中止之前，高内存占用将会导致垃圾回收器的性能变差和RSS变高(即使内存不再需要，通常也不会被释放回系统)。如果远程的另一端没有读取数据，TCP的socket 可能永远也不会排空，所以写入到一一个不会排空的socket可能会导致产生远程可利用的漏洞。 对于Transform，写入数据到一一个不会排空的流尤其成问题，因为Transform流默认会被暂停，直到它们被pipe或者添加了 data 或readable 事件句柄。 如果要被写入的数据可以根据需要生成或取得，建议将逻辑封装为一一个可读流并且使用stream.pipe()。 如果要优先调用 write()，则可以使用 drain 事件来防止背压与避免内存问题。 双工流与转换流双工流（Duplex）是同时实现了Readable和 Writable接口的流。双工括TCP socket、zlib流、crypto流。转换流（Transform）是一种双工流，但它的输出与输入是相关联的。与双工流一样，转换流也同时实现了 Readable 和 Writable 接口。转换流的例子包括 zlib流和 crypto 流。 实现双工流双工流同时实现了可读流和可写流，如TCP socket连接。因为JavaScript不支持多重继承，所以使用stream.Duplex类来实现双工流（而不是使用stream.Readable类和stream.Writable类)。stream.Duplex类的原型继承自stream.Readable和寄生自stream.Writable，但是instanceof对这两个基础类都可用，因为重写了 stream.Writable 的Symbol.hasInstance。自定义的双工流必须调用new stream.Duplex([options])构造函数并实现 readable._read() 和 writable._write() 方法。以下是示例。 const &#123; Duplex &#125; = require('stream'); class MyDuplex extends Duplex &#123; constructor(options)&#123; super(options); // ... &#125; &#125; 双工流的例子封装了一个可读可写的底层资源对象 const &#123; Duplex &#125; = require('stream'); const kSource = Symbol('source'); class MyDuplex extends Duplex &#123; constructor(source, options) &#123; super(options); this[kSource] = source; &#125; _write(chunk, encoding, callback) &#123; // 底层资源只处理字符串。 if (Buffer.isBuffer(chunk))&#123; chunk = chunk.toString(); &#125; this[kSource].writeSomeData(chunk); callback(); &#125; _read(size) &#123; this[kSource].fetchSomeData(size, (data, encoding) => &#123; this.push(Buffer.from(data, encoding)); &#125;); &#125; &#125; net模块在nodejs中，net模块用于创建基于流的TCP或IPC的服务器与客户端。net主要包含两个部分： net.Server: TCP Server，内部通过socket来实现与客户端的通信。 net.Socket: TCP&#x2F;本地socket的Node版实现，它实现了全双工的stream接口，可以用来构建TCP客户端。 const net = require('net'); 创建TCP服务器 net.Server类创建TCP或IPC服务器 net.Server支持如下事件： listening事件: 当服务被绑定后调用server.listen()方法后触发。 connection事件: 当一个新的connection建立的时候触发，回调参数为socket连接对象。 close事件：当TCP服务器关闭的时候触发，回调函数没有参数。 error事件: 当TCP服务器出现错误的时候触发，回调函数的参数为err对象。例如，监听了已经被占用的端口号。 创建TCP服务器示例const net = require('net'); const server = net.createServer((socket) => &#123; socket.end('goodbye\\n'); &#125;).on('error', (err) => &#123; // 处理错误 throw err; &#125;); server.on('close', () => &#123; console.log('服务器接收到close事件'); &#125;) // socket对象，对象可以与客户端进行通信 server.on('connection', (socket) => &#123; console.log('服务器接收到connection事件') &#125;) server.on('listening', () => &#123; console.log('服务器接收到listening事件') &#125;) // 随机获取未绑定的端口 server.listen(() => &#123; console.log('服务器启动，占用端口：', server.address()); &#125;); 当创建了一个TCP服务器后，可以通过 server.address()方法来查看这个TCP服务器监听的地址，并返回一个JSON对象。这个对象的属性有: port: TCP服务器监听的端口号。 family: 说明TCP服务器监听的地址是IPv6还是IPv4。 address: TCP服务器监听的地址。/** * 查看服务器监听的地址 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP服务器 */ var server = net.createServer(function (socket) &#123; console.log('someone connects'); &#125;) /* 获取地址信息 */ server.listen(8000, function () &#123; /* 获取地址信息，得到的是一个json &#123; address: '::', family: 'IPv6', port: 8000 &#125; */ var address = server.address(); /* TCP服务器监听的端口号 */ console.log(\"the port of server is\" + address.port); /* TCP服务器监听的地址 */ console.log(\"the address of server is\" + address.address); /* 说明TCP服务器监听的地址是 IPv6 还是 IPv4 */ console.log(\"the family of server is\" + address.family); &#125;) 创建一个TCP服务器后，可以通过server.getConnections()方法获取连接这个TCP服务器的客户端数量。除此之外，也可以通过maxConnections属性来设置这个服务器的最大连接数量，当连接数量超过最大值时，服务器将拒绝新的连接，例如:/** * 连接服务器的客户端数量 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP服务器 */ var server = net.createServer(function (socket) &#123; console.log('someone connects'); /* 设置最大连接数量 */ server.maxConnections = 3; server.getConnections(function (err, count) &#123; console.log(\"the count of client is \" + count); &#125;) &#125;) /* 获取监听端口 */ server.listen(8000, function () &#123; console.log(\"Creat server on http://127.0.0.1:8000/\"); &#125;) 服务器和客户端之间的通信：socket对象可以用来获取客户端发出的流数据，每次接收到数据的时候触发data事件，通过监听这个事件就可以在回调函数中获取客户端发送的数据。/** * 连接服务器的客户端数量 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP服务器 */ var server = net.createServer(function(socket)&#123; /* 获取地址信息 */ var address = server.address(); var message = \"the server address is\"+JSON.stringify(address); /* 发送数据 */ socket.write(message,function()&#123; var writeSize = socket.bytesWritten; console.log(message + \"has send\"); console.log(\"the size of message is\"+writeSize); &#125;) /* 监听data事件，每次接收到数据的时候触发data事件 */ socket.on('data',function(data)&#123; console.log(data.toString()); var readSize = socket.bytesRead; console.log(\"the size of data is\"+readSize); &#125;) &#125;) /* 获取地址信息 */ server.listen(8000,function()&#123; console.log(\"Creat server on http://127.0.0.1:8000/\"); &#125;) server.listen监听链接listen()方法是异步的。当服务器开始监听时，会触发listening事件。最后一个参数callback将被添加为listening事件的监听器。 当且仅当在第一次调用server.listen()或调用server.close()期间出现错误时，才能再次调用server.listen()方法。 监听时最常见的错误之一是EADDRINUSE, 这说明该地址正被另一个服务器所使用。处理此问题的一种方法是在一段时间后重试。 server.on('error', function(e)&#123; if(e.code === 'EADDRINUSE')&#123; console.log('地址正被使用，重试中。。。') setTimeout(()=>&#123; server.close(); server.listen(PORT, HOST) &#125;, 1000) &#125; &#125;) server.listen(options[, callback])方法中的options参数支持如下属性 port&lt;number&gt;: 端口号。 host&lt;string&gt;: 主机。 path&lt;string&gt;: 如果指定了port，将被忽略。 backlog&lt;number&gt;。如果exclusive为 false，则集群将使用相同的底层句柄，从而允许共享连接处理。当exclusive为 true时，不共享句柄，并且尝试端口共享会导致错误。监听专用端口的示例如下。 exclusive&lt;boolean&gt;: 默认值是false。 readableAll&lt;boolean&gt;: 对于IPC服务器，使管道对所有用户都可读，默认值是false。 writableAll&lt;boolean&gt;: 对于IPC服务器，管道可以为所有用户写入，默认值是false。 创建Socket对象发送和接受数据const net = require('net'); const server = net.createServer(); server.on('error', (err) => &#123; // 处理错误 throw err; &#125;); server.on('close', () => &#123; console.log('服务器接收到close事件'); &#125;) server.on('connection', (socket) => &#123; console.log('服务器接收到connection事件'); socket.setEncoding('utf8'); socket.write('welcome!'); // 发送数据 socket.on('data', (data) => &#123; console.log('服务器接收到的数据为：' + data); // 如果收到c字符，就终止连接 if (data == 'c') &#123; socket.write('bye!'); socket.end(); // 关闭socket // 如果收到k字符，就关闭服务器 &#125; else if (data == 'k') &#123; socket.write('bye!'); socket.end(); // 关闭socket server.close();// 关闭服务器 &#125; else &#123; socket.write(data); &#125; &#125;) &#125;) server.on('listening', () => &#123; console.log('服务器接收到listening事件'); &#125;) // 绑定到端口 server.listen(8888, () => &#123; console.log('服务器启动，端口：8888'); &#125;); 在上述示例中，socket.write() 方法用于将数据写入 Socket发送; socket通过data事件，可以监听来自客户端写入的数据(接收)。在上述示例中，会将接收到的数据，再通过 socket.write() 方法发送回客户端。 关闭TCP服务器：TCP服务器通过 socket.end() 终止客户端的连接，也可以通过 server.close() 方法来将整个TCP服务器关闭。当TCP服务器关闭时，会监听到close事件。 构建TCP客户端可以用net.Socket构建TCP客户端，实现TCP客户端和TCP服务器的通信。 /** * 构建TCP客户端 */ /* 引入net模块 */ var net = require(\"net\"); /* 创建TCP客户端 */ var client = net.Socket(); /* 设置连接的服务器 创建完socket对象后，使用socket对象的connect方法就可以连接一个TCP服务器。*/ client.connect(8000, '127.0.0.1', function () &#123; console.log(\"connect the server\"); /* 向服务器发送数据 */ client.write(\"message from client\"); &#125;) /* 监听服务器传来的data数据 */ client.on(\"data\", function (data) &#123; console.log(\"the data of server is \" + data.toString()); &#125;) /* 监听end事件 */ client.on(\"end\", function () &#123; console.log(\"data end\"); &#125;) net.Socket连接相关的API有: socket.connect(): 有3种不同的参数，用于不同的场景。 socket.setTimeout(): 用来进行连接超时设置。 socket.setKeepAlive(): 用来设置长连接。 socket.destroy( )、socket.destroyed: 当错误发生时，用来销毁socket，确保这个socket上不会再有其他的IO操作。 net.Socket涉及的事件: data: 当收到另一侧传来的数据时触发。 connect: 当连接建立时触发。 close: 当连接断开时触发。如果是因为传输错误导致的连接断开，参数就为error。 end: 当连接另一侧发送了FIN包的时候触发。默认情况下(allowHalfOpen &#x3D;&#x3D; false)，socket会完成自我销毁操作。但也可以把allowHalfOpen设置为true，这样就可以继续往socket里写数据。当然，最后需要手动调用socket.end()。 error: 当有错误发生时就会触发，参数为error。 timeout: 示用户socket已经超时，需要手动关闭连接。 drain: 当写缓存空了的时候触发。 lookup: 当域名解析完成时触发。 httphttp.Server类是继承自net.Server，有很多net.Server的方法和事件。 net、http、dgram模块分别用来实现TCP、HTTP、UDP的通信。http为应用层模块，主要按照特定协议编解码数据; net为传输层模块，主要负责传输编码后的应用层数据; https是一个综合模块（涵盖了http&#x2F;tIs&#x2F;crypto等)，主要用于确保数据安全性。 const http = require('http'); const hostname = '127.0.0.1'; const port = 8080; const server = http.createServer((req, res) => &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n'); // 用于完成发送请求 &#125;); server.listen(port, hostname, () => &#123; console.log(`服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/`); &#125;); http.Server事件 close事件：服务器关闭时触发close事件 connection事件：建立新的TCP流是会发出connection事件 request事件：每次有请求时都会发出request事件。注意，在HTTP Keep-Alive连接的情况下每个连接可能会有多个请求。 http.requset发送请求const http = require ('http'); const req = http.request(&#123; host: '127.0.0.1', port: 8080, method: 'POST' // 默认是GET，POST、PUT、DELETE &#125;, (res) => &#123; res.resume(); res.on('end', () => &#123; console.log ('请求完成!');&#125;); &#125;); http请求对象和响应对象HTTP请求对象和响应对象在 Node.js中是被定义在 http.ClientRequest和http.ServerResponse类中的。 http.ClientRequesthttp.ClientRequest对象由http.request()内部创建并返回。它表示正在进行的请求，且其请求头已进入队列。请求头仍然可以使用 getHeader(name) 返回请求头的值 removeHeader(name) 改变。 实际的请求头将与第一个数据块一起发送，或者当调用request.end()时发送。 要获得响应，则为请求对象添加response事件监听器。当接收到响应头时，将会从请求对象触发response事件。response事件执行时有一个参数，该参数是http.IncomingMessage的实例。 在response事件期间，可以添加监听器到响应对象，如监听data事件。 如果没有添加response事件处理函数，则响应将被完全丢弃。如果添加了response事件处理函数，则必须消费完响应对象中的数据，每当有readable事件时，会调用response.read()，或添加 data事件处理函数，或调用.resume()方法。在消费完数据之前，不会触发end事件。此外，在读取数据之前，它将占用内存，最终可能导致进程内存不足的错误。 http.ServerResponse类http.ServerResponse对象由HTTP服务器在内部创建，而不是由用户创建。它作为第二个参数传给request事件。ServerResponse继承自Stream。 close事件：表示底层链接已经终止 finish事件：在响应发送后触发。 response.end()方法response.end([data][, encoding][, callback])方法用于向服务器发出信号，表示已发送所有响应标头和正文，该服务器应该考虑此消息已完成。必须在每个响应上调用response.end() 方法。 如果指定了data，则它实际上类似于先调用response.write(data, encoding)方法，接着调用response.end()方法。如果指定了callback，则在响应流完成时将调用它。 response.setHeader(name, value)：设置响应头。 response.getHeaderNames()：返回已经设置的响应头属性数组。 response.getHeaders()：返回已经设置的响应头，以key-vale表示。 REST ful风格 若要在服务器上创建资源，应该使用POST方法。 若要检索某个资源，应该使用GET方法。 若要更新或添加资源，应该使用PUT方法。 若要删除某个资源，应该使用DELETE方法。 npmnpm全称node package manager即node包管理器。 查看当前项目的所有NPM脚本命令，可以使用不带任何参数的npm run命令: npm run npm 脚本的原理相对简单，每当执行npm run时，会自动新建一个Shell，在该Shell 中执行指定的脚本命令。 因此，只要是Shell (一般是Bash)可以运行的命令，就可以写在 NPM脚本里面。需要注意的是，npm run新建的 Shell 会将当前目录的node_modules.bin子目录加入PATH变量，命令执行结束后，再将PATH 变量恢复。也就是说，当前目录的node_modules&#x2F;.bin子目录里面的所有脚本都可以直接用脚本名调用，而不必加上路径。例如，当前项目的依赖里面有Mocha，只需要直接写mocha test即可: \"script\": &#123; \"test\" : \"mocha test\" &#125; // 而不需要写成: \"script\": &#123; \"test\" :\"./node_modules/.bin/mocha test\" &#125; 由于NPM脚本的唯一要求是可以在Shell 中执行，因此它不一定是Node脚本，任何可执行文件都可以写在script中。 安装的局部开发依赖如果有命令，会在node_modules&#x2F;.bin目录创建软连接，package.json是可以读取到依赖下.bin目录下的命令，可以在package.json直接使用该命令。 package.jsonpackage.json可以手动编写，也可以使用npm init命令自动生成，它描述了项目使用到的模块，项目名称（必填）、版本号（必填）、许可、关键词。 Name: 包名。 Version: 包的版本号，语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。 Description: 包的描述。 Homepage: 包的官网地址。 Author: 包的作者姓名。 Contributors: 包的其他贡献者姓名。 Dependencies: 依赖包列表，指定了项目运行所依赖的模块。如果依赖包没有安装，npm就会自动将依赖包安装在node_module目录下。 devDependencies: 指定项目开发所需要的模块。 repository: 包代码存放的地方的类型，可以是Git或Svn，Git可在GitHub 上。 main: main字段指定了程序的主入口文件, require(‘moduleName’)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。 keywords: 关键字。 scripts: 指定了运行脚本命令的npm命令行缩写，比如 start 指定了运行npm run start时所要执行的命令。 bin: 用来指定各个内部命令对应的可执行文件的位置。 config: 用于添加命令行的环境变量。 npm命令# 更新模块： npm update module # 查看安装的模块： npm list -g # 查看全局安装的模块 npm list # 查看本地安装的模块 # 查看某个模块的信息 npm list koa # 查看命令详细帮助 npm help # 查看包的安装路径 npm root [-g] # 清除npm本地缓存 npm cache clean WebSocketWebSocket 提供了一个真正的全双工连接，它可用于客户机和服务器之间的双向通信，客户端和服务器可以随意向对方发送数据。 该方案的优点是属于HTML5标准，已经被大多数浏览器支持，而且是真正的全双工，性能比较好。其缺点是实现起来相对比较复杂，需要对ws协议专门处理。 使用ws创建WebSocket服务器Node.js原生API并未提供 WebSocket的支持，因此，需要安装第三方包才能使用WebSocket 功能。 // npm i ws const WebSocket = require('ws'); const server = new WebSocket.Server(&#123; port: 8080 &#125;); WebSocket.Server(options[, callback]）方法中的options对象支持如下参数。 host&lt;String&gt;: 绑定服务器的主机名。 port&lt;Number&gt;: 绑定服务器的端口。 backlog&lt;Number&gt;: 挂起连接队列的最大长度。 server: 预先创建的Node.js HTTP&#x2F;S服务器。 verifyClient&lt;Function&gt;: 可用于验证传入连接的函数。 handleProtocols&lt;Function&gt;: 可用于处理WebSocket子协议的函数。 path&lt;String&gt;: 仅接受与此路径匹配的连接。 noServer&lt;Boolean&gt;: 不启用服务器模式。 clientTracking&lt;Boolean&gt;: 指定是否跟踪客户端。 perMessageDeflate: 启用&#x2F;禁用消息压缩。 maxPayload&lt;Number&gt;: 允许的最大消息大小(以字节为单位)。 ws事件 ws监听事件：connection。只要有WebSocket连接到该服务器，就能触发connection事件。 如果想获知所有的已连接的客户端信息，则可以使用server.clients数据集。该数据集存储了所有已连接的客户端。 发送和接收数据ws通过websocket.send()方法发送数据，通过监听message事件来接受数据。 发送数据websocket.send(data[, options][, callback])方法可以用来发送数据。data参数就是用来发送的数据。options对象的属性可以有以下几种。 compress: 用于指定数据是否需要压缩。默认是true。 binary: 用于指定数据是否通过二进制传送。默认是自动检测。 mask: 用于指定是否应遮罩数据。当WebSocket不是服务器客户端时，默认认为true。 fin: 用于指定数据是否为消息的最后一个片段，默认为true。 发送ping和pong在消息通信中, ping-pong是一种验证客户端和服务器是否正常连接的简单机制。当客户端给服务器发送ping消息时，如果服务器能够正常响应pong消息，则说明客户端和服务器之间的通信是正常的。反之亦然，如果服务器想验证客户端的连接是否正常，也可以给客户端发送ping消息。ws提供了一种快捷的方式来发送ping消息和pong消息。 websocket.ping([data[, mask]][, callback]) websocket.pong([data[, mask]][, callback]) 接收数据ws通过message事件来接收数据 准备状态ws 中的 WebSocket类具有以下4种准备状态。 CONNECTING: 值为0，表示连接还没有打开。 OPEN: 值为1，表示连接已打开，可以通信了。 CLOSING: 值为2，表示连接正在关闭。 CLOSED: 值为2，表示连接已关闭。需要注意的是，当通过 WebSocket对象进行通信时，状态必须是OPEN。 关闭WebSocket服务器可以通过server.close()来关闭服务器，并通过close事件监听服务器的关闭。 ws例子 服务端const WebSocket = require('ws'); const WebSocketServer = WebSocket.Server; const wss = new WebSocketServer(&#123; port: 3000 &#125;); wss.on('connection', function (ws) &#123; console.log(`[SERVER] connection()`); ws.on('message', function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); setTimeout(() => &#123; ws.send(`What's your name?`, (err) => &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;, 1000); &#125;) &#125;); console.log('ws server started at port 3000...'); 客户端（浏览器）// client test: let count = 0; let ws = new WebSocket('ws://localhost:3000/ws/chat'); ws.on('open', function () &#123; console.log(`[CLIENT] open()`); ws.send('Hello!'); &#125;); ws.on('message', function (message) &#123; console.log(`[CLIENT] Received: $&#123;message&#125;`); count++; if (count > 3) &#123; ws.send('Goodbye!'); ws.close(); &#125; else &#123; setTimeout(() => &#123; ws.send(`Hello, I'm Mr No.$&#123;count&#125;!`); &#125;, 1000); &#125; &#125;); WebSocket 协议本身不要求同源策略（Same-Origin Policy)，也就是某个地址为 http://a.com的网页可以通过 WebSocket连接到ws://b.com。但是，浏览器会发送 Origin 的 HTTP 头给服务器，服务器可以根据 Origin 拒绝这个 WebSocket 请求。所以，是否要求同源要看服务器端如何检查。 MySQL基本操作# 显示已有的数据库 show databases; # 创建数据库 CREATE DATABASES data_name; # nodejs_book # 使用数据库 use data_name; # 建表 mysql> CREATE TABLE t_user ( user_id BIGINT NOT NULL, username VARCHAR(20)); # 查看表 show TABLES; # 显示表的结构 mysql> DESCRIBE t_user; # 往表中加入记录 mysql> insert into t_user values(1, 'yolo'); 使用node.js操作mysql使用mysql或者mysql2模块 实现简单的查询 mysql.createConnection()用于创建一个连接; connection.connect()方法用于建立连接; connection.query()方法用于执行查询，第一个参数就是待执行的SQL语句; connection.end()用于关闭连接。 const mysql = require('mysql'); // 连接信息 const connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '123456', database: 'nodejs_book' &#125;); // 建立连接 /// connection.connect(); connection.connect(function (err) &#123; if (err) &#123; console.error('error connecting: ' + err.stack); return; &#125; console.log('connected as id ' + connection.threadId); &#125;); // 执行查询 connection.query('SELECT * FROM t_user', function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('SELECT result is: ', results); &#125;); // 关闭连接 ///connection.end(); ///connection.destroy(); connection.end(function (err) &#123; if (err) &#123; console.error('error end: ' + err.stack); return; &#125; console.log('end connection'); &#125;); mysql模块连接选项 参数 描述 host 主机地址,默认是localhost user 用户名 password 密码 port 端口号，默认是3306 database 数据库名 charset 连接字符集（默认:&#39;UTF8_GENERAL_CI&#39;，注意字符集的字母都要大写) localA ddress 此IP用于TCP连接（可选) socketPath 连接到unix域路径，当使用host和port时会被忽略 timezone 时区，默认是&#39;local&#39; connectTimeout 连接超时，单位为毫秒。默认为不限制 stringifyObjects 是否序列化对象 typeCast 是否将列值转换为本地JavaScript类型值。默认为true queryFormat 自定义query语句格式化方法 supportBigNumbers 数据库支持bigint或decimal类型列时，需要设此option为true。默认为false bigNumberStrings supportBigNumbers和bigNumberStrings启用，强制bigint或decimal列以JavaScript字符串类型返回。默认为false dateStrings 强制timestamp、datetime、data类型以字符串类型返回，而不是JavaScript Date类型。默认为false debug 开启调试。默认为false multipleStatements 是否允许一个query中有多个MySQL语句。默认为false flags 用于修改连接标志 ssl 使用ssl参数或一个包含ssl配置文件名称的字符串 mysql模块CRUD// 执行查询 connection.query('SELECT * FROM t_user', function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('SELECT result is: ', results); &#125;); // 插入数据 // 其中，在SQL语句中，通过“?”占位符的方式将参数对象data进行传入。 var data = &#123; user_id: 2, username: 'waylau' &#125;; connection.query('INSERT INTO t_user SET ?', data, function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('INSERT result is: ', results); &#125;); // 更新数据 // 通过“?\"占位符的方式将参数对象进行传入。所不同的是，参数对象是一个数组。 connection.query('UPDATE t_user SET username = ? WHERE user_id = ?', ['Way Lau', 2], function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('UPDATE result is: ', results); &#125;); // 执行查询 // 同样也是通过“?占位符的方式将参数对象进行传入。所不同的是，参数对象是一个数值（用户ID)。 connection.query('SELECT * FROM t_user', function (error, results, fields) &#123; if (error) &#123; throw error; &#125; // 打印查询结果 console.log('SELECT result is: ', results); &#125;); mysql连接池建议将连接池的pool.getConnection封装一下，实现复用 const express = require('express'); const app = express(); const port = 8080; const bodyParser = require('body-parser');//用于req. const URL = '/api/users'; const mysql = require('mysql'); // 连接信息. // 使用连接池 const pool = mysql.createPool(&#123; connectionLimit: 4, // 连接数限制 host: 'localhost', user: 'root', password: '123456', database: 'nodejs_book' &#125;); app.use(bodyParser.json()); // 获取所有用户列表API app.get(URL + '/', function (req, res) &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户ID let name = req.query.name; console.log('User name is: ', name); if (name == null) &#123; // 执行查询 connection.query('SELECT * FROM t_user', function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125; else &#123; // 执行查询 connection.query('SELECT * FROM t_user where username = ?', name, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印查询结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125; &#125;); &#125;); // 获取指定ID的用户API app.get(URL + '/:id', function (req, res) &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户ID let id = req.params.id; console.log('User id is: ', id); // 执行查询 connection.query('SELECT * FROM t_user where user_id = ?', id, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 取第一个，转为JSON返回 res.json(results[0]).end(); &#125;); &#125;); &#125;); // 创建用户信息API app.post(URL + '/', (req, res) => &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户信息 let username = req.body.username; console.log('User is: ', username); // 执行查询 connection.query('INSERT INTO t_user (username) VALUES (?)', username, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125;); &#125;); // 更新用户信息API app.put(URL + '/', (req, res) => &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户信息 let user_id = req.body.user_id; let username = req.body.username; console.log('User id is: ', user_id); console.log('User name is: ', username); // 执行查询 connection.query('UPDATE t_user SET username = ? WHERE user_id = ? ', [username, user_id], function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125;); &#125;); // 删除指定ID的用户API app.delete(URL + '/:id', (req, res) => &#123; // 获取连接 pool.getConnection(function (err, connection) &#123; if (err) &#123; throw err; &#125; // 从请求参数中获取用户ID let id = req.params.id; console.log('User id is: ', id); // 执行查询 connection.query('DELETE FROM t_user WHERE user_id = ? ', id, function (error, results) &#123; // 错误处理 if (error) &#123; throw error; &#125; // 打印执行结果 console.log('The result is: ', results); // 释放连接 connection.release(); // 转为JSON返回 res.json(results).end(); &#125;); &#125;); &#125;); app.listen(port, () => console.log(`Server listening on port $&#123;port&#125;!`)); RedisRedis是一个高性能的key-vale缓存数据库 Redis支持主从同步，可以从主服务器向任意数量的从服务器上同步数据，从服务器可以是关联其他从服务器的主服务器。这使得 Redis可执行单层树复制，存盘可以有意无意地对数据进行写操作。由于完全实现了发布&#x2F;订阅机制，使得从数据库在任何地方进行数据同步时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 Redis不仅仅是简单的key-value存储，更是一个data strutures server（数据结构服务器)，用来支持不同的数值类型。在key-value中，value不仅仅局限于string类型，它可以是更复杂的数据结构。 二进制安全的string。 List: 一个链表，链表中的元素按照插入顺序排列。 Set: string 集合，集合中的元素是唯一的，没有排序。 Sorted set: 与Set类似，但是每一个string 元素关联一个浮点数值，这个数值被称为Score。元素总是通过它们的Score进行排序，所以不像Set那样可以获取一段范围的元素（例如，获取前10个，或者后10个)。 Hash: 指由关联值字段构成的 Map。字段和值都是string。 Bit array（或者简单称为Bitmap): 像位数值一样通过特别的命令处理字符串，可以设置和清除单独的bit，统计所有bit集合中为1的数量，查找第一个设置或没有设置的bit等。 HyperLogLogs: 这是一个概率统计用的数据结构，可以用来估计一个集合的基数。对于所有的例子，我们都使用redis-cli工具来演示。这是一个简单但非常有用的命令行工具，可以用来给Redis Server 发送命令。 Redis超时Redis超时是 Redis的一个特性之一，这个特性可以用在任何一种值类型中。可以给一个key设置一个超时时间，这个超时时间就是有限的生存时间。当生存时间过去，这个key就会自动被销毁。 在设置超时时间时，可以使用秒或毫秒。 超时时间一般总是1ms。 超时信息会被复制，并持久化到磁盘中。当Redis服务器停止时(这意味着Redis将保存key 的超时时间)。 node.js操作redis使用redis模块操作redis redis.createClient()用于创建客户端。 client.set()方法设置单个值。 client.hset()方法用于设置多个字段。 client.hkeys()方法用于返回所有的字段。 client.get()和client.hgetall()方法都用于获取key 所对应的值。 client.quit()用于关闭连接。 const redis = require(\"redis\"); // 创建客户端 const client = redis.createClient(6379, '127.0.0.1'); // 如果没有密码，则不需要这一步 client.auth(123456) // // 错误处理 client.on(\"error\", function (err) &#123; console.log(\"Error \" + err); &#125;); client.on('connect', function()&#123; // 设值 client.set(\"hello\", \"this is a value\"); // 把存储对象改成JSON对象 程序将会报错，因为Redis 中存储的是字符串对象 client.set('test', &#123; user_name: 'yolo', age: 18&#125;) // 重写toString 即可方法: // object.prototype.tostring = function ()&#123; // return JSON.stringify(this); // &#125;; &#125;) // 设值 client.set(\"书名\", \"《Node.js企业级应用开发实战》\", redis.print); // 同个key不同的字段 client.hset(\"柳伟卫的Spring三剑客\", \"第一剑\", \"《Spring Boot 企业级应用开发实战》\", redis.print); client.hset(\"柳伟卫的Spring三剑客\", \"第二剑\", \"《Spring Cloud 微服务架构开发实战》\", redis.print); client.hset([\"柳伟卫的Spring三剑客\", \"第三剑\", \"《Spring 5 开发大全》\"], redis.print); // 返回所有的字段 client.hkeys(\"柳伟卫的Spring三剑客\", function (err, replies) &#123; console.log(\"柳伟卫的Spring三剑客共\" + replies.length + \"本:\"); // 遍历所有的字段 replies.forEach(function (reply, i) &#123; console.log(\" \" + i + \": \" + reply); &#125;); &#125;); // 获取key所对应的值 client.get(\"书名\", function (err, reply) &#123; console.log(reply); &#125;); // 获取key所对应的值 client.hgetall(\"柳伟卫的Spring三剑客\", function (err, reply) &#123; console.log(reply); // 退出 client.quit(); &#125;); // 清除数据 client.del('key') 异常处理 使用process.on(&#39;uncaughtException&#39;, function(err)&#123;&#125;)就不会造成接口崩溃了，可惜的是，很多应用在开发时都没有做这样的基本处理，因此都出现了问题，捕获那些咱没有 try-catch 的异常错误。// 相对于异常来说，内存泄漏也是一个不能忽视的严重问题，而process.on('uncaughtException')的做法很难保证不造成内存的泄漏。 // 所以当捕获到异常时，显式地手动杀掉进程并重启Node进程，既可以保证释放内存，又保证了服务后续的正常可用。 process.on ('uncaughtException', (e)=>&#123; console.error('process error is:', e.message); process.exit(1); restartServer(); //重启服务 &#125;); try&#x2F;catch&#x2F;finally，当我们去读取文件遇到异常时，抛出的异常会被try&#x2F;catch捕获，当前的线程就不会英文异常而意外结束了。 async&#x2F;await和promise是无法捕获异步代码的异常的，如下例子，无法捕获setTimeout异步代码里的异常new Promise((resolve, reject) =>&#123; setTimeout(() => &#123; throw new Error('error'); &#125;, 100); &#125;).then(() =>&#123; // 一些逻辑代码 &#125;).catch ((e) =>&#123; console.log('能进来说明可以处理异常信息了'); console.log(e); &#125;); fs.readFile('test.txt', function(err, data)&#123; try&#123; if(err) throw err; // ... &#125;catch(e)&#123; console.log(e) &#125;finally&#123; &#125; &#125;) nodejs里约定，同步的代码才能捕获异常，异步的代码不能直接使用try、catch 先看同步代码可以捕获的异常const testFunc = function() &#123; return new Promise((resolve, reject) => &#123; throw new Error('error'); &#125;); &#125;; async function testAsync() &#123; try &#123; await testFunc(); &#125; catch (e) &#123; console.log('能进来，说明异常能处理'); console.log(e); &#125; &#125; testAsync(); 异步代码无法捕获异常const testFunc = function() &#123; setTimeout(() => &#123; console.log(1111); return new Promise((resolve, reject) => &#123; throw new Error('error'); &#125;); &#125;, 100); &#125;; async function testAsync() &#123; try &#123; await testFunc(); &#125; catch (e) &#123; console.log('能进来，说明异常能处理'); console.log(e); &#125; &#125; testAsync(); 进程崩溃时重启进程因异常退出是很常见的事，当遇到崩溃退出的时候，重启就可以了。负责进程崩溃应用自动重启的模块有： forever模块，forever处理crash事件，再开启新的node进程（很少用了，基本都用pm2模块） pm2模块，支持所有的forever的功能，功能强大，比如0秒切换。 npm i pm2 -g pm2 start app.js 大集群：多台机器为了应对大流量，需要多台机器进行集群处理，因此可以通过负载均衡策略将流量分发到各个机器上，通过消除单点故障提升应用系统的可用性。常见的集群处理方式是使用Nginx或HAProxy。 参考 Node.js的底层原理 Node.js 技术架构 .env 文件原理 Node.js子进程 NodeJS中的事件（EventEmitter 书栈网node.js教程 《Node.js12 实战》 《Node.js 企业级应用开发实战》 《狼叔卷1》 《狼叔卷2》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"}]},{"title":"TypeScript 知识汇总","slug":"front_end/typescript","date":"2021-12-27T18:32:14.000Z","updated":"2022-07-08T14:26:34.275Z","comments":true,"path":"2021/12/28/front_end/typescript/","link":"","permalink":"http://example.com/2021/12/28/front_end/typescript/","excerpt":"","text":"TypeScript 基本使用 2021 typescript史上最强学习入门文章 如何优雅地在 React 中使用TypeScript React 中完美运用 TypeScript 工具类型PartialPartial&lt;T&gt; 将类型的属性变成可选，只支持处理第一层的属性 type Partial&lt;T> = &#123; [key in keyof T]?: T[key] &#125; DeepPartialDeepPartial&lt;T&gt; 将类型的属性变成可选，只支持多层的属性 type DeepPartial&lt;T> = &#123; [key in keyof T]?: T[key] extends object ? DeepPartial&lt;T[key]> : T[key] &#125; RequiredRequired&lt;T&gt;将类型的属性变成必选 type Required&lt;T> = &#123; [key in keyof T]-?: T[key] &#125; ReadonlyReadonly&lt;T&gt; 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。只对一级的属性做限制不能修改，如果是引用类型，还是可以修改的。 type Readonly&lt;T> = &#123; readonly [key in keyof T]: T[key] &#125; Pick（挑选）Pick 从某个类型中挑出一些属性出来 type Pick&lt;T, K extends keyof T> = &#123; [key in K]: T[key] &#125; Record（转化）Record&lt;K extends keyof any, T&gt; 的作用是将 K 中所有的属性的值转化为 T 类型。 type Record&lt;K extends keyof any, T> = &#123; [key in K]: T &#125; interface PageInfo &#123; title: string; &#125; type Page = \"home\" | \"about\" | \"contact\"; const x: Record&lt;Page, PageInfo> = &#123; about: &#123; title: \"about\" &#125;, contact: &#123; title: \"contact\" &#125;, home: &#123; title: \"home\" &#125;, &#125;; Exclude（移除）Exclude&lt;T, U&gt; 的作用是将某个类型中属于另一个的类型移除掉。如果 T 能赋值给 U 类型的话，那么就会返回 never 类型，否则返回 T 类型。最终实现的效果就是将 T 中某些属于 U 的类型移除掉。 type Exclude&lt;T, U> = T extends U ? never : T; // 例子 type T0 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\" type T1 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\" type T2 = Exclude&lt;string | number | (() => void), Function>; // string | number Extract（公共）Extract&lt;T, U&gt; 的作用是从 T 中提取出 U，提取公共部分。 type Extract&lt;T, U> = T extends U ? T : never; type T0 = Extract&lt;\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\" type T1 = Extract&lt;string | number | (() => void), Function>; // () =>void Omit（差集）Omit&lt;T, K extends keyof any&gt; 的作用是使用 T 类型中除了 K 类型的所有属性，来构造一个新的类型。 type Omit&lt;T, K extends keyof any> = Pick&lt;T, Exclude&lt;keyof T, K>>; interface Todo &#123; title: string; description: string; completed: boolean; &#125; type TodoPreview = Omit&lt;Todo, \"description\">; const todo: TodoPreview = &#123; title: \"Clean room\", completed: false, &#125;; NonNullableNonNullable&lt;T&gt; 的作用是用来过滤类型中的 null 及 undefined 类型。 type NonNullable&lt;T> = T extends null|undefined ? never : T type T0 = NonNullable&lt;string | number | undefined>; // string | number type T1 = NonNullable&lt;string[] | null | undefined>; // string[] ParametersParameters&lt;T&gt;的作用是用于获得函数的参数类型组成的元组类型。 type Parameters&lt;T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never; type A = Parameters&lt;() =>void>; // [] type B = Parameters&lt;typeof Array.isArray>; // [any] type C = Parameters&lt;typeof parseInt>; // [string, (number | undefined)?] type D = Parameters&lt;typeof Math.max>; // number[] ReturnType获取函数的返回值的类型 type ReturnType&lt;T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any; type E = ReturnType&lt;() => string> // E的类型是string tsconfig.json介绍tsconfig.json 是 TypeScript 编译的相关配置，用于描述将TS转化为JS代码的配置文件，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。 生成tsconfig.js文件：tsc --init 查看更多配置和使用说名: tsc -h 应当将tsc作为类型检查工具，而不是编译项目的工具，代码编译的工作应该交给babel、webpack等工具 tsconfig.json 重要字段 files，设置需要编译的单个文件的列表； // 只编译 src下的 index.ts文件 &#123; \"files\": [\"src/index.ts\"] &#125; include，设置需要进行编译的文件或者目录，支持路径模式匹配；include和files会合并 // 编译src所有的ts文件 // 支持通配符，只编译src下的一级目录的ts文件，如\"src/*\"，二级文件 \"src/*/*\" &#123; \"include\": [\"src\"] &#125; exclude，排除不需要进行编译的文件，支持路径模式匹配（排除）；默认排除node_modules下的所有文件、排除所有声明文件(xxx.d.ts)，只对include字段有排除效果，对file字段无影响。 // 排除src/lib的文件编译 &#123; \"include\": [\"src/lib\"] &#125; extends，导入或者继承其他tsconfig配置 // 导入当前目录下的tsconfig.base.json里的配置，但是导入的配置容易被覆盖（在tsconfig.json可以覆盖导入的配置） &#123; \"extends\": \"./tsconfig.base.json\" &#125; compileOnSave: true, 保存文件时自动触发tsc编译文件（VScode不支持这个配置），一般来说，代码编译过程会通过webpack等打包构建工具，并且使用热更新，因此一般不需要配置该项。 compilerOptions，设置与编译流程相关的选项。 如果ts.config文件为空，则会按照默认是编译当前目录下的所有ts文件。 compilerOptions 选项&#123; \"compilerOptions\": &#123; \"tsBuildInfoFile\": './buildFile', // 指定编译后的文件放在哪里 /* 基本选项 */ \"target\": \"es5\", // 指定编译后ECMAScript目标版本: 要将ts编译成js哪个版本的语法，'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制只能引用当前目录下的ts文件. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": &#123;&#125;, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 &#125; &#125; TypeScript 面试 TypeScript 面试题 TypeScript 面试题及答案","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"React Hooks 总结","slug":"front_end/reacthooks","date":"2021-07-14T12:02:11.000Z","updated":"2022-07-10T09:29:39.454Z","comments":true,"path":"2021/07/14/front_end/reacthooks/","link":"","permalink":"http://example.com/2021/07/14/front_end/reacthooks/","excerpt":"","text":"为什么要设计Hooks，Hooks有什么优势？ 解决了 Class 组件存在的一些代码冗余、难以逻辑复用的问题，替代了高阶组件的负担，能够让代码更加容易理解和维护。 让函数组件拥有类组件的一些特性，内部状态（useState）和类似 class 组件的生命周期（useEffect）。 函数组件和类组件本质的区别是？ Class组件，底层只需要实例化一次，实例中保存了组件的 state 状态。对于每一次更新只需要调用 render 方法以及对应的生命周期就可以了。 Function组件，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量会重新声明。React 对函数组件的调用，是采用直接执行函数的方式，而不是通过new的方式。 使用Hooks需要注意的地方 只在 function 组件和自定义 hooks 中使用 hooks。 不能将 hooks 放在循环、条件语句或者嵌套方法内执行，原因是 react 是根据 hooks 出现顺序来记录对应状态的。 useStateuseState基本使用useState的参数可以是任意的值，也可以是一个函数，函数的返回值作为其初始值。 const [count, setCount] = useState(initialState) const [state, setState] = useState(() => &#123; // 初始化initialState return initialState; &#125;) useState 返回值为一个数组，数组的第一个参数为我们需要使用的 state，第二个参数为更新state的函数 setCount(0) // 需要获取上一个state的值 setCount(prevCount => prevCount + 1) // state为对象时 setState(prevState => (&#123; ...prevState, attr: 'value' &#125;)) // state为数组时 setArr((arr) => &#123; arr.push(5) return [...arr] &#125;) useState为什么返回的是一个数组而不是一个对象？简单来说，数组解构是有顺序的，开发者可自定义名称，对象解构是根据对象的key解构。 useState的实现原理 第一次渲染时候，根据 useState 顺序，逐个声明 state 并且将其放入全局 Array 中。每次声明 state，都要将 count 增加 1。 更新 state，触发再次渲染的时候，count 被重置为 0。按照 useState 的声明顺序，依次拿出最新的 state 的值，视图更新。 const stateArr = []; // 多个状态，保存在一个全局容器 Array 中 let count = 0; function useState(initialState) &#123; const curCount = count; stateArr[curCount] = stateArr[curCount] || initialState; // 检查是否渲染过 function dispatch(newState) &#123; stateArr[curCount] = newState; render(); // 调用函数组件的render方法 &#125; ++count; // update: count return [stateArr[curCount], dispatch]; &#125; useEffectuseEffect(effect, deps); 第一个参数为 effect 副作用函数，副作用函数返回值是一个回调函数returnFunction，这个回调函数不只是会在组件销毁时执行，而且是每次 Effect 重新执行之前都会先执行returnFunction，用于清理上一次 effect 的执行结果。 每次组件 render 完成后，会根据deps里的依赖，是否要执行 effect 第二个参数 deps 依赖的不同情况 没有依赖项，则每次 render 后都会重新执行，如果存在returnFunction则先执行returnFunction，再触发 effect（componentDidUpdate） 空数组作为依赖项，则只在第一次 render 后执行，对应到 Class 组件就是 componentDidMount returnFunction 用于在组件销毁的时候做一些清理的操作，比如移除事件的监听、定时器的清除（componentWillUnmount） 依赖项中定义的变量一般是会在回调函数中用到的，否则声明依赖项其实是没有意义的。 React 会使用浅比较来对比依赖项是否发生了变化，所以要特别注意数组或者对象类型。如果你是每次创建一个新对象，即使和之前的值是等价的，也会被认为是依赖项发生了变化。（deps为非原始类型时，每次渲染都会发生改变） 不要把 effect 写成一个 async 函数，useEffect 中约定 Effect 函数要么没有返回值，要么返回一个函数， async 函数会隐式地返回一个 Promise，直接违反了这一约定，会造成不可预测的结果。 useEffect的实现原理在 useEffect 的第二个参数中，我们可以指定一个数组，如果下次渲染时，数组中的元素没变，那么就不会触发这个副作用 // 利用 Array + Count 的思路，不包括销毁副作用功能的 useEffect 的实现 const allDeps = []; let effectCount = 0; function useEffect(callback, deps) &#123; if (!allDeps[effectCount]) &#123; // 初次渲染：赋值 + 调用回调函数 allDeps[effectCount] = deps; ++effectCount; callback(); return; &#125; const currEffectCount = effectCount; const rawDeps = allDeps[currEffectCount]; // 检测依赖项是否发生变化，发生变化需要重新render const isChanged = rawDeps.some( (dep, index) => dep !== deps[index] ); if (isChanged) &#123; callback(); &#125; ++effectCount; &#125; function render() &#123; ReactDOM.render(&lt;App />, document.getElementById(\"root\")); effectCount = 0; // 注意将 effectCount 重置为0 &#125; useLayoutEffectuseLayoutEffect(effect, deps); useLayoutEffect 与 useEffect 使用方法一样，只是执行回调函数的时机不同。useLayoutEffect在浏览器执行绘制之前执行（会阻碍浏览器 paint，慎用），只有当我们需要进行DOM的操作时才使用该函数。 useLayoutEffect(() => &#123; console.log('useLayoutEffect————2') return () => &#123; console.log('组件卸载了：useLayoutEffect————1') &#125; &#125;, [deps]) useEffect(() => &#123; console.log('useEffect————4') return () => &#123; console.log('组件卸载了：useEffect————3') &#125; &#125;, [deps]) // 监听的状态发生改变时： useLayoutEffect返回的函数（1） ——> useLayoutEffect（2） ——> useEffect返回的函数（3） ——> useEffect（4） useMemo 第一个参数为一个回调函数，该函数返回一个缓存的值 第一个参数为依赖项，依赖的值发生变化时，回调函数才会重新计算缓存数据 这样避免在每次重新渲染时都进行复杂的数据计算 function Counter(&#123; countA, countB&#125;) &#123; const sum = useMemo(() => &#123; // ... 只有当countA 或 countB变化时才重新计算count return countA + countB; &#125;, [countA, countB]); return ( &lt;div>&#123;sum&#125;&lt;/div> ) &#125; useMemo的实现原理function useMemo(fn, deps)&#123; return useCallback(fn(), deps) &#125; momo上个例子中，只要父组件render方法执行，Counter函数依旧会触发重新渲染，要让函数不执行，在最外层加上memo const Counter = memo((&#123; countA, countB&#125;) => &#123; const sum = useMemo(() => &#123; // ... 只有当countA 或 countB变化时才重新计算count return countA + countB; &#125;, [countA, countB]); return ( &lt;div>&#123;sum&#125;&lt;/div> ) &#125;) useCallback useCallback 的用法和 useMemo 类似，只有依赖项发生变化的时候，才需要重新创建一个回调函数，这样就保证了组件不会创建重复的回调函数。 接收这个回调函数作为属性的组件，也不会频繁地需要重新渲染。 useCallback(fn, deps) 等同于 useMemo(() =&gt; fn, deps) // 这样， function Counter() &#123; const [count, setCount] = useState(0); const handleIncrement = useCallback(() => setCount(count + 1), [count]); // ... return &lt;button onClick=&#123;handleIncrement&#125;>+&lt;/button> &#125; useCallback实现原理let memoizedState = null function useCallback(callback, deps) &#123; const nextDeps = (deps !== undefined ) &amp;&amp; (deps !== null) ? deps : [callback] const prevState = memoizedState; if (prevState !== null) &#123; const prevDeps = prevState[1] if (areHookdepsEqual(nextDeps, prevDeps)) &#123; return prevState[0] &#125; &#125; memoizedState = [callback, nextDeps] return callback &#125; useRef 组件的引用：返回一个可变的 ref 对象，该对象下面有一个 current 属性指向被引用对象的实例，当做 ref 正常使用时，和 createRef 效果一样。 useRef 返回的 ref 对象在组件的整个生命周期内保持不变，useRef 每次都会返回相同的引用，createRef 每次渲染都会重新创建 ref import &#123; React, useRef, createRef&#125; from 'react' const App = () => &#123; const inputElement = createRef() const flieElement = useRef(); if (!inputElement.current) &#123; console.log('inputElement') // 函数重新执行时，每一次都打印 &#125; if (!flieElement.current) &#123; console.log('flieElement') // 只打印第一次 &#125; // flieElement.current.click() 上传文件 // inputElement.current.focus() 聚焦 return ( &lt;> &lt;input type='text' ref=&#123;inputElement&#125; /> &lt;input type='flie' ref=&#123;flieElement&#125; /> &lt;/> ) &#125; useRef 可以拿到最新的值， current 指向初始化为传入的参数，可以存放任何变量 const refVal = useRef(value); // refVal.current => value const [count, setCount] = useState(value) const newCount = useRef() new.current = count useImperativeHandle useImperativeHandle 一般和 forwardRef 一起使用的，减少暴露给父组件的属性 forwardRef的作用是：引用父组件的 ref 实例，成为子组件的一个参数，可以引用父组件的 ref 绑定到子组件自身的节点上。它有两个参数，第一个是父组件传递的 props，第二个就是 ref 的引用 forwardRef((props, ref) => &#123; // 父组件传来的 ref return ( &lt;input ref=&#123;ref&#125;>&lt;/input> ) &#125;) useImperativeHandle 有三个参数： 第一个参数，接收一个通过 forwardRef 引用父组件的 ref 实例。 第二个参数一个回调函数，返回一个对象，对象里面存储需要暴露给父组件的属性或方法。 第三个参数为一个可选参数，该参数是一个依赖项数组deps。 function Example(props, ref) &#123; const inputRef = useRef() useImperativeHandle(ref, () => (&#123; // 父组件可以通过this.xxx.current.focus的方式使用子组件传递出去的focus方法 focus: () => &#123; inputRef.current.focus() &#125; &#125;)) return &lt;input ref=&#123;inputRef&#125; /> &#125; export default forwardRef(Example) // 父组件 class App extends Component &#123; constructor(props)&#123; super(props) this.inputRef = createRef() &#125; render() &#123; return ( &lt;> &lt;Example ref=&#123;this.inputRef&#125;/> &lt;button onClick=&#123;() => &#123;this.inputRef.current.focus()&#125;&#125;>Click&lt;/button> &lt;/> ) &#125; useReducer useReducer是useState 的一种替代方案，它接收三个参数，第一个参数为一个 reducer 函数，第二个参数是reducer的初始值，第三个参数为可选参数，值为一个函数，可以用来惰性提供初始状态。 reducer 函数接受两个参数一个是 state 另一个是 action ，用法原理和 redux 中的 reducer const [state, dispatch] = useReducer(reducer, initialArg, init) function init(initialCount) &#123; return &#123;count: initialCount&#125;; &#125; function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; case 'reset': return init(action.payload); default: throw new Error(); &#125; &#125; function Counter(&#123;initialCount&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;> Count: &#123;state.count&#125; &lt;button onClick=&#123;() => dispatch(&#123;type: 'reset', payload: initialCount&#125;)&#125; > Reset &lt;/button> &lt;button onClick=&#123;() => dispatch(&#123;type: 'increment'&#125;)&#125;>+&lt;/button> &lt;button onClick=&#123;() => dispatch(&#123;type: 'decrement'&#125;)&#125;>-&lt;/button> &lt;/> ); &#125; function render () &#123; ReactDOM.render(&lt;Counter initialCount=&#123;0&#125; />, document.getElementById('root')); &#125; useContext 定义全局状态，当这个 Context 的数据发生变化时，使用这个数据的组件就能够自动刷新 React 的开发中，我们很少会使用 Context 来做太多数据的共享，Context 更多的是提供了一个强大的机制，让 React 应用具备定义全局的响应式数据的能力。主要是用来实现 Theme(主题)、Language (多语)等功能 const globalContext = React.createContext() function App()&#123; return ( &lt;globalContext.Provider value=&#123;'light'&#125;> &lt;Count /> &lt;/globalContext.Provider> ) &#125; function Count(props) &#123; const context = useContext(globalContext) return ( &lt;div> &#123;context&#125; // light &lt;/div> ) &#125; 参考 React Hooks 使用总结 useEffect 完整指南 React Hooks 原理","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"【webpack】手写loader和plugin","slug":"engineering/loader-and-plugin","date":"2021-03-24T12:10:21.000Z","updated":"2022-07-08T17:48:18.429Z","comments":true,"path":"2021/03/24/engineering/loader-and-plugin/","link":"","permalink":"http://example.com/2021/03/24/engineering/loader-and-plugin/","excerpt":"","text":"loader loader的作用：loader可以看成为一个转换器，将非js&#x2F;json的文件转化为可执行的JS字符串。 loader本质上是一个函数，上一个loader处理完source之后会把处理结果传给下一个loader来处理。 loader执行的顺序是在use数组内从右到左（从后往前） Compose(webpack采用的函数组合)：compose = (f, g) =&gt; (...args) =&gt; f(g(...args)) 手写清除console的loader参考文档: 手写清除console的loader 手写loader源码// 路径 /loaders/console-loader/index.js /** * 手写清除console的loader * 参考：https://juejin.cn/post/7038413043084034062 * loader实际上就是一个函数，但他不能是一个箭头函数，因为它需要继承webpack的this。 * 多个loader是从右向左调用，上一个loader将结果返回给下一个loader使用 * 输入输出都是字符串或者二进制数据，在loader函数中直接返回数字类型，会报错 */ // webpack5 已经可以通过this.query直接获取loader的options配置，所以不需要利用loader-utils工具获取 // webpack5 内置了terser-webpack-plugin，如果使用的是webpack5，同时需要自定义配置，那么仍需要安装terser-webpack-plugin // uglifyjs-webpack-plugin只支持ES5，terser-webpack-plugin支持ES6，压缩js，清除console前缀的语句 // source：表示当前要处理的内容 const reg = /(console.log()(.*)())/g; // Webpack5在loader的上下文中，会带有内置的this.getOptions方法 function ConsoleLoader(source) &#123; const &#123; data &#125; = this.query; console.log('data', data) // 通过正则表达式将当前处理内容中的console替换为空字符串 source = source.replace(reg, \"\") // 再把处理好的内容return出去，坚守输入输出都是字符串的原则，并可达到链式调用的目的供下一个loader处理 return source; &#125; module.exports = ConsoleLoader; 在webpack.config.js中使用该loaderconst path = require('path'); module.exports = &#123; mode: 'development', entry: path.join(__dirname, 'src/index.js'), output: &#123; path: path.join(__dirname, 'dist'), filename: 'index.js', &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, use: &#123; // path.resolve(__dirname, 'loaders/console-loader/index.js') loader: 'console-loader', options: &#123; data: \"console-loader\" &#125; &#125; &#125; ] &#125;, resolveLoader: &#123; modules: ['node_modules', path.resolve(__dirname, 'loaders')] &#125; &#125; pluginplugins是增强webpack功能，打包输出js文件（bundle）的一个优化，作用于整个构建过程。可以理解为任何loader没办法做的事情，都可以用plugins去完成。 手写一个md转成html的plugin如何创建 Plugin参考：手把手带你入门WebpackPlugin const pluginName = 'md-to-html-plugin'; class MdToHtmlPlugin &#123; apply(compiler) &#123; // 代表开始读取 records 之前执行 compiler.hooks.emit.tap(pluginName, (compilation) => &#123; console.log(\"webpack 构建过程开始！\"); // _assets 打包的资源详情 const _assets = compilation.assets; &#125;); &#125; &#125; compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例； webpack会提供一个apply方法，接受一个编译器compiler，编译的时候都是在apply里执行，是执行具体的插件方法。 apply 方法的入参注入了一个 compiler 实例，compiler 实例是 Webpack 的支柱引擎，代表了 CLI 和 Node API 传递的所有配置项。 compiler会有钩子hooks，钩子hooks会有一个发布器emit（类似node的EmitterEvent发布订阅）tap第一个参数是插件的名字，第二个参数是回调函数，回调函数的参数是一个compilation。 compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 compilation 将被创建。compilation 对象也提供了很多事件回调供插件做扩展。通过 compilation 也能读取到 Compiler 对象。Compilation 上的assets可以用于文件写入，可以将资源设置到compilation.assets对象上。 Hook 上还暴露了 3 个方法供使用，分别是 tap、tapAsync 和 tapPromise。这三个方法用于定义如何执行 Hook，比如 tap 表示注册同步 Hook，tapAsync 代表 callback 方式注册异步 hook，而 tapPromise 代表 Promise 方式注册异步 Hook。 常见Complier Hooks参考: webpack Hook type 调用 run AsyncSeriesHook 开始读取 records 之前 compile SyncHook 一个新的编译 (compilation) 创建之后 emit AsyncSeriesHook 生成资源到 output 目录之前 done SyncHook 编译 (compilation) 完成 实现MdToHtmlPlugin1、创建MdToHtmlPlugin在根目录下创建plugin文件夹，在plugin下新建md-to-html-plugin文件夹，并在该文件夹下新建index.js入口文件，compiler.js文件，constant.js声明常量文件，util.js公共方法文件，template.html模板文件 index.js文件const &#123; readFileSync &#125; = require('fs'); const &#123; resolve, dirname, join &#125; = require('path'); const &#123; compileHTML &#125; = require('./compiler'); const &#123; TEMPLATE_MARK, PLUGIN_NAME &#125; = require('./constant'); class MdToHtmlPlugin &#123; constructor(&#123; template, filename &#125;) &#123; // 没传template if (!template) &#123; throw new Error('Please input the markdown template file'); &#125; this.template = template; // 没传filename 默认为 index.html this.filename = filename ? filename : 'index.html'; &#125; apply(compiler) &#123; // tap第一个参数是插件的名字，第二个参数是回调函数，回调函数的参数是一个compilation compiler.hooks.emit.tap(PLUGIN_NAME, (compilation) => &#123; // _assets 打包的资源详情 const _assets = compilation.assets; // fs的api readFileSync 同步读取文件 readFile是异步的 const templateContent = readFileSync(this.template, 'utf-8'); // 目录文件，编码方式 // 将templateContent（md文件的内容） 变为数组 const templateContentArr = templateContent.split('\\n'); // 核心方法： 将数组内容 编译为 html标签 const &#123; htmlStr, staticSource &#125; = compileHTML(templateContentArr); // 找到当前目录下的template.html const templateHtml = readFileSync(resolve(__dirname, \"template.html\"), 'utf-8'); // 将template.html的模板字符串替换 const fileHtml = templateHtml.replace(TEMPLATE_MARK, htmlStr); // _assets增加资源，this.filename 就是_assets的一个属性 _assets[this.filename] = &#123; // source不是一个普通的函数，它会把放到_assets[this.filename]对象中 // 将资源放到我们定义filename的html文件中 source() &#123; return fileHtml; &#125;, // 资源的长度 size() &#123; return fileHtml.length; &#125; &#125; // 处理静态文件 if (staticSource &amp;&amp; staticSource.length > 0) &#123; // 获取md文件所在的目录 const tplDirName = dirname(this.template); staticSource.map((staticItem) => &#123; const &#123; filename, staticPath &#125; = staticItem; // 拼接md文件引用的静态资源路径 const staticsourcepath = join(tplDirName, staticPath); // 读取静态资源 const statics = readFileSync(staticsourcepath); // _assets增加资源 _assets[`$&#123;filename&#125;`] = &#123; source() &#123; return statics; &#125;, size() &#123; return statics.length; &#125; &#125; &#125;) &#125; &#125;) &#125; &#125; module.exports = MdToHtmlPlugin; index.js中做了哪些事件？ 读取md文件，用到了node内置模块fs的方法，将md内容存到为数组中； 将数组传入编译文件compiler的compileHTML中进行编译，返回html字符串和静态资源的路径，htmlStr如下： 读取template模板html文件，将文件内的模板替换为htmlStr 最后把html文件和静态资源放到_assets中，交由webpack处理 2、compiler模板编译文件// compiler.js const &#123; guid &#125; = require('./util'); const &#123; basename &#125; = require('path'); const &#123; REG_MARK, REG_TITLE, REG_ORDER, REG_DISORDER, REG_LINK, REG_IMG, TAGTYPE_SIMPLE, TAGTYPE_NESTING, REG_LINK_STYLE &#125; = require('./constant'); function createTree(tplArr) &#123; // 存放结果 let htmlTree = &#123;&#125;; // 上一个标识符 let lastMark = ''; let uid = 0; // 字符串相关的东西最好不要做封装，老老实实的写最好，不同的标签有不同的处理方法 tplArr.forEach((tplItem) => &#123; // 去掉\\r回车的影响 tplItem = tplItem.replace(/\\r/, ''); // 正则 const matched_mark = tplItem.match(REG_MARK); const matched_link = tplItem.match(REG_LINK); const matched_img = tplItem.match(REG_IMG); // 匹配到md语法，不为空 if (matched_mark) &#123; // matched_mark[1]就是去掉空格的 md标识 const mark = matched_mark[1]; // input就是匹配到的md语法，input: '# h1标题\\r' const input = matched_mark['input']; // 匹配到#号的 if (REG_TITLE.test(mark)) &#123; // 根据#号的个数 判断是h几 const tag = `h$&#123;mark.length&#125;`; //将'# h1标题\\r'中的'# '干掉，最终得到'h1标题\\r' const tagContent = input.replace(REG_MARK, '') // REG_TITLE.test(lastMark) if ((lastMark === mark)) &#123; htmlTree[tag].children = [...htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`], `&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; else &#123; lastMark = mark; uid = guid(); htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`] = &#123; type: TAGTYPE_SIMPLE, children: [`&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125; // 无序列表 if (REG_DISORDER.test(mark)) &#123; //将'- ul第一项\\r'中的'- '干掉，最终得到'ul第一项\\r' const tagContent = input.replace(REG_MARK, ''); const tag = `li`; // 上一个是不是`-` if (REG_DISORDER.test(lastMark)) &#123; // '- ul第i项\\r' 放到一起 htmlTree[`ul-$&#123;uid&#125;`].children = [...htmlTree[`ul-$&#123;uid&#125;`].children, `&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; else &#123; uid = guid(); lastMark = mark; // 加一个随机后缀key htmlTree[`ul-$&#123;uid&#125;`] = &#123; type: TAGTYPE_NESTING, // 外层需要一个ul children: [`&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125; // 有序列表 是不是以数字开头的，如果是数字开头，没有.呢？ if (REG_ORDER.test(mark)) &#123; const tagContent = input.replace(REG_MARK, ''); const tag = `li`; if (REG_ORDER.test(lastMark)) &#123; htmlTree[`ol-$&#123;uid&#125;`].children = [...htmlTree[`ol-$&#123;uid&#125;`].children, `&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; else &#123; lastMark = mark; uid = guid(); htmlTree[`ol-$&#123;uid&#125;`] = &#123; type: TAGTYPE_NESTING, children: [`&lt;$&#123;tag&#125;>$&#123;tagContent&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125; &#125; else if (matched_link) &#123; // 超链接的处理 // '百度' const link_title = matched_link[1]; // 'http://www.baidu.com' const link_href = matched_link[2]; // '[百度](http://www.baidu.com)' const input = matched_link['input']; const tag = `a`; uid = guid(); htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`] = &#123; type: TAGTYPE_SIMPLE, children: [`&lt;$&#123;tag&#125; href=\"$&#123;link_href&#125;\" target=\"_blank\" style=\"$&#123;REG_LINK_STYLE&#125;\">$&#123;link_title&#125;&lt;/$&#123;tag&#125;>`] &#125; &#125; else if (matched_img) &#123; // 图片的处理 const tag = `img`; // '图片' const img_title = matched_img[1]; // 'public/testimages.png' const img_src = matched_img[2]; // 'testimages' const img_file = basename(img_src); uid = guid(); htmlTree[`$&#123;tag&#125;-$&#123;uid&#125;`] = &#123; type: TAGTYPE_SIMPLE, staticResources: &#123; filename: img_file, staticPath: img_src &#125;, children: [`&lt;$&#123;tag&#125; src=\"./$&#123;img_file&#125;\" alt=\"$&#123;img_title&#125;\">&lt;/$&#123;tag&#125;>`] &#125; &#125; &#125;) return htmlTree; &#125; // 转成树形结构 或者AST function compileHTML(templateContentArr) &#123; // templateContentArr数组内容 // 转成树形结构 const htmlTree = createTree(templateContentArr) // static资源 const staticSource = []; // 拼接结果 let htmlStr = ''; // 保存当前遍历到的 key let currItem; for (let key in htmlTree) &#123; currItem = htmlTree[key]; htmlTree[key]?.staticResources &amp;&amp; staticSource.push(htmlTree[key]?.staticResources) // 等于single，直接拼接 if (currItem.type === TAGTYPE_SIMPLE) &#123; currItem.children.forEach(tag => &#123; htmlStr += tag; &#125;); &#125; else if (currItem.type === TAGTYPE_NESTING) &#123; // 外层要套一个标签的，不能直接拼接 // 获取外层的标签，就是htmlTree的key const outerTag_Start = `&lt;$&#123;key.split('-')[0]&#125;>`; const outerTag_End = `&lt;/$&#123;key.split('-')[0]&#125;>`; let currStr = \"\" + outerTag_Start; currItem.children.forEach(tag => &#123; currStr += tag; &#125;) // 结束标签 currStr += outerTag_End; htmlStr += currStr; &#125; &#125; return &#123; htmlStr, staticSource &#125;; &#125; module.exports = &#123; compileHTML &#125; compiler做了什么？ compileHTML方法中，调用createTree方法将数组转化为树形结构，htmlTree如下： createTree的作用 遍历数组，匹配不同的md标识符，如 #号代表标题，(num.)代表有序列表，(-)代表无序列表，![]()代表图片标识等，对不同的标识做不同的处理，如果是列表，需要在外层嵌套ul、ol。匹配md标识，用到了正则表达式。 如果是超链接，则设置a标签，设置a标签默认样式，href属性。 如果是图片，则设置img标签，获取图片的路径，设置src、alt等属性。 最后返回htmlTree 遍历htmlTree的所有value，如果是simple类型，则直接拼接结果，如果是nesting类型，则需要在外面嵌套ol、ul 最后返回处理结果htmlStr、staticSource。 3、其他文件说明constant.js// 以空字符串开头，以空格结尾，找到里边的所有字符 const REG_MARK = /^(.+?)\\s/; // 以#号开头的，最终转化成h标签，有可能是1个、2个、3个。。。 const REG_TITLE = /^\\#/; // 以数字开头 有序列表 const REG_ORDER = /^\\d/; // 以-开头的 最终转化成li const REG_DISORDER = /^\\-/; // 匹配 []() 超链接 const REG_LINK = /^\\[(.+?)\\]\\((.+?)\\)$/; // 匹配 []() 超链接 const REG_IMG = /^\\!\\[(.+?)\\]\\((.+?)\\)$/; // 简单类型 const TAGTYPE_SIMPLE = 'simple'; // 需要嵌套包裹 const TAGTYPE_NESTING = 'nesting'; // 超链接默认样式 const REG_LINK_STYLE = `color: #3489fd;font-weight: 500;text-decoration: none;` // 需要替换 模板html文件里的字符串 const TEMPLATE_MARK = '&lt;!--templateString-->'; // 插件名称 const PLUGIN_NAME = 'md-to-html-plugin'; module.exports = &#123; REG_MARK, REG_TITLE, REG_ORDER, REG_DISORDER, REG_LINK, REG_IMG, TAGTYPE_SIMPLE, TAGTYPE_NESTING, REG_LINK_STYLE, TEMPLATE_MARK, PLUGIN_NAME &#125; template.html util.js// 生成uid function guid() &#123; let res = \"\"; for (let i = 1; i &lt;= 8; i++) &#123; let n = Math.floor(Math.random() * 16.0).toString(16); res += n; &#125; return res; &#125; module.exports = &#123; guid &#125; 4、创建webpack.config.js文件在根目录下新建notebook.md，并写入简单的md标记，引入MdToHtmlPlugin插件，配置MdToHtmlPlugin的template和filename const &#123; resolve &#125; = require('path') const MdToHtmlPlugin = require('./plugins/md-to-html-plugin'); const config = &#123; // 模式 mode: \"development\", // 入口文件 entry: resolve(__dirname, 'src/app.js'), output: &#123; path: resolve(__dirname, 'dist'), filename: \"app.js\" &#125;, // 配置自定义插件 plugins: [ new MdToHtmlPlugin(&#123; template: resolve(__dirname, 'notebook.md'), // 我们需要解析的文件 filename: 'notebook.html' // 解析后的文件名 &#125;) ] &#125; module.exports = config; notebook.md文件内容如下： 5、调试和运行 执行 npm run build 在dist文件夹下输出打包后文件 打开notebook.html看结果","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]},{"title":"【webpack】如何成为一名webpack配置工程师","slug":"engineering/webpack-base","date":"2021-02-09T20:33:11.000Z","updated":"2022-07-09T03:02:13.997Z","comments":true,"path":"2021/02/10/engineering/webpack-base/","link":"","permalink":"http://example.com/2021/02/10/engineering/webpack-base/","excerpt":"","text":"Webpack基础为什么需要构建工具，它有什么作用？ 转换ES6语法：ES6语法在前端领域广泛使用，然而很多浏览器对ES6没有提供全面的兼容和支持，所以需要构建工具来对ES6语法进行编译。 转换JSX、vue指令：前端框架React的JSX，VUE指令都是浏览器无法识别的，需要编译转换。 CSS前缀补全，预处理器：经常使用less、sass等预编译语法写样式，需要构建工具做编译转化为CSS。 多媒体资源压缩：经常使用的图片、字体、图标等多媒体资源，需要构建工具对它们进行压缩，减少体积大小。 压缩混淆代码：当前的前端开发都是模块开发，也引入了大量的依赖包，为了让浏览器对代码的加载更快，需要构建工具对代码进行压缩和混淆。 Webpack基础知识 loader作用：webpack仅支持js和json文件，想对其他类型的文件打包需要使用loader，转化成为有效的模块。loader本身是一个函数，接受源文件作为参数，返回转换的结果，loader的执行顺序是从右往左。 plugins作用：plugins是增强webpack功能，是 bundle 的一个优化，干预输出的结果，作用于整个构建过程。可以简单理解为任何loader没办法做的事情，都可以用plugins去完成。 chunk和bundle：chunk是webpack打包过程中依赖，bundle是输出的产物。 基本的配置文件如下：// 为JSON模块使用具名导出，可能需要使用 package.json 中的一些字段 // package.json的 homepage 属性会告诉 webpack 项目的路径需要打包到哪个路径下，如github路径、CDN路径 import pkg from './package.json'; // console.log(pkg.version); const path = require('path'); module.exports = &#123; mode: 'development', // 模式：development、production、none entry: './src/index.js', // 打包入口地址 output: &#123; filename: 'bundle.js', // 输出文件名 path: path.join(__dirname, 'dist') // 输出文件目录 &#125; module: &#123; rules: [ ] &#125;, plugin: [] &#125; mode模式 名称 描述 development 开发模式，打包更加快速 production 生产模式，打包比较慢，会开启 tree-shaking、压缩代码和清除无用代码 none 不开启任何优化选项 development：更快的构建速度、热更新(hot)、快速定位问题(sourcemap ) production: 生产环境下会自动压缩js代码，构建体积小（代码压缩 + tree-shaking）、代码分割、压缩images。 webpack常用指令 webpack默认配置文件是根目录下的webpack.config.js，自定义配置打包文件的命令：webpack --config filename 监听变动并自动打包（文件监听是在发现源码发生变化时，自动重新构建出新的输出文件）： 方式一：在package.json的script命令添加：webpack --watch 方式二：在webpack.config.js中设置watch: true 压缩混淆代码：webpack -p 方便出错时能查阅更详尽的信息：webpack --display-error-details 让编译的输出内容带有进度和颜色：webpack --progress --colors 模块热替换，在前端代码变动的时候无需整个刷新页面，只把变化的部分替换掉：webpack-dev-server --hot inline选项会为入口页面添加热加载功能，即代码改变后重新加载页面（刷新浏览器）：webpack-dev-server --inline Webpack的整个生命周期Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口 根据配置中的 entry 找出所有的入口文件 编译模块 从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块被编译后的最终内容以及它们之间的依赖关系 完成模块编译 在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上过程中，在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，并且plugin可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 常见的loaders 名称 描述 babel-loader 转换ES6、ES7等JS新特性语法 css-loader 加载和解析.css文件，不会将样式加载到页面上 style-loader 将处理好的css以style标签形式添加到页面上 postcss-loader 添加CSS3部分属性的浏览器前缀（先添加前缀，再使用css-loader） less-loader 将less文件转换成css ts-loader 将TS转换成JS vue-loader 支持 Vue thread-loader 正常情况下webpack开一个进程打包，thread-loader作用是多进程打包JS和CSS file-loader 解决图片、字体、媒体等资源引入问题，并将资源copy到指定目录，默认为 dist url-loader url-loader内部使用了file-loader，可以设置较小的资源自动base64，多了一个limit的配置 raw-loader raw-loader可以将文件转化成字符串的形式导入 注意：webpack5内置了资源处理模块，file-loader、url-loader和raw-loader都可以不用安装 常见的plugins 名称 描述 HtmlWebpackPlugin 将打包好的bundle如js、css 文件可以自动引入到html中 mini-css-extract-plugin 将CSS从 bunlde文件里提取成一个独立的CSS文件(MiniCssExtractPlugin.loader) TerserPlugin 压缩JS，支持ES6，清除console（webpack5内置） splitchunksplugin 将chunks相同的模块代码提取成公共js CleanWebpackPlugin 自动清空打包目录 copyWebpackPlugin 将文件或者文件夹拷贝到构建的输出目录（webpack5内置） UglifyjsWebpackPlugin 压缩JS ZipWebpackPlugin 将打包出的资源生成一个zip包 基本的webpack配置 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 生成html模板 const MiniCssExtractPlugin = require('mini-css-extract-plugin'); // 将css单独提取 const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); // 压缩css const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin'); // 打包输出前清空文件夹 const path = require('path'); // 通过 process.env.NODE_ENV 获取当前环境 module.exports = &#123; mode: 'development', // production or development or none /** * 单入口entry: './src/js/index.js' * 多入口entry: &#123; key: 'value' &#125; * key可自定义，value是入口文件路径 */ entry: &#123; // 定义应用的入口点 src/app.js，并命名为 main main: path.resolve(__dirname, './src/app.js'), index: './src/js/index.js', // 输出index test: './src/js/test.js', // 输出test &#125;, /** * filename, path * [name].[hash:8].bundle.js、[name].[chunkhash:8].bundle.js * hash字段是根据每次编译compilation的内容计算所得、chunkhash是根据模块内容计算出的hash值 */ output: &#123; // 打包输出的文件名 // name是一个占位符，通过占位符确保文件名称的唯一，一般entry多入口使用占位符区分 filename: 'js/[name].[contenthash:10].js', // 10位hash值, name取原来的文件名 // 定义打包结果的输出位置build目录 path: path.resolve(__dirname, 'build'), // publicPath表示的是打包生成的index.html文件里面引用资源的前缀 // webpack5清除输出目录可用，无需安装clean-webpack-plugin clean: true &#125;, /** * test指定匹配规则 * use指定使用的loader名称 */ module: &#123; // 定义处理源文件的规则，rules 下会按顺序使用匹配的规则 rules: [ &#123; // 遇到 .js 结尾的文件则使用这个规则 test: /\\.js$/, // 忽略 node_modules 目录下的 js 文件 // 在配置 loader 的时候，我们需要更精确的去指定 loader 的作用目录或者需要排除的目录， // 通过使用 include 和 exclude 两个配置项 include: path.join(__dirname, 'src'), // 符合条件的模块进行解析 exclude: /node_modules/, // 排除符合条件的模块，不解析 use: [ /* 开启多线程打包。 进程启动大概为600ms，进程通信也有开销。 只有工作消耗时间比较长，才需要多线程打包 */ &#123; loader: 'thread-loader', options: &#123; workers: 2 // 进程2个 &#125; &#125;, &#123; // 使用 babel-loader 处理 js loader: 'babel-loader', // babel-loader 的一些选项 options: &#123; presets: [ '@babel/preset-env', // 确保 Babel 能够处理 JSX 语法 &#123; // 按需加载 useBuiltIns: 'usage', // 指定core-js版本 corejs: &#123; version: 3 &#125;, // 指定兼容性做到哪个版本浏览器 targets: &#123; chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' &#125; &#125; ], // babel 在转译 js 过程中时间开销比价大，将 babel-loader 的执行结果缓存起来，重新打包的时候，直接读取缓存 // 开启babel缓存, 第二次构建时，会读取之前的缓存, 速度会更快一点 cacheDirectory: true // 启用缓存，缓存位置： node_modules/.cache/babel-loader &#125;, &#125;, ] &#125;, &#123; test: /\\.css$/, /** * css-loader用于处理加载.css文件，并且转换成commonjs对象 * style-loader将样式通过&lt;style>标签插入到head中 */ use: [ // 'style-loader', // 以 style标签 添加到head MiniCssExtractPlugin.loader, // 将js中的css单独提取出来 'css-loader', // 将css文件整合到js文件中 ] &#125;, &#123; // 检测 less 文件 test: /\\.less$/, // 使用了三个 loader，注意执行顺序是数组的倒序 // 也就是先执行 less-loader ，将less转换成css use: [ // 'style-loader', MiniCssExtractPlugin.loader, // 缓存一些性能开销比较大的 loader 的处理结果，缓存位置：node_modules/.cache/cache-loader 'cache-loader', 'css-loader', // 'less-loader' &#123; loader: 'less-loader', options: &#123; sourceMap: true, // 替换某个属性值，如修改antd默认主题色@primary-color，入口文件样式引入@import '~antd/dist/antd.less'; modifyVars: &#123; '@primary-color': '#13c2c2', &#125; &#125; ], &#125;, &#123; // webpack 默认处理不了html中img图片 // 匹配 图片资源 test: /\\.(jpg|png|gif|jpeg)$/, // 通过 url-loader 或者 file-loader 处理图片资源 // url-loader内部使用了file-loader，可以设置较小的资源自动base64 // base64格式的图片 可打包在js中直接使用 loader: 'url-loader', options: &#123; // 图片大小小于8kb，就会被base64处理 // 优点: 减少请求数量（减轻服务器压力） // 缺点：图片体积会更大（文件请求速度更慢） limit: 8 * 1024, // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs // 解析时会出问题：[object Module] // 解决：关闭url-loader的es6模块化，使用commonjs解析 esModule: false, // 给图片进行重命名 // [hash:10]取图片的hash的前10位 // [ext]取文件原来扩展名 name: '[contenthash:10].[ext]', outputPath: 'imgs', &#125; &#125;, &#123; test: /\\.html$/, // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理） loader: 'html-loader' &#125;, // 打包其他资源(除了html/js/css资源以外的资源) &#123; // file-loader处理字体文件 // 排除css/js/html资源 test: /\\.(woff|woff2|ttf|eot|otf)$/, exclude: /\\.(css|js|html|less)$/, loader: 'file-loader', options: &#123; name: '[contenthash:10].[ext]', outputPath: 'media' &#125; &#125;, ], &#125;, plugins: [ // 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS），并配置了页面的 title new HtmlWebpackPlugin(&#123; title: 'Webpack Output', // 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS） template: './src/index.html', // 压缩html代码 minify: &#123; // 移除空格 collapseWhitespace: true, // 移除注释 removeComments: true &#125; &#125;), // 提取js中的css成单独文件 new MiniCssExtractPlugin(&#123; // 对输出的css文件进行重命名，如filename: 'css/built.css'，放到输出目录的css文件夹下 filename: '[name].[hash:8].css' &#125;), // 打包输出前清空文件夹clean-webpack-plugin（webpack5不需要） new CleanWebpackPlugin(), // 压缩css new OptimizeCssAssetsWebpackPlugin(), ], /* 1. 可以将node_modules中代码单独打包一个chunk最终输出（单入口） 2. 自动分析多入口文件的chunk中，有没有公共的文件。如果有会打包成单独一个chunk */ optimization: &#123; splitChunks: &#123; // 解决代码引入的复用问题，不会重复打包多次 chunks: 'all' &#125; &#125;, // 开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器） // 特点：只会在内存中编译打包，不会有任何输出 devServer只能在 开发环境使用，生产环境不需要 devServer: &#123; // 项目构建后路径 contentBase: resolve(__dirname, 'build'), // 启动gzip压缩 compress: true, // 端口号 port: 8888, // 自动打开浏览器 open: true, // 开启HMR功能(webpack优化配置) // 当修改了webpack配置，新配置要想生效，必须重新webpack服务 hot: true // HMR只能在 开发环境使用，生产环境不需要 &#125;, // 拒绝XXX包 被打包进来，再用cdn 引进来(在html中手动通过srcipt标签引入、link引入) // CDN内容分发网络，分布式存放静态资源，缓解服务器压力，就近获取资源，加快访问速度 // 某些包需要用cdn引入进来，就可以使用externals externals: &#123; // 拒绝jQuery被打包进来 jquery: 'jQuery' // jquery: '$' &#125;, devtool: 'eval-source-map' // source-map &#125;; babel（解析ES6、处理jsx） 解析ES6，需要在rules里面匹配js文件，并use: ‘babel-loader’。babel-loader是依赖babel的，需要在根目录创建babel的配置文件.babelrc。 需要安装@babel&#x2F;core、@babel&#x2F;preset-env、babel-loader babel-loader 使用 Babel 加载 ES2015+ 代码并将其转换为 ES5 @babel&#x2F;core Babel 编译的核心包 @babel&#x2F;preset-env Babel 编译的预设，可以理解为 Babel 插件的超集 // .babelrc &#123; // 一系列plugins的集合 \"presets\": [ \"@babel/preset-env\", // 增加ES6的babel preset配置，解析ES6 \"@babel/preset-react\", // 安装该依赖，并增加react的babel preset配置，解析react相关的语法，jsx // @babel/preset-typescript ], // 一个plugins对应一个功能 \"plugins\": [ // 处理 装饰器的使用 [\"@babel/plugin-proposal-decorators\", &#123; legacy: true &#125;], [\"@babel/plugin-proposal-class-properties\", &#123; loose: true &#125;], ] &#125; babel-plugin vs babel-preset（预设）Babel polyfill 常见配置对比 babel存在太多的plugin，实现某种功能，比如ES2015语法兼容时需要用到众多的插件。preset是plugin的集合，将多个plugin合并在一起（预设是插件的集合） 插件plugin和预设preset的执行顺序 plugin先执行，preset后执行 plugin集从前往后执行 preset集从后往前执行 @babel&#x2F;preset-env（官方提供），作用是根据 targets 的配置引入对应插件来实现编译和 polyfill，自动根据 targets 来引入需要的插件 所谓Polyfill就是这样解决API的兼容问题的，抹平差异化 官方给出了两种 polyfill 方案： babel-polyfill：会污染全局适合在业务项目中使用。（Babel7.4.0版本开始，babel&#x2F;polyfill 已经被废弃，推荐直接使用core-js） babel-runtime：不污染全局适合在组件或类库项目中使用。 开启 polyfill 功能要指定它的引入方式，也就是 useBuiltIns。设置为 usage 是在每个模块引入用到的，设置为 entry 是统一在入口处引入 targets 需要的。 polyfill 的实现就是 core-js，需要再指定下 corejs 版本，一般是指定 3 @babel&#x2F;preset-env 会导致多个模块重复注入同样的代码，会污染全局环境。解决这个问题就要使用 @babel&#x2F;plugin-transform-runtime 插件 这样就不会多个模块重复注入同样的实现代码了，而且 core-js 的 api 也不是全局引入了，变成了模块化引入。 这样就解决了 corejs 的重复注入和全局引入 polyfill 的两个问题 @babel&#x2F;plugin-transform-runtime 的功能，把注入的代码和 core-js 全局引入的代码转换成从 @babel&#x2F;runtime-corejs3 中引入的形式 @babel&#x2F;runtime-corejs3 就包含了 helpers、core-js、regenerator 这 3 部分 &#123; presets: [ ['@babel/preset-env', &#123; targets: 'chrome 30', debug: true, useBuiltIns: 'usage', corejs: 3 &#125;] ], plugins: [ ['@babel/plugin-transform-runtime', &#123; corejs: 3 // 插件也是处理 polyfill ，也就同样需要指定 corejs 的版本 &#125;] ] &#125; babel的原理babel是一个JS、JSX、TS 的编译器，能把新语法写的代码转换成目标环境支持的语法的代码 babel工作的三个步骤 解析：将源码解析为AST（词法解析和语法解析） 转换：旧AST转换成为新的AST（应用插件&#x2F;预设中，对AST节点增删改查的操作） 生成：根据AST生成源码（深度优先遍历AST生成转译后的源码） @bable&#x2F;core 内核@bable&#x2F;core类似一个调度器，并不直接实现功能细节，而是调度各模块插件去实现相关功能 @babel&#x2F;core的功能可以简单概况为 向外读取配置 &#x3D;&gt; 向内调度插件模块协同工作 &#x3D;&gt; 向外输出转译后的源码。详细版本如下： 加载配置文件，读取所需使用的插件、预处理器等等 调用@babel&#x2F;parser进行词法分析、语法分析后转换为AST 调用@babel&#x2F;traverse对AST进行遍历，并采用visitor模式应用配置项中的插件对AST进行转换 调用@babel&#x2F;generator生成源码和源码对应的sourceMap 解析（parse）解析的核心是：词法分析将源码分词、语法分析将分词后的源码按照JS语法逻辑转换为AST（抽象语法树）。 词法分析：简单理解为：将源码分割为不同种类，保留关键词（如function）、条件判断词（if&#x2F;else）、运算符、数字、字符串、空格等 语法分析：将词法分析生成的分词，组合为各类型的语法短语（抽象语法树AST） 转换（Traverser）转换器会遍历AST树，然后按照配置的插件对其中需要转换的节点进行操作 生成（generator）调度器调用generator插件将AST转译成源码 babel-clibabel官方提供的脚手架，允许你以命令行的方式运行babel $ npm install babel-cli -g ​ # 将示例js输出到编译后的js中 $ babel example.js -o compiled.js webpack文件监听的原理轮询判断文件的最后编辑时间是否变化，某个文件发生变化了，并不会立刻告诉监听者，而是先缓存起来，等aggregateTimeout. watch 和 watchOptions module.exports = &#123; // 默认是false，不开起监听 watch: true, watchOptions: &#123; // 默认为空，不监听的文件或者文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行，默认300ms aggregateTimeout: 300, // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒检查1次变化 // 间隔xxx秒检查一次变化 poll: 1000 &#125; &#125; 文件指纹打包后输出的文件名的后缀，如 index_0a4dfa7c33787eec103e.chunk.js中的0a4dfa7c33787eec103e hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改 chunkhash：对于 JS 文件，和 webpack 打包的 chunk 相关，不同的entry会生成不同的 chunkhash 值 contenthash：将根据资源内容创建出唯一 hash。当资源内容发生变化时，[contenthash] 也会发生变化。 JS 的文件指纹设置，在output 的 filename，使用 [chunkhash] CSS 的文件指纹设置，可以在MiniCssExtractPlugin使用[contenthash] 使用hash的场景还应该结合mode来考虑，如果mode是development的时候，在使用hmr的情况下，尽量避免使用chunkhash和contenthash，应该使用hash。而在mode是production的时候，就是不用hmr的情况下，这时候就适合使用chunkhash了。hmr只在development开发阶段使用。 js使用chunkhash是便于寻找资源，js的资源的关联度更高；而css采用contenthash是因为css一般是根据不同的页面书写的，css资源之前的关联度不高，也就不用在其他资源修改，而css部分没有修改的时候重新更新css。 MiniCssExtractPlugin作用 将 CSS 提取到单独的文件中 为每个包含 CSS 的 JS 文件创建一个 CSS 文件 支持按需加载 CSS 和 SourceMaps 下载 npm i mini-css-extract-plugin -D const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; output: &#123; path: path.resolve(__dirname, '/dist'), filename: '[name][chunkhash:8].js' &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name][contenthash:8].css' &#125;) ] &#125; 图片的文件指纹设置在 file-loader或者url-loader 的options参数中设置name，使用[contenthash] 当 webpack 配置中使用了 [hash] 占位符时，请考虑将它改为 [contenthash] 占位符名称 含义 [ext] 资源后缀名 [name] 文件名称 [path] 文件的相对路径 [folder] 文件所在的文件夹 [hash] 每次构建生成的唯一 hash 值，默认是 md5 生成 [chunkhash] 根据chunk生成hash值 [contenthash] 根据文件内容生成hash 值，默认是md5生成，默认有32位，一般取前8位 [emoji] 一个随机的指代文件内容的 emoji hash：任何一个文件改动，整个项目的构建 hash 值都会改变； chunkhash：文件的改动只会影响其所在 chunk 的 hash 值； contenthash：每个文件都有单独的 hash 值，文件的改动只会影响自身的 hash 值； const path = require('path'); module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: 'images/[name][hash:8].[ext]' &#125; &#125; ] &#125; ] &#125; &#125; sourcemap sourcemap是一种提供源代码到构建后代码映射技术（如果构建后代码出错了，通过映射可以追踪源代码错误） sourcemap一般在开发环境使用，生产环境关闭 关键字 说明 eval 使用eval包裹模块代码 source-map 产生.map文件 cheap 只需要定位到行信息，不需要列信息 inline 将.map作为DataURI嵌入，不单独生成.map文件 module 包含loader的sourcemap，展示源代码中的错误位置 sourcemap的类型 不开起source-map调试是打包之后的内容，不方便调试 开启source-map调试看到的是源代码，方面调试 module.exports = &#123; devtool: 'source-map' &#125; sourcemap的类型总结[inline-、hidden-、eval-][nosources-][cheap-[module-]]source-map 说明：外部则是生成xxx.js.map文件，内联则是将.map内嵌，不生成.map文件，内联构建速度更快，但是体积比外部大 source-map：外部，能显示出错误代码准确信息和源代码的错误位置 inline-source-map：内联，只生成一个内联source-map，能显示错误代码准确信息和源代码的错误位置 eval-source-map：内联，每一个文件都生成对应的source-map，都在eval中，能显示错误代码准确信息和源代码的错误位置(文件后面会多一个hash值，print.js?8d3a) hidden-source-map：外部，为了隐藏源代码而诞生的，错误代码能显示错误原因，但是没有源代码的错误位置，不能追踪源代码错误，只能提示到构建后代码的错误位置 nosources-source-map：外部，为了隐藏源代码而诞生的，错误代码准确信息，但是没有任何源代码信息(找不到任何代码信息) cheap-source-map：外部，能显示错误代码准确信息和源代码的错误位置，只能精确的行的错误，不能精确到列（比如第四行只是后面的一个代码错误，但是是整行报错，而source-map可以准确提示哪一行的那一列出错了，同一行没错误的分号(;) 不提示错误） cheap-module-source-map：外部，能错误代码准确信息和源代码的错误位置，有module，会将loader的source map加入。 开发环境：速度快，调试更友好 速度快慢，eval&gt;inline&gt;cheap&gt;… eval-cheap-souce-map (有cheap只精确到行) eval-source-map 调试更友好 souce-map cheap-module-souce-map(module会将loader的source map加入) cheap-souce-map eval-source-map(调试最友好) 、eval-cheap-module-souce-map(调试性能最友好)、react脚手架（cra）默认使用的是eval-source-map 本地开发推荐eval-cheap-souce-map 本地开发首次打包慢点没关系，因为eval缓存的原因，rebuild会很快 开发中，我们每行代码不会写的太长，只需要定位到行就行，所以加上cheap 我们希望能够找到源代码的错误，而不是打包后的，所以需要加上module 生产环境：源代码要不要隐藏? 调试要不要更友好 内联会让代码体积变大，所以在生产环境不用内联，我们要让体积变小，就不要内联，而采用外部的方式。 nosources-source-map 全部隐藏（源码和构建后的代码都会隐藏） hidden-source-map 只隐藏源代码，会提示构建后代码错误信息 source-map(调试友好) cheap-module-souce-map（cheap的速度会快一点） 推荐none：不想别人看到我的源代码 webpack进阶自动清理构建产物 通过 npm scripts 清理构建目录 rm -rf ./dist &amp;&amp; webpack rimraf ./dist &amp;&amp; webpack 避免构建前每次都需要手动删除 dist，使用 clean-webpack-plugin，默认会删除 output 指定的输出目录 const path = require('path'); const CleanWebpackPlugin = require('clean-webpack-plugin'); module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name][chunkhash:8].js' &#125;, plugins: [ new CleanWebpackPlugin() ] &#125; webpack之PostCSS插件autoprefixer自动补齐CSS3前缀为了实现 CSS3 前缀的自动补齐，使用autoprefixer 插件：对代码打包完成后的 CSS 进行后置处理，与 postcss-loader 结合使用Can I Use 插件 查看兼容性 npm i autoprefixer postcss-loader -d const path = require('path'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name]_[chunkhash:8].js' &#125;, // 有单行注释代码的时候，需要把less loader放到后面，不然会报错的 module: &#123; rules: [ &#123; test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: () => [ require('autoprefixer')(&#123; // browsers 指定 autoprefixer 所需要兼容的浏览器版本 // 最近两个版本，浏览器使用量大于1% browsers: ['last 2 version', '>1%', 'ios 7'] // browsers改成overrideBrowserslist &#125;) ] &#125; &#125; ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;) ] &#125; 移动端CSS px自动转换成rempx2rem-loader：将 px 自动转换成 rem const path = require('path'); module.exports = &#123; module: &#123; rules: [ &#123; test: /.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader', // 移动端CSS px自动转换成rem &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75, // 1rem = 75px remPrecision: 8 // px 转换为 rem 时小数点后的位数 &#125; &#125; ] &#125; ] &#125; &#125; lib-flexible：页面渲染时计算根元素的 font-size 值(可以使用手淘的 lib-flexible 库https://github.com/amfe/lib-flexible) 将 node_modules -&gt; lib-flexible -&gt; flexible.js 文件全部代码手动引入到 模板html 文件中 多页面应用(PWA) 页面有多个入口，多页面应用每个应用都是解耦的，多页面应用对SEO更加友好。 多页面跳转需要刷新所有资源，每个公共资源(js、css等)需选择性重新加载; 页面跳转：使用window.location.href &#x3D; “.&#x2F;index.html”进行页面间的跳转； 数据传递：可以使用path?account&#x3D;123&amp;password&#x3D;456 路径携带数据传递的方式，或者localstorage、cookie等存储方式; 每个页面对应一个entry，一个html-webpack-plugin，缺点是每次新增或者删除页面需要修改webpack配置 解决方案：动态获取entry和设置html-webpack-plugin的数量 约定js入口文件放置格式为 ./src/xxx/index.js，xxx为某个特定模块的名称，html模板为index.html 利用glob.sync读取文件：glob // npm i glob -d glob.sync(path.join(__dirname, './src/*/index.js')) // webpack.config.js const glob = require('glob'); const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const setMPA = () => &#123; const entry = &#123;&#125;; const htmlWebpackPlugins = []; const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js')); Object.keys(entryFiles) .map((index) => &#123; const entryFile = entryFiles[index]; const match = entryFile.match(/src\\/(.*)\\/index\\.js/); const pageName = match &amp;&amp; match[1]; entry[pageName] = entryFile; htmlWebpackPlugins.push( new HtmlWebpackPlugin(&#123; inlineSource: '.css$', template: path.join(__dirname, `src/$&#123;pageName&#125;/index.html`), filename: `$&#123;pageName&#125;.html`, chunks: ['vendors', pageName], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false &#125; &#125;) ); &#125;); return &#123; entry, htmlWebpackPlugins &#125; &#125; const &#123; entry, htmlWebpackPlugins &#125; = setMPA(); module.exports = &#123; entry: entry, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name]_[chunkhash:8].js' &#125;, mode: 'production', // module: &#123;......&#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;), new OptimizeCSSAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano') &#125;), new CleanWebpackPlugin(), new HTMLInlineCSSWebpackPlugin() ].concat(htmlWebpackPlugins) &#125;; 热更新（HMR）1、使用 webpack-dev-server 自动编译并运行，不需要手动刷新浏览器，每次修改代码都需要重新执行 webpack 命令，可以使用 webpack-dev-server 自动打包运行 不输出文件，而是放在内存中，watch是放在磁盘里 与 HotModuleReplacementPlugin 插件配合使用 npm i webpack-dev-server -d webpack.config.js const path = require('path'); const webpack = require('webpack'); module.exports = &#123; output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].js' &#125;, // 热更新一般只在开发模式使用 mode: 'development', plugins: [ new webpack.HotModuleReplacementPlugin() ], devServer: &#123; // 告诉服务器从哪里提供静态资源（只有想提供静态文件时才需要） contentBase: path.resolve(__dirname, 'public'), // 静态资源所在的路径，默认为项目根目录 hot: true // 开启热更新 port: 8888, // 端口号 compress: true, //是否启动压缩 gzip open:true // 是否自动打开浏览器 // devServer里面的publicPath表示的是打包生成的静态文件所在的位置 //（若是devServer里面的publicPath没有设置，则会认为是output里面设置的publicPath的值） &#125; &#125; package.json，–open打开浏览器 &#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server --open\" &#125; &#125; 热更新原理分析 首次编译：① -&gt; ② -&gt; A -&gt; B 修改代码后的热更新：① -&gt; ② -&gt; ③ -&gt; ④ HMR Server -&gt; HMR Runtime 以json形式传递 概念 描述 Webpack Compiler(webpack编译器) 将JS编译成 Bundle HMR Server 将热更新的文件传输给 HMR Runtime Bundle Server 提供文件在浏览器的访问，提供类似的服务器环境访问，如localhost:3003&#x2F;bundle.js，服务器和浏览器是ws链接 HMR Runtime 会被注入到浏览器，更新文件的变化 bundle.js 构建输出的文件 webpack之JS、css和html文件的压缩webpack4 内置了uglifyjs-webpack-plugin 插件（mode为production），默认打包出的 JS 文件已压缩过， webpack5 内置了terser-webpack-plugin 插件 CSS 文件的压缩 # 安装依赖，使用 optimize-css-assets-webpack-plugin 插件，同时使用预处理器 cssnano npm i optimize-css-assets-webpack-plugin cssnano -D html文件的压缩 const path = require('path'); const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; entry: &#123; index: './src/index.js', &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name][chunkhash:8].js' &#125;, plugins: [ // 添加 css 压缩配置 new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require('cssnano') &#125;), // 通常是一个html页面对应一个HtmlWebpackPlugin，多个html就使用多个HtmlWebpackPlugin new HtmlWebpackPlugin(&#123; template: path.join(__dirname, 'src/index.html'), // html 模板所在的位置 filename: 'index.html', // 指定打包出 html 的文件名称 chunks: ['index'], // 指定生成的 html 要 使用哪些 chunk inject: true, // 将指定的chunks（js、css）引入到 html中 minify: &#123; html5: true, // 移除空格 collapseWhitespace: true, // 当标记之间的空格包含换行符时，始终折叠为1换行符(不完全删除它)，必须与collapseWhitespace=true一起使用 preserveLineBreaks: false, minifyCSS: true, // 压缩文内css minifyJS: true, // 压缩文内js // 移除注释 removeComments: false &#125; &#125;) ], optimization: &#123; minimize: true, minimizer: [ // 添加 css 压缩配置 new OptimizeCssAssetsPlugin(&#123;&#125;), // 压缩 JS new TerserPlugin(&#123;&#125;) ] &#125;, &#125; 提取页面的公共资源基础库的分离 思路:将react、react-dom 基础包通过cdn 引入，不打入bundle 中 方法:使用html-webpack-externals-plugin entry: 可以是本地文件、cdn引入等 externalsexternals 配置选项提供了「从输出的 bundle 中排除依赖」的方法 例如，从CDN引入React，而不是把它打包 &lt;!-- anonymous：CORS请求将不设置凭据标志 --> &lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin=\"anonymous\" >&lt;/script> 配置externals const config = &#123; //... externals: &#123; react: 'React', &#125;, &#125;; 使用React import React from 'react'; CDNCDN用来托管静态资源，就近获取，加快访问速度，缓解服务器压力，还可以防止一些网络的攻击 CDN的原理是：本地DNS系统解析的时候，发现该URL对应的是一个CDN专用的DNS服务器，将解析权利交给了 专门处理CDN的DNS服务处理 使用SplitChunksPlugin进行公共脚本分离optimization.splitChunks 是基于 SplitChunksPlugin 插件实现的，webpack内置的。 splitChunks 分包配置 module.exports = &#123; //... optimization: &#123; splitChunks: &#123; // async：异步引入的库进行分离（默认）， initial： 同步引入的库进行分离， all：所有引入的库进行分离（推荐） chunks: 'async', minSize: 30000, // 抽离的公共包最小的大小，单位字节 30k 如果minSize: 0,只要有引用，就会抽离 minRemainingSize: 0, // 确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块 maxSize: 0, // 最大的大小 minChunks: 1, // 资源使用的次数(在多个页面使用到)， 大于1， 最小使用次数 maxAsyncRequests: 5, // 并发请求的资源数量 maxInitialRequests: 30, // 入口文件做代码分割最多能分成30个js文件 automaticNameDelimiter: '~', // 文件生成时的连接符 automaticNameMaxLength: 30, // 自动自动命名最大长度 name: true, // 让cacheGroups里设置的名字有效 cacheGroups: &#123; //当打包同步代码时，上面的参数生效，配置提取模块的方案 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, //检测引入的库是否在node_modlues目录下的 priority: -10, //值越大,优先级越高.模块先打包到优先级高的组里 filename: 'vendors.js'//把所有的库都打包到一个叫vendors.js的文件里 &#125;, default: &#123; minChunks: 2, // 上面有 priority: -20, // 上面有 reuseExistingChunk: true //如果一个模块已经被打包过了,那么再打包时就忽略这个上模块 &#125;, commons: &#123; test: /(react|react-dom)/, // 分离处理的名称，可将vendors这个chunk添加到html-webpack-plugin中的chunks数组里使用，chunks: ['vendors', pageName] name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125; &#125;; Tree Shaking的使用和原理分析 webpack默认支持，模式为production默认开启，必须是es module的模块规范，cjs不支持 Tree Shaking就是把模块中使用到的代码打入bundle，引入了但是没有使用，也不会被打包进入bundle。 Tree Shaking原理：Tree Shaking会对模块的代码进行静态的分析，在编译的阶段已经确定了哪些代码需要使用的，不需要的代码会被Tree Shaking进行注释标记，最终在uglify阶段删除无用的代码。 DCEdead code elimination，消除死代码，通常在编译阶段由编译器进行判断某些代码是否可达从而删除那些不可能执行的代码 代码不会被执行，不可到达 if(false)&#123; console.log(\"1\") // 这段代码永远不会执行 &#125; 代码的执行结果不会被用到 代码只会影响死变量（只写不读） 常规的死代码消除一般来说包含上面这几种类型的无用代码，会在打包阶段，一般是uglify.js分析并删除无用代码。 副作用的代码不能treeshking，如在window对象挂载属性值，但是没有使用；export封装成对象导出，没有使用的方法不能被treeshking，原因是treeshking只能做到export级别，编译期间的静态分析只能对es module的相关语法做分析，是不会真正去执行代码的。 Scope Hoisting（作用域提升）Scope Hoisting 是 webpack3 的新功能，它可以让 webpack 打包出来的代码文件更小，运行更快。原理是将多个模块放在同一个作用域下，并重命名防止命名冲突，通过这种方式可以减少函数声明和内存开销。 当前现状：webpack构建后的代码存在大量的闭包代码，导致什么问题？ 大量函数闭包包裹代码，导致包体积增大（模块越多越明显） 代码在运行时因为创建的函数作用域更多，内存开销变大。 模块转换分析 模块转化为模块初始化函数，转换后的模块会带上一层包裹 import会被转换成__webpack_require，__webpack_require的参数有moduleId，exprot也会发生转换 webpack模块机制 webpack 打包输出打是一个 IIFE（匿名闭包）； modules 是一个数组，每一项是一个模块初始化函数，modules会传入IIFE函数中； IIFE函数最核心的是使用 __webpack_require() 来加载和处理模块，返回 module.exports； __webpack_require()根据moduleId来查看installModules里是否存在，不存在会创建一个新的module存放到installModules； 通过 webpack_require(webpack_require.s &#x3D; 0)，entry入口依赖，启动程序。 Scope Hoisting原理（从rollup借鉴） 原理：将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突，消除包裹 Scope Hoisting的使用：webpack4以上，模式为production默认开启，必须是ESM，不支持cjs ModuleConcatenationPlugin() 插件参考Scope Hoisting 没有 Scope Hoisting 时用 webpack 打包下面两个文件 // main.js export default \"hello\"; // index.js import str from \"./main.js\"; console.log(str); 使用 webpack 打包后输出文件内容如下： // module指代源代码，__webpack_exports__就是export、__webpack_require__是import /* harmony import 是ES6语法的标识 */ /* harmony exports 是ES6语法的标识 */ [ (function (module, __webpack_exports__, __webpack_require__) &#123; var __WEBPACK_IMPORTED_MODULE_0__main_js__ = __webpack_require__(1); console.log(__WEBPACK_IMPORTED_MODULE_0__main_js__[\"a\"]); &#125;), (function (module, __webpack_exports__, __webpack_require__) &#123; __webpack_exports__[\"a\"] = ('hello'); &#125;) ] 再开启 Scope Hoisting 后，相同源码打包输出结果变为： [ (function (module, __webpack_exports__, __webpack_require__) &#123; var main = ('hello'); console.log(main); &#125;) ] 对比两种打包方式输出的代码，我们可以看出，启用 Scope Hoisting 后，函数声明变成一个， main.js 中定义的内容被直接注入到 main.js 对应模块中，这样做的好处： 代码体积更小，因为函数申明语句会产生大量代码，导致包体积增大（模块越多越明显）； 代码在运行时因为创建的函数作用域更少，内存开销也随之变小。 对比结果: 通过scope hoisting 可以减少函数声明代码和内存开销 scope hoisting理解为是把每个模块被webpack处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，但是有一个前提就是，当模块的引用次数大于1时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被webpack处理后，会被独立的包裹函数所包裹 Scope housting对模块的引用次数大于1次是不产生效果的，这个其实也很好理解，如果一个模块引用次数大于1次，那么这个模块的代码会被内联多次，从而增加了打包出来的js bundle的体积。 代码分割和动态import代码分割场景 抽离相同代码到一个共享模块 脚本懒加载，使得初始下载的代码更小，懒加载方式： cjs：require.ensure esm：动态import（目前还没有原生支持，需要babel转换） 静态分析（在模块的头部import xxx from ‘xxx’） 动态引入（在if…else{ import(‘xxx’)}），按需加载 动态import的js代码在打包时，会被抽离出来，用到的时候才会加载这个被抽离出来的js文件，通过webpackJsonp的一个请求加载。（典型的通过jsonp的形式往html插入script标签），动态import（懒加载）必定会分割代码，生成新的chunk。 prefetch (预获取)：浏览器空闲的时候进行资源的拉取 import( /* webpackPrefetch: true */ './src/xxx').then(() => &#123;&#125;) preload (预加载)：提前加载后面会用到的关键资源（谨慎使用） import(/* webpackPreload: true */ 'ChartingLibrary'); preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。 preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。 preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。 如何动态import 使用@babel&#x2F;plugin-syntax-dynamic-import插件，下载该插件，并在.babelrc的plugins配置插件 /* 通过js代码，让某个文件被单独打包成一个chunk import动态导入语法：能将某个文件单独打包 */ // 魔法注释当注解用了，标注打包后的文件名为test /* webpackChunkName: 'test' */ import(/* webpackChunkName: 'test' */'./test') .then((&#123; add &#125;) => &#123; // 文件加载成功~ // eslint-disable-next-line console.log(add(1, 2)); &#125;) .catch(() => &#123; // eslint-disable-next-line console.log('文件加载失败~'); &#125;); 在webpack中使用ESLint制定ESLint规范，检查JS 不重复造轮子，基于eslint:recommend配置并改进 能够帮助发现代码错误的规则，全部开启 ESLint如何执行落地 和CI&#x2F;CD系统集成 和webpack集成 本地开发阶段增加precommit钩子 安装husky，npm i husky -d 增加npm script，通过lint-staged增量检查修改的文件 &#123; \"scripts\": &#123; \"precommit\": \"lint-staged\", &#125;, \"lint-staged\": &#123; \"linters\": &#123; \"*.&#123;js, less&#125;\": [ \"eslint --fix\", \"git add\" ], &#125; &#125;, &#125; 使用eslint-webpack-plugin，构建时检查js规范 eslint-config-airbnb的使用 eslint-config-airbnb(react项目使用)、eslint-config-airbnb-base(其他项目)eslint-config-airbnb 下载 npm install eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y -d 下载 npm install babel-eslint eslint-config-airbnb -deslint官网 eslint配置文件：.eslint.*(.eslint.js&#x2F;.eslint.json&#x2F;.eslint.yml) // .eslint.js module.exports = &#123; \"parser\": \"babel-eslint\", // 使用的parser是babel-eslint，需要下载安装babel-eslint \"extends\": \"airbnb\", // 继承airbnb，需要安装 \"env\": &#123; // 识别browser和node环境的一些全局变量 \"browser\": true, \"node\": true &#125;, // 定义规则 \"rules\": &#123; \"indent\": [\"error\", 4] //indent空格， \"error\"错误级别、4是控制的空格数量 &#125; &#125;; 优化 resolve 配置aliasalias 用的创建 import 或 require 的别名，用来简化模块引用，项目中基本都需要进行配置。 优化 resolve 配置 const path = require('path') ... // 路径处理方法 function resolve(dir)&#123; return path.join(__dirname, dir); &#125; const config = &#123; ... resolve:&#123; // 配置别名 alias: &#123; '~': resolve('src'), '@': resolve('src'), 'components': resolve('src/components'), &#125; &#125; &#125;; 配置完成之后，我们在项目中就可以 // 使用 src 别名 ~ import '~/fonts/iconfont.css' // 使用 src 别名 @ import '@/fonts/iconfont.css' // 使用 components 别名 import footer from \"components/footer\"; extensions和modules 如果用户引入模块时不带扩展名，那么 webpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块，高频文件后缀名放前面。 modules，告诉 webpack 解析模块时应该搜索的目录，const config = &#123; //... resolve: &#123; extensions: ['.js', '.json', '.wasm'], // webpack 默认配置 // 手动配置后，默认配置会被覆盖，如果想保留默认配置，可以用 ... 扩展运算符代表默认配置 // extensions: ['.ts', '...'], modules: [resolve('src'), 'node_modules'] &#125;, &#125;; resolveLoader用于解析 webpack 的 loader 包，有自定义的 Loader 就需要配置一下，手写loader时可以用 const path = require('path'); const config = &#123; //... resolveLoader: &#123; modules: ['node_modules', path.join(__dirname,'loader')] &#125;, &#125;; webpack构建速度和优化体积使用webpack内置的stats分析&#123; \"srcipts\":&#123; \"build:stats\": \"webpack --env production --json > stats.json\" &#125; &#125; 速度分析：使用speed-measure-webpack-plugin 分析整个打包的总耗时 每个插件和loader的耗时情况 和一些Loader或者Plugin新版本会不兼容，需要进行降级处理，如mini-css-extract-plugin、html-webpack-plugin const SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin'); const smp = new SpeedMeasureWebpackPlugin(); module.exports = smp.wrap(&#123; ...... &#125;) 体积分析：使用webpack-bundle-analyzer可以直观的看到打包结果中，文件的体积大小、各模块依赖关系、文件是够重复等问题，极大的方便我们在进行项目优化的时候，进行问题诊断 构建完成后会在8888端口展示大小 依赖的第三方模块文件大小 业务里面的组件代码大小 const &#123; BundleAnalyzerPlugin &#125; = require('webpack-bundle-analyzer'); module.exports = &#123; plugins: [ // 配置插件 new BundleAnalyzerPlugin(&#123; // analyzerMode: 'disabled', // 不启动展示打包报告的http服务器 // generateStatsFile: true, // 是否生成stats.json文件 &#125;) ] &#125; webpack4webpack4: 优化原因 V8带来的优化(for of替代 forEach、Map和Set替代 Object、includes替代indexOf) 默认使用更快的md4 hash 算法 webpacks AST可以直接从loader传递给AST，减少解析时间 使用字符串方法替代正则表达式 多进程&#x2F;多实例构建：资源并行解析可选方案thread-loader parallel-webpack HappyPack（同样为开启多进程打包的工具，webpack5 已弃用） 多进程&#x2F;多实例：并行压缩const TerserPlugin = require('terser-webpack-plugin'); module.exports = &#123; optimization: &#123; minimizer: [ new TerserPlugin(&#123; parallel: true, cache: true &#125;) ], minimize: true, &#125;, &#125; 优化构建速度，缩小构建目标目的：尽可能的少构建模块，比如babel-loader不解析node_modules、减少文件搜索范围 &#123; test: /\\.js$/, exclude: /node_modules/, // 同时使用多个loader 用use数组，多个可以直接配置 use: [ /* 开启多线程打包。 进程启动大概为600ms，进程通信也有开销。 只有工作消耗时间比较长，才需要多线程打包 */ &#123; loader: 'thread-loader', options: &#123; workers: 2 // 进程2个 &#125; &#125;, &#123; loader: 'babel-loader', options: &#123; // 预设：指示babel做怎么样的兼容性处理 presets: [ [ '@babel/preset-env', &#123; // 按需加载 useBuiltIns: 'usage', // 指定core-js版本 corejs: &#123; version: 3 &#125;, // 指定兼容性做到哪个版本浏览器 targets: &#123; chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' &#125; &#125; ] ], // 开启babel缓存 // 第二次构建时，会读取之前的缓存, 速度会更快一点 cacheDirectory: true &#125; &#125; ], &#125; 无用的CSS如何删除 PurifyCSS:遍历代码，识别已经用到的CSS class 使用purgecss-webpack-plugin，必须和mini-css-extract-plugin搭配使用 const PurgecssPlugin = require('purgecss-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const glob = require('glob'); const PATHS = &#123; src: path.join(__dirname, 'src') &#125;; module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name]_[contenthash:8].css' &#125;), new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;PATHS.src&#125;/**/*`, &#123; nodir: true &#125;), &#125;) ] &#125; uncss: HTML需要通过jsdom加载，所有的样式通过PostCSS解析，通过document.querySelector来识别在html文件里面不存在的选择器 prefetch 与 preloadprefetchprefetch (预获取)：等其他资源加载完毕，浏览器空闲了，会在使用之前，提前加载js文件 /* 通过js代码，让某个文件被单独打包成一个chunk import动态导入语法：能将某个文件单独打包 */ /* webpackChunkName: 'test' */ // 魔法注释当注解用了,标注打包后的文件名为test // 类似路由的懒加载 import(/* webpackChunkName: 'test' */'./test') // 按需加载 必定会分割代码，生成新的chunk img.addEventListener('click', () => &#123; import( /* webpackPrefetch: true */ './desc').then((&#123; default: element &#125;) => &#123; console.log(element) document.body.appendChild(element) &#125;) &#125;) preloadpreload (预加载)：提前加载后面会用到的关键资源，因为会提前拉取资源，如果不是特殊需要，谨慎使用 import(/* webpackPreload: true */ 'ChartingLibrary'); 全局环境变量通过 webpack 内置插件 DefinePlugin 定义 DEV 环境变量。 const webpack = require(\"webpack\"); module.exports = &#123; mode: \"development\", plugins: [ new webpack.DefinePlugin(&#123; ENV: JSON.stringify(\"dev\"), // 推荐使用JSON.tringify，不仅可以处理字符串，还可以处理Object中的字符串和Array HELLO: 'hello world', &#125;), ], &#125;; 可维护的webpack构建配置构建配置抽离成npm包的意义 通用性 业务开发者无需关注构建配置 统一团队构建脚本 可维护性 构建配置合理的拆分 README文档、ChangeLog文档等 质量 冒烟测试、单元测试、测试覆盖率 持续集成 构建配置管理的可选方案 通过多个配置文件管理不同环境的构建，webpack –config 参数进行控制 将构建配置设计成一个库，比如: hjs-webpack、Neutrino、webpack-blocks 抽成一个工具进行管理，比如: create-react-app, kyt, nwb（团队规模大抽成一个cli） 将所有的配置放在一个文件，通过–env参数控制分支选择 构建配置包设计通过多个配置文件管理不同环境的webpack构建 基础配置:webpack.base.js 开发环境:webpack.dev.js 生产环境:webpack.prod.js SSR环境:webpack.ssr.js … 抽离成一个npm包统一管理 规范: git commit日志、README、ESLint规范、Semver规范 通过webpack-merge组合配置合并配置 const merge = require('webpack-merge') module.exports = merge(baseConfig, devConfig) 功能模块设计 目录结构设计-/test # 测试代码 -/lib # 源代码 - webpack.dev.js - webpack.prod.js - webpack.ssr.js - webpack.base.js index.js README.md CHANGELOG.md .eslinrc.js package.json webpack5 node版本大于10.13.0 功能清除：清理弃用功能 所有在webpack4里面被废弃的能力都被清除，因此需要确保webpack4没有打印警告。 require.includes语法已被废弃，可以通过 Rule.parser.requirelnclude 将行为改为允许、废弃或禁用。预加载一些模块，并不会马上执行 不再为Node.js模块引入polyfill，之前的版本是：如果某个模块依赖Node.js里面的核心模块，那么这个模块被引入的时候会把Node.js整个polyfill顺带引入。 长期缓存确定的模块ld、chunk和导出名称。在生产模式下，默认的chunklds:”deterministic”, modulelds:”deterministic”。设置成deterministic时默认最小3位数会被使用，不会因为某一个文件发生了变化，其他的会产生变化。 chunklds 选项值 描述 natural 按使用顺序的数字id。 named 对调试更友好的可读的id。 deterministic 在不同的编译中不变的短数字id。有益于长期缓存。在生产模式中会默认开启。 size 专注于让初始下载包大小更小的数字id。 total-size 专注于让总下载包大小更小的数字id。 modulelds 选荐值 描述 natural 按使用顺序的数字id。 named 对调试更友好的可读的id。 deterministic 被哈希转化成的小位数值模块名。 size 专注于让初始下载包大小更小的数字id。 cache持久化缓存在webpack4里面，可以使用cache-loader将编译结果写入硬盘缓存，还可以使用babel-loader，设置option.cacheDirectory将babel-loader编译的结果写进磁盘。 webpack5缓存策略 默认开启缓存，缓存默认是在内存里。可以对cache进行设置。 缓存淘汰策略︰文件缓存存储在node_modules&#x2F;.cache&#x2F;webpack，最大500MB，缓存时常两个星期，旧的缓存先淘汰 后面打包可以直接利用它原生缓存的打包的能力 module.exports= &#123; cache: &#123; // 将缓存类型设置为文件系统 type: 'filesystem', buildDependencies: &#123; // 将你的 config添加为 buildDependency，以便在改变config时获得缓存无效 config: [__filename], // 如果你有其他的东西被构建依赖，你可以在这里添加它们 // 注意 webpack、加载器和所有从你的配置中引用的模块都会被自动添加 &#125; &#125; &#125; 构建优化：TreeShaking 支持嵌套的TreeShaking 可以分析这个模块直接的一个依赖关系 代码生成：支持生成ES6代码 webpack 4之前只生成ES5的代码。webpack 5则现在既可以生成ES5又可以生成ES6&#x2F;ES2015代码。 两种设置方式:5 =&lt;ecmaVersion &lt;= 11或2009 =&lt; ecmaVersion &lt;= 2020 module.exports = &#123; output:&#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js', ecmaVersion: 6, // 输出ES6代码 &#125; &#125; 开创性的特性：模块联邦基本解释: 使一个JavaScript 应用在运行过程中可以动态加载另一个应用的代码，并支持共享依赖(CDN)。不再需要本地安装Npm包。通过CDN加载，应用A通过一个CDN，它去加载应用B，然后这两个应用分别在不同的端口。使用组件或者模块的分享更加方便了 Remote: 被依赖方，被Host消费的 Webpack构建，提供一些组件或者依赖出来，给其他的依赖方去用，相当于服务提供方。 Host: 依赖方，消费其他 Remote 的 Webpack 构建，使用其他Remote提供的模块， 一个应用可以是Host，也可以是Remote，也可以同时是Host和Remote 开创性的特性: ModuleFederationPlugin介绍Webpack内部通过ModuleFederationPlugin 插件将多个应用结合起来。 name: 必须，唯一ID，作为输出的模块名，使用的时通过 $&#123;name&#125;/$&#123;expose&#125;的方式使用; library: 必须，其中这里的name为作为umd的name; remotes: 可选，表示作为Host时，去消费哪些Remote; shared: 可选，优先用Host的依赖，如果Host没有，再用自己的; main.js: 应用主文件 remoteEntry.js: 作为remote 时被引的文件 bundle和bundlessbundle和bundless资源加载差异 bundle：浏览器加载的是构建好的文件，最开始会加载一个bundle.js； bundless: 直接加载原文件，不是加载构建好的文件； bundle和bundless打包速度对比 bundless的冷启动时间大大缩短（使用esbuild） bundless的HMR速度不受整个项目体积影响，HMR效率高 bundless的单文件粒度的缓存更优 bundless在开发阶段的体验是更优的 vite构建速度快的原因预构建使用ESBuild（冷启动快的原因），ESBuild使用golang进行打包 参考 玩转 webpack webpack知识体系 从v4升级到v5 webpack5资源模块 webpack5资源模块的使用 构建webpack5知识体系","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]},{"title":"【前端工程化】从0-1搭建react脚手架","slug":"engineering/build-cli","date":"2021-01-25T19:29:58.000Z","updated":"2022-07-09T16:04:02.310Z","comments":true,"path":"2021/01/26/engineering/build-cli/","link":"","permalink":"http://example.com/2021/01/26/engineering/build-cli/","excerpt":"","text":"前言介绍模块的使用chalkcommanderinquirerWebpack5 + React Webpack5 + React 脚手架的配置 webpack(v5.7)+React(v18.0)+react-router(v6.3)+Mobx(v6.5)+TS(v4.6)从零开始构建 参考 从0-1搭建react + ts脚手架 从0到1构建cli脚手架 React入门———react脚手架","categories":[{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"localStorage、sessionStorage和cookie的区别","slug":"front_end/browser-cache","date":"2021-01-15T10:22:49.000Z","updated":"2022-07-04T14:36:54.588Z","comments":true,"path":"2021/01/15/front_end/browser-cache/","link":"","permalink":"http://example.com/2021/01/15/front_end/browser-cache/","excerpt":"","text":"localStorage 和 sessionStorage localStorage 和 sessionStorage 是 HTML5 新增的浏览器本地缓存API，localstorage，sessionstorage在浏览器无痕模式下会存在丢失问题 只有相同域名的页面才能互相读取 localStorage 浏览器同时打开两个相同域名的tab页面，localstorage是共享的，sessionstorage是不共享的 localStorage 和 sessionStorage的存取操作都是同步的 主要用途 localStorage 项目状态管理的持久化，例如redux的持久化、mobx的持久化、vuex的持久化等 项目全局风格状态的切换（页面的默认定制配置），例如主题颜色、语言标识 token的存储 项目通用参数的存储，来记录一些不敏感的信息 sessionStorage sessionStorage 适合一次性临时数据保存 localStorage、sessionStorage和cookie的异同点 分类 生命周期 存储容量 cookie 默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效） 4KB localStorage 永久有效的，除非主动清除。 5M左右 sessionStorage 仅在当前tab页会话下有效，关闭tab页面或浏览器后会被清除。 5M左右 基本使用// 以 localStorage 为例 localStorage.setItem(key, value); // 存储 localStorage.getItem(key); // 获取 localStorage.removeItem(key); // 删除 localStorage.clear(); // 清空 localStorage 数据过期（脏数据）localstorage本身是没有过期机制的，可以通过手动实现。具体的做法是： 存入数据时，顺便存一个过期时间 maxAge 和 当前存值时间戳 time 获取数据时，通过（time + maxAge 和 Date.now()的关系）来判断当前数据是否过期，过期则删除当前数据; 否则正常返回数据 参考：如何实现localStorage的过期机制？ 没有手动封装localStorage过期的token登录例子：假如前端用localStorage永久存储token（token由过期时间、其他信息组成），发送请求时，后端拿到token检验是否过期，token过期后，后端会返回401状态码，前台统一捕获这个状态码后跳转到登录页面（过期重定向）。一般都是这么个做法，但是这个做法有一个小弊端：需要依靠请求才能感知是否已过期。 cookiecookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。 cookie的组成服务器一般是通过在http响应消息头增加Set-Cookie，将Cookie信息种在浏览器中，浏览器发送http请求时，会自动带上同源的Cookie请求头字段，传给服务器。 // 其中name=value是必选项，其它都是可选项 Set-Cookie: \"name=value;domain=.domain.com;path=/;expires=&lt;date>, 11 Jun 2019 11:29:42 GMT;HttpOnly;secure\" expires: 设置cookie的有效期，如果cookie 超过 date 所表示的日期时，cookie将失效。 如果没有设置这个选项，那么cookie将在浏览器关闭时失效。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。 Max-Age：指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。 domain&#x3D; : .taobao.com(a.taobao.com和b.taobao.com都可以访问)，但是不能设置成taobao.com，这样是不允许的携带cookies path&#x3D;: 一般是 &#x2F; (注：临时cookie，没有expires参数的cookie，不能带有domain选项)，当客户端发送一个http请求时，会将有效的cookie一起发送给服务器，如果一个cookie的domain和path参数和URL匹配，那么这个cookie就是有效的。 secure: secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。该属性只是一个开关，不需要指定值。 httponly : 表示cookie不能被客户端脚本获取到。HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是Document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。（但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全）有助于避免 XSS 攻击。（防止通过srcipt标签里面的代码获取cookie） localforage前端本地存储 可以解决 localStorage&#x2F;sessionStorage 大小限制的问题 localforage.getItem 返回的是 promise 不会因为关闭浏览器就消失，需要手动清理哦 localforage.removeItem(key), localforage.clear() localforage库 localforage前端数据存储 参考 localStorage、sessionStorage、cookie、session几种web数据存储方式对比总结 理解cookie、session、localStorage、sessionStorage的关系与区别 傻傻分不清之 Cookie、Session、Token、JWT","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"【JavaScript】写出高质量的JS代码","slug":"front_end/high-quality-code","date":"2020-12-20T11:28:51.000Z","updated":"2022-07-04T14:38:08.454Z","comments":true,"path":"2020/12/20/front_end/high-quality-code/","link":"","permalink":"http://example.com/2020/12/20/front_end/high-quality-code/","excerpt":"","text":"尽量少用全局变量，带来的第三方的 JavaScript 库、不同js文件同名变量的冲突。 尽量使用 &#x3D;&#x3D;&#x3D; ，减少&#x3D;&#x3D;的隐式转化 构造函数和组件首字母要大写，其他一般采取小驼峰命名。 使用空格分开所有的操作符和操作对象，在+，-，*，&#x3D;，&lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;，&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;，&amp;&amp;，||，+&#x3D;等前后都需要空格。 一 、注释代码//1、一个函数解决一个问题的注释 const fun = () => &#123;&#125; //2、多个函数实现某个功能 //当按钮点击时——begin const fun_01 = () => &#123;&#125; const fun_02 = () => &#123;&#125; const fun_03 = () => &#123;&#125; //当按钮点击时——end 二、你更习惯哪种写法读取属性值？推荐——解构赋值1、代码冗余、不高效、不直观代handleResizerMove = (event) => &#123; if (this.props.visible) &#123; let newmoveX = this.state.moveX + (event.clientX - this.state.x); if (this.props.defaultwidth + newmoveX &lt; this.props.minwidth) &#123; newmoveX = this.props.minwidth - this.props.defaultwidth; this.setState(&#123; left: this.props.left + newmoveX, x: event.clientX, moveX: newmoveX &#125;); this.props.onChange &amp;&amp; this.props.onChange(event, this.props.moveX, this.props.dataSource); Event.stopPropagation(event); &#125; &#125; &#125; 2、推荐写法：解构赋值读取属性值handleResizerMove = (event) => &#123; const &#123; visible, left, dataSource, onChange, defaultwidth, minwidth &#125; = this.props; const &#123; x, moveX &#125; = this.state; if (visible) &#123; //计算出移动的距离，向左移动则值小于0，右右移动则值大于0 let newmoveX = moveX + (event.clientX - x); if (defaultwidth + newmoveX &lt; minwidth) &#123; //超过最小宽度则使用最小宽度 newmoveX = minwidth - defaultWidth; &#125; this.setState(&#123; left: left + newmoveX, x: event.clientX, moveX: newmoveX &#125;); onChange &amp;&amp; onChange(event, moveX, dataSource); Event.stopPropagation(event); &#125; &#125; 三、if多条件简化写法// 不推荐这样写： let test; if (x > 10) &#123; test = true; &#125; else &#123; test = false; &#125; // 推荐做法： let test = (x > 10) ? true : false; // 或者 let test = x > 10; // 不推荐: if (x === 'a' || x === 'b' || x === 'c' || x ==='d') &#123; //do something &#125; // 推荐做法： if(['a', 'b', 'c', 'd'].includes(x)) &#123; //do something &#125; 四、方法调用简化写法// 不推荐： var test = 1; if (test === 1) &#123; helper1(); &#125; else &#123; helper2(); &#125; // 推荐做法： test === 1 ? helper1() : helper2(); // 或者 (test === 1 ? helper1 : helper2)(); // 不推荐: if (condition) &#123; callMethod(); &#125; // 推荐做法： condition &amp;&amp; callMethod(); 五、默认属性写法let test1 = 0; let test2 = 'value'; let test3 = &#123;&#125;; // 优化写法: let [test1, test2, test3] = [0, 'value', &#123;&#125;]; if (test === undefined)&#123; test = 1; &#125; // 推荐写法: test = test || 1; 六、属性排除写法排除某些对象的属性，不需要使用第三方库，可以直接使用解构赋值。 import omit from 'omit.js'; // 引入第三方库 // 场景：去掉props对象的某些属性，把剩余属性放到other对象中。 let props=&#123; 'inputIcon':'a', 'removeIcon','b', 'clearIcon':'c', 'switcherIcon':'d', 'type':1, 'status':2, info:&#123;&#125;, visible:true &#125; // 不太推荐的做法： const others= omit(props, ['inputIcon', 'removeIcon', 'clearIcon', 'switcherIcon']); // 推荐做法：利用解构赋值，把pros其他属性放到 other 中 const &#123;inputIcon, removeIcon, clearIcon, switcherIcon, ...others&#125; = props; 七、for循环&#x2F;for…in循环&#x2F;for…of循环哪个写法的效率更高——答案是：普通for循环 forEach 遍历列表值，不能使用 break 语句或使用 return 语句结束循环 for in 遍历对象键值(key)，或者数组下标，不推荐循环一个数组 for of 遍历列表值，允许遍历 Arrays，Strings，Map（哈希），Set（集合）等可迭代的数据结构，for of循环出的是value值，不能循环普通的对象（Object 没有 Symbol.iterator属性） // 测试数据 let arr = []; for(let count = 0; count &lt; 99999; count++)&#123; arr[count] = count; &#125; // 在for循环过程中，提前获取数组长度，只检索了一次长度值。 for (let i = 0, len = arr.length; i &lt; len; i++) &#123; // do something &#125; for (let key in arr) &#123; // do something &#125; for (let value in arr) &#123; // do something &#125; // for: 2.4900375016 ms // for in: 17.1098265997 ms // for of: 7.4388625005 ms 八、求数组最大最小值const arr = [1, 2, 3, 4, 5, 6]; Math.max(…arr); Math.min(…arr); 九、查找匹配const data = [ &#123; type: 'boy', name: 'Mark' &#125;, &#123; type: 'girl', name: 'Amy' &#125;, &#123; type: 'boy', name: 'Bob' &#125; ] function findData(type, name) &#123; for (let i = 0; i &lt; data.length; ++i) &#123; if (data[i].type === type &amp;&amp; data[i].name === name) &#123; return data[i]; &#125; &#125; &#125; let result = findData('boy', 'Mark'); // 优化方法 function findData(data, type, name) &#123; return data.find((item) => &#123; return item.type === type &amp;&amp; item.name === name &#125;); &#125; let result = findData(data, 'boy', 'Mark'); 十、事件代理&lt;ul> &lt;li>test01&lt;/li> &lt;li>test02&lt;/li> &lt;li>test03&lt;/li> &lt;li>test04&lt;/li> &lt;li>test05&lt;/li> &lt;/ul> document.querySelectorAll('li').forEach((e) => &#123; e.onclick = function() &#123; //do something &#125; &#125;) //(addEventLstener) 推荐做法: document.querySelector('ul').onclick = (e) => &#123; if (e.target.nodeName === 'li') &#123; //do something &#125; &#125; 十一、DOM操作写法（1）DOM写入操作写法// 非常不推荐： for (let i = 0; i &lt; 99999; i++) &#123; let test = document.getElementById('test').innerHTML; //do something &#125; //推荐写法：先获取DOM节点，再用该节点进行doSomething var test = document.getElementById('test'); for (let i = 0; i &lt; 99999; i++) &#123; let title = test.innerHTML; //do something &#125; // 非常不推荐： for (let i = 0; i &lt; 99999; i++) &#123; document.getElementById('test').innerHTML = '&lt;span>' + i + '&lt;/span>'; &#125; //推荐写法： var html = ''; for (let i = 0; i &lt; 99999; i++) &#123; html += '&lt;span>' + i + '&lt;/span>'; &#125; document.getElementById('test').innerHTML = html; //document.createDocumentFragment 十二、If Else &#x2F; Switch 写法// if-else做法： if (type === 1) &#123; return '已提交'; &#125; else if (type === 2) &#123; return '审批中'; &#125; else if (type === 3) &#123; return '审批通过'; &#125; else if (type === 0) &#123; return '审批驳回'; &#125; // switch做法： switch (type) &#123; case 1: return '已提交'; case 2: return '审批中'; case 3: return '审批通过'; case 0: return '审批驳回'; &#125; //推荐做法:将键值存在对象中，再获取 let map = &#123; 1: '已提交', 2: '审批中', 3: '审批通过', 0: '审批驳回' &#125;; let typeStr = map[type]; // if-else做法： if (type === 'add') &#123; doAdd(); &#125; else if (type === 'delete') &#123; doDelete(); &#125; else if (type === 'edit') &#123; doEdit(); &#125; else if (type === 'view') &#123; doView(); &#125; // switch做法： switch (type) &#123; case 'add': doAdd(); break; case 'delete': doDelete(); break; case 'edit': doEdit(); break; case 'view': doView(); break; &#125; //推荐做法:将键值存在对象中，再获取 var map = &#123; 'add': doAdd, 'delete': doDelete, 'edit': doEdit, 'view': doView &#125;; map[type] &amp;&amp; map[type]();","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"【JavaScript】Object对象常用方法","slug":"front_end/js-object","date":"2020-11-10T10:22:34.000Z","updated":"2022-07-07T15:03:51.447Z","comments":true,"path":"2020/11/10/front_end/js-object/","link":"","permalink":"http://example.com/2020/11/10/front_end/js-object/","excerpt":"","text":"Object.defineProperty作用：劫持或者修改对象的属性 Object.defineProperty(obj, attr, &#123; options &#125;); options参数包含如下属性： value：就是属性的值。 writable：&lt;boolean&gt;，决定属性能否被赋值。 enumerable：&lt;boolean&gt;，决定 for in 能否枚举该属性。 configurable：&lt;boolean&gt;，决定该属性能否被删除或者改变特征值(key)。 Object.hasOwnProperty检测一个对象是否含有attr的属性，不会去原型查找，不包括原型链上的属性 // 封装深拷贝时常用该方法 obj.hasOwnProperty(attr); Object.assginObject.assign只拷贝源对象的自身属性，不拷贝继承属性，也不拷贝不可枚举的属性(enumerable: false)。属性名为Symbol值的属性也会被Object.assign拷贝 Object.assgin(target, obj1, obj2, ...); Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，后面的属性就会覆盖前面的属性。 单层是深拷贝，会开辟一个新的内存空间和地址；多层是浅拷贝，会引用原来的地址。 如果只有一个参数，Object.assign会直接返回该参数。如果该参数不是对象，就会先转成对象，然后返回。 由于undefined和 null无法转成对象，因此如果它们作为参数，就会报错。如果undefined和null不在首参数，就不会报错。 object.assign(undefined) //报错 object.assign(null) //报错 object.assign(obj, undefined) //不报错 object.assign(obj, null) // 不报错 其他类型的值（数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式拷贝入目标对象外，其他值都不会产生效果。vl、v2、v3分别是字符串、布尔值和数值，结果只有字符串可以合并到目标对象中(以字符数组的形式)，数值和布尔值都会被忽略。 let vl = 'abc'; let v2 = true; let v3 = 10; const obj = object.assign (&#123;&#125;, vl, v2, v3); console.log(obj); // &#123;\"0\": \"a\"，\"l\":\"b\"，\"2\": \"c\"&#125; Object.assagin方法很多的用处 为对象添加属性 // 1 class Point&#123; constructor(x, y)&#123; Object.assign(this, x, y); &#125; &#125; // 2 Object.assign(someClass.prototype, &#123; someMethod(arg1, arg2)&#123;&#125;, anotherMethod(arg1, arg2)&#123;&#125;, attr: 'hello' &#125;) // 2的等同于 someClass.prototype.someMethod = function(arg1, arg2)&#123;&#125; someClass.prototype.anotherMethod = function(arg1, arg2)&#123;&#125; someClass.prototype.attr = 'hello'; 克隆对象 function clone(origin)&#123; return Object.assign(&#123;&#125;, origin); &#125; // 采用这种方法克隆只能克隆原始对象自身的值，不能克隆它继承的值。 // 如果想要保持继承链，可以采用下面的代码。 function clone(origin)&#123; let originProto = Object.getPrototypeof(origin); return Object.assign(0bjObjectect.create(originProto), origin); &#125; 合并多个对象，将多个对象合并到某个对象。 const merge = (target, ...sources) => 0bject.assign(target, ...sources); // 如果希望合并后返回一个新对象，可以改写上面的函数，对一个空对象合并 const merge = (...sources) => Object.assign(&#123;&#125;, ...sources); Object.keys获取对象的key值，以数组存放返回 // 使用 Object.keys(obj) // 原理 function keys(object) &#123; const result = []; for (let key in object)&#123; object.hasOwnProperty(key) &amp;&amp; result.push(key); &#125; return result; &#125; Object.values获取对象的value值，以数组存放返回（不会遍历继承的属性，并且会过滤属性名为Symbol值的属性） 如果Object.values方法的参数是一个字符串，就会返回各个字符组成的一个数组。object.values(‘foo’) &#x3D;&gt; [‘f’, ‘o’, ‘o’] 如果参数不是对象，Object.values就会先将其转为对象。由于数值和布尔值的包装对象都不会为实例添加非继承的属性，因此Object.values会返回空数组。 // 使用 Object.values(obj) Object.values(42) // [] Object.values(true) // [] Object.entries获取对象可枚举的[key, value]键值对，以数组存放返回 for(let [key, value] in Object.entries(obj))&#123; // &#125; 实现entriesfunction entries(obj)&#123; let arr = []; for(let key of Object.keys(obj))&#123; arr.push([key, obj[key]]); &#125; return arr; &#125; Object.getOwnPropertyNames获取对象所有属性的key值，包括不可枚举属性，但是不包括Symbol属性 const obj = &#123; a: 1, b: 2 &#125; Object.getOwnPropertyNames(obj) // ['a', 'b'] Object.getOwnPropertySymbols获取一个对象所有Symbol属性 Object.getOwnPropertyDescriptor获取对象的数据属性描述 const obj = &#123; a: 1 &#125;; obj.b = 2; // a和b皆为数据属性 Object.getOwnPropertyDescriptor(obj, \"a\") // &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.getOwnPropertyDescriptor(obj, \"b\") // &#123;value: 2, writable: true, enumerable: true, configurable: true&#125; Object.create根据指定的原型创建实例对象，实例完全继承原型对象，原型可以是null。 // 原型对象 const obj1 = &#123;&#125;; // 实例对象 const obj2 = Object.create(obj1); obj2.__proto__ === obj1 // true // Object.getPrototypeOf(obj2) === obj1 动手实现Object.createObject.create = function(prototype)&#123; function F()&#123;&#125;; F.prototype = prototype; F.prototype.constructor = F; return new F(); &#125; Object.getPrototypeOf获取一个对象的原型 // Object.getPrototypeOf(obj) function F() &#123;&#125;; const f = new F(); Object.getPrototypeOf(f) === F.prototype // true Object.setPrototypeOf为第一个参数对象设置原型，第二个参数是原型对象， Object.setPrototypeOf(obj, prototype); Object.isPrototypeOf判断该对象是否为参数对象的原型 function F()&#123;&#125;; const f = new F(); F.prototype.isPrototypeOf(f) // true Object.freeze冻结的对象是只读的，不能修改、不能添加新的属性。 Object.freeze(obj) 属性的可枚举性对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 let obj = &#123; foo: 123 &#125;; Object.getOwnPropertyDescriptor(obj, 'foo') // &#123; value: 123, writable: true, enumerable: true, configurable: true&#125; 会忽略enumerable为false的属性的操作 for…in循环: 只遍历对象自身的和继承的可枚举的属性。 Object.keys(): 返回对象自身的所有可枚举的属性的键名。 JSON.stringify(): 只串行化对象自身的可枚举的属性。 Object.assign()，会忽略enumerable为 false的属性，只拷贝对象自身可枚举的属性。 只有for…in 会返回继承的属性。实际上，引入enumerable的最初目的就是让某些属性可以规避掉for..in操作。比如，对象原型的toString方法以及数组的length属性就通过这种手段避免被for…in遍历到。 object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerablel // false object.getOwnPropertyDescriptor([], 'length').enumerable // false 另外，ES6规定，所有Class的原型的方法都是不可枚举的。 0bject.getOwnPropertyDescriptor(class&#123; foo()&#123;&#125; &#125;.prototype, 'foo').enumerable // false // class中声明的发法是 挂载到prototype上的 尽量不要用for…in循环，而用Object.keys()代替。 属性的遍历ES6一共有5种方法可以遍历对象的属性。 (1) for…infor…in循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)。 (2)Object.keys(obj)Object.keys返回一个数组，包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)。 (3)Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性)。 (4)Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 (5)Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性遵守同样的属性遍历的次序规则: 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 参考 MDN-Object 《Node.js12 实战》","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"前端面试八股文","slug":"interview/interview01","date":"2020-08-22T12:05:02.000Z","updated":"2022-07-09T17:38:16.516Z","comments":true,"path":"2020/08/22/interview/interview01/","link":"","permalink":"http://example.com/2020/08/22/interview/interview01/","excerpt":"","text":"前端面试复习 中高级前端大厂面试秘籍 聊聊前端面试 「2021」高频前端面试题汇总之手写代码篇 前端面试复习计划 2022年我的前端面试准备 XPoet’s Blog","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"【计算机基础】常见数据结构与算法","slug":"computer_base/algorithm","date":"2020-05-22T10:35:29.000Z","updated":"2022-08-17T15:47:15.253Z","comments":true,"path":"2020/05/22/computer_base/algorithm/","link":"","permalink":"http://example.com/2020/05/22/computer_base/algorithm/","excerpt":"","text":"常用的数据结构字符串1、最长不含重复字符的子字符串请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 题解：// 1、创建一个空数组arr，存放不重复的子字符串 // 2、遍历字符串，如果字符串的某个值在arr中存在，则删除arr中的重复字符； // 若字符串中的字符在arr中不存在，则push进去； // 3、arr数组中保存的一直是以s[i]为结尾的最大不重复的字符串。 var lengthOfLongestSubstring = function(s) &#123; var arr = [], maxLength = 0; for(let i = 0; i &lt; s.length; i++)&#123; let index = arr.indexOf(s[i]); if(index != -1)&#123; arr.splice(0, index + 1); &#125; arr.push(s[i]); maxLength = Math.max(maxLength, arr.length); &#125; return maxLength; &#125;; 2、字符串相加给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。 输入：num1 = \"11\", num2 = \"123\" 输出：\"134\" 输入：num1 = \"456\", num2 = \"77\" 输出：\"533\" 题解：// 创建指针 i 指向 nums1 末位数字，j 指向 nums2 末位数字。 // i, j 数字相加，用进位就用 carry 来记录进位值，无则为 0。 // 若产生进位，则当前数字为 (i+j) % 10 的值。 // 若遍历过程中，nums1 或 nums2 当前已无数字，则用 0 补位来计算。 var addStrings = function(num1, num2) &#123; let i = num1.length - 1, j = num2.length - 1, carry = 0, // 记录进位值 ans = []; // 保存结果 while(i >= 0 || j >= 0 || carry !== 0)&#123; // 两字符串相减，得number let c1 = i >= 0 ? num1[i] - '0' : 0, c2 = j >= 0 ? num2[j] - '0' : 0; let t = c1 + c2 + carry; carry = Math.floor(t / 10); ans.push(t % 10); i--; j--; &#125; return ans.reverse().join(''); &#125;; 3、大数相加JavaScript Number的精度丢失问题：因为 JavaScript的 Number类型是遵循IEEE 754规范表示的，这就意味着 JavaScript能精确表示的数字是有限的，JavaScript可以精确到个位的最大整数是9007199254740992，也就是2的53次方，超过这个范围就会精度丢失，造成 JavaScript无法判断大小，从而会出现下面的现象： Math.pow(2, 53); // 9007199254740992 Math.pow(2, 53) === Math.pow(2, 53) + 1000; // true 9007199254740992 === 9007199254740992 + 1000; // true 那当两个数据相加时，其中一个或者两个数据都超过了这个精度范围，直接相加结果就会不准了，解决方案是将 Number转为 String进行相加 实现代码：// 两个大数相加 var addStrings1 = function(num1, num2) &#123; let maxlength = Math.max(num1.length, num2.length); num1 = num1.padStart(maxlength, 0); num2 = num2.padStart(maxlength, 0); let t = 0, carry = 0, sum = \"\"; for(let i = maxlength - 1; i >= 0; i--)&#123; t = parseInt(num1[i]) + parseInt(num2[i]) + carry; carry = Math.floor(t / 10); sum = t % 10 + sum ; &#125; // 进位不等于零 拼到字符串前面 // if(carry !== 0)&#123; // sum = \"\" + carry + sum; // &#125; if(carry == 1)&#123; sum = \"1\"+ sum; &#125; return sum; &#125; 4、删除字符串中的所有相邻重复项给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。 输入：\"abbaca\", 输出：\"ca\" 解释：例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。 之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 题解：// 思路 // 为什么维护一个栈。因为扫描过的字符还不知道要不要删，要保留对它的记忆，入栈暂存 // 遍历字符串，如果当前字符和栈顶字符相同，则栈顶出栈（删字符），否则入栈 // 最后将栈中剩下的字符转成字符串即可。 var removeDuplicates = function (S) &#123; const stack = []; for (let i = 0; i &lt; S.length; i++) &#123; if (stack.length > 0 &amp;&amp; stack[stack.length - 1] == S[i]) &#123; stack.pop(); &#125; else &#123; stack.push(S[i]); &#125; &#125; return stack.join(''); &#125;; 5、回文数给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 输入：x = 121, 输出：true 输入：x = -121, 输出：false, 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 题解：var isPalindrome = function(x) &#123; // !(x % 10) &amp;&amp; x 是 10的整数倍, 排除零, 负数，00，1010 的倍数，都不可能是回文数。 if(x &lt; 0 || (!(x % 10) &amp;&amp; x)) return false; x = x + ''; let left = 0, right = x.length - 1; while(left &lt; right)&#123; if(x[left] != x[right])&#123; return false; &#125;else&#123; right--; left++ &#125; &#125; return true; &#125;; 6、最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 输入：s = \"babad\", 输出：\"bab\" 输入：s = \"cbbd\", 输出：\"bb\" 题解：var longestPalindrome = function(s) &#123; if( s.length &lt;= 1)&#123; return s; &#125; // 开始长度 let start = 0; // 最长回文长度 let maxLength = 1; // 找出 start和 maxlength 的方法 function seek(left, right) &#123; // 下标不越界，且 s[left] 等于s[right] while (left >= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) &#123; let newMax = right - left + 1; if ( newMax > maxLength) &#123; // 更新 start和 maxLength maxLength = newMax; start = left; &#125; // 向两边散开 left--; right++; &#125; &#125; for (let i = 0; i &lt; s.length; i++) &#123; // 情况1：BAB 以A为中心 seek(i - 1, i + 1); // 情况2：AA 以AA的中间为 中心 seek(i, i + 1); &#125; return s.slice(start, start + maxLength); &#125;; 7、Z字形变换将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下： P A H N A P L S I I G Y I R 输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。 输入：s = \"PAYPALISHIRING\", numRows = 4 输出：\"PINALSIGYAHRPI\" 解释： P I N A L S I G Y A H R P I 题解：// 1.行数是固定的 // 2.写入顺序是固定的，下上下上下上。。。。 // 3.可不可以遍历s的同时，控制上下顺序，写入对应的行，最后合并 // 4.当字符串长度没有行数多市，为一列，或者行数为1的情况，不需要计算 var convert = function(s, numRows) &#123; // s = \"PAYPALISHIRING\", numRows = 3 // 可能存在字符串长度没有行数多的情况，和一行的情况，就直接返回 if(s.length &lt;= numRows || numRows === 1)&#123; return s &#125; // 创建一个数组，个数为行数 // [\"\",\"\",\"\"], [\"PAHN\",\"APLSIIG\",\"YIR\"] // const arr = new Array(numRows).fill(''); const arr = Array.from(&#123;length: numRows&#125;, () => \"\"); // 当前字母对应的行 let num = 0; // true 表示向下+ ，false 为向上- let flag = true; for(let i = 0; i &lt; s.length; i++)&#123; // 每次项当前行里添加字符串 arr[num] = arr[num] + s[i]; if(flag)&#123; // 向下行+1 num = num + 1; &#125;else&#123; // 向上行-1 num = num - 1; &#125; // 再次到 0 说明到顶了要向下了，为true if(num === 0)&#123; flag = true; &#125; // 再次到 底部 说明要向上了，为false if(num === numRows - 1)&#123; flag = false; &#125; &#125; return arr.join(''); &#125;; var convert = function(s, numRows) &#123; if( s.length &lt;= numRows || numRows == 1)&#123; return s; &#125; let arr = new Array(numRows).fill(''); let direction = \"down\"; let index = 0; for(let i = 0; i &lt; s.length; i++)&#123; arr[index] = arr[index] + s[i] if(direction === \"down\")&#123; index = index + 1 &#125;else&#123; index = index - 1 &#125; // 再次到 底部 说明要向上了，direction = \"up\" if(index === numRows - 1)&#123; direction = \"up\" &#125; // 再次到 顶部 说明要向下了，direction = \"down\" if(index === 0)&#123; direction = \"down\" &#125; &#125; return arr.join(\"\") &#125; 8、比较版本号给你两个版本号 version1 和 version2 ，请你比较它们。 版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。 返回规则如下： 如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1，除此之外返回 0。 输入：version1 = \"1.01\", version2 = \"1.001\", 输出：0 解释：忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\" 输入：version1 = \"0.1\", version2 = \"1.1\", 输出：-1 解释：version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 &lt; 1，所以 version1 &lt; version2 题解：// 对比版本号 var compareVersion = function(version1, version2) &#123; const v1 = version1.split('.'); const v2 = version2.split('.'); for (let i = 0; i &lt; v1.length || i &lt; v2.length; i++) &#123; // let x = 0, y = 0; // if (i &lt; v1.length) &#123; // x = parseInt(v1[i]); // &#125; // if (i &lt; v2.length) &#123; // y = parseInt(v2[i]); // &#125; // if (x > y) &#123; // return 1; // &#125; // if (x &lt; y) &#123; // return -1; // &#125; let x = i &lt; v1.length ? parseInt(v1[i]) : 0; let y = i &lt; v2.length ? parseInt(v2[i]) : 0; if (x > y) &#123; return 1; &#125; if (x &lt; y) &#123; return -1; &#125; &#125; return 0; &#125;; var compareVersion = (version1, version2) => &#123; // 使用'.'将版本号分割成为数组 const [v1, v2] = [version1.split('.'), version2.split('.')]; // 取两者长度的最大值 const len = Math.max(v1.length, v2.length); for (let i = 0; i &lt; len; i++) &#123; // 数组元素逐个转换成数字，比较大小 // 数组若越界，则定义为0 const num1 = v1[i] ? parseInt(v1[i]) : 0; const num2 = v2[i] ? parseInt(v2[i]) : 0; if (num1 > num2) &#123; return 1; &#125; else if (num1 &lt; num2) &#123; return -1; &#125; &#125; // 还没有返回，说明两者相等 return 0; &#125;; 9、有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 输入: s = \"anagram\", t = \"nagaram\", 输出: true 输入: s = \"rat\", t = \"car\", 输出: false 题解：var isAnagram = function(s, t) &#123; let s1 = [...s].sort().join(''); let t1 = [...t].sort().join(''); return s.length == t.length &amp;&amp; s1 === t1 &#125;; // 哈希表存每个字符出现次数。初始字符出现次数都为0 // 遍历s和t字符串，s中遇字符，对应次数+1，t中-1 // 字母异位词，最终每个字符出现次数，即哈希表的每个键值都是0 // 特殊情况：a与ab，如果只遍历a，哈希表的每个键值也是0 // 解决方法1：遍历a与ab较长者 // 解决方法2：比较长度，长度不同，无需继续 var isAnagram = function(s, t) &#123; let len = Math.max(s.length, t.length); let h = Object.create(null); // for循环的判断条件 只要为真 就会继续循环下去， i-- 为true，就会循环下去 for(var i = len; i--; )&#123; h[s[i]] = (h[s[i]] || 0) + 1; h[t[i]] = (h[t[i]] || 0) - 1; &#125; // [0, 0, 0, 0, 0....] return Object.values(h).every(item => item === 0) // &#125;; 10、Excel表列序号给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。 A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 输入: columnTitle = \"A\", 输出: 1 输入: columnTitle = \"AB\", 输出: 28 输入: columnTitle = \"ZY\", 输出: 701 题解：var titleToNumber = function(columnTitle) &#123; let ans = 0; for (const c of columnTitle) &#123; // charCodeAt() 方法可返回指定位置的字符的 Unicode 编码 // A~Z 65~90 a~z 97~122 ans = ans * 26 + (c.charCodeAt() - 64); &#125; return ans; &#125;; var titleToNumber = function(s) &#123; const map = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']; var res = 0; var len = s.length; for(let c of s) &#123; if(len > 1) &#123; res += map.indexOf(c) * Math.pow(26, len - 1); len--; &#125; else &#123; res += map.indexOf(c); &#125; &#125; return res; &#125;; 11、判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 输入：s = \"abc\", t = \"ahbgdc\", 输出：true 输入：s = \"axc\", t = \"ahbgdc\", 输出：false 题解：// 双指针 // 两个指针分别扫描长串和短串，目标是为短串中的字符在长串中找到匹配 // 如果指向的字符相同，两个指针都移动考察下一个字符 // 如果不相同，短串的指针不动，长串的指针移动考察下一个字符 // 如果短串走完了，说明短串的字符在长串中都找到匹配 // 如果短串没有走完，长串走完了，说明考察了整个长串也没能找齐短串的所有字符 var isSubsequence = (s, t) => &#123; if (s.length == 0) &#123; return true; &#125; let tindex = 0; let sindex = 0; // 当 tindex &lt; t.length 不满足时，长串走完 while (tindex &lt; t.length) &#123; if (s[sindex] == t[tindex]) &#123; // sindex 自加1 到下一个索引 sindex++; // 如果短串走完了，说明短串的字符在长串中都找到匹配 if (sindex > s.length - 1) &#123; return true; &#125; &#125; tindex++; &#125; // 如果短串没有走完，长串走完了，说明考察了整个长串也没能找齐短串的所有字符 return false; &#125;; 12、验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 输入: \"A man, a plan, a canal: Panama\", 输出: true 解释：\"amanaplanacanalpanama\" 是回文串 题解：// 解题思路 // g :执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） // [0-9]:查找任何从 0 至 9 的数字; // [a-z]: 查找任何从小写 a 到小写 z 的字符。 // [A-Z]:查找任何从大写 A 到大写 Z 的字符。 // [A-z]:查找任何从大写 A 到小写 z 的字符。 // match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 var isPalindrome = function(s) &#123; //[ 'a', 'man', 'a', 'plan', 'a', 'canal', 'panama' ] var arr = s.toLowerCase().match(/[a-z0-9]+/g); if(!arr) &#123; return true; &#125; let slong = arr.join(\"\"); // anaplanacanalpanama let left = 0; let right = slong.length - 1; // 当 left = right 时 跳出while循环 s是回文串 while(left &lt; right)&#123; if(slong[left] == slong[right])&#123; left++; right--; &#125;else&#123; return false; &#125; &#125; return true; &#125;; 13、把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 输入: 12258, 输出: 5 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\" 题解：// a-z 97 -122 charCodeAt(); // 定义递归函数 // dfs 函数求：「当前指针位置到末尾的数字」的翻译方法数。 // 节点的状态用指针表示，dfs 入口传 0。 // 如果 指针 和 指针+1 对应的两位数在[10,25]内，则可以直译，有两种选择： // 翻译 1 个数，指针走一步，递归调用 dfs，返回出剩余数字的翻译方法数。 // 翻译 2 个数，指针走两步，递归调用 dfs，返回出剩余数字的翻译方法数。 // 二者相加，就是当前数字串的翻译方法数。 // 如果 指针 和 指针+1 对应的两位数不在[10, 25]内，则无法直译，只有一个选择： // 翻译 1 个数，指针走一步，递归调用 dfs，返回出剩余子串的翻译方法数。 var translateNum = (num) => &#123; const str = num.toString(); const dfs = (str, pointer) => &#123; // 随着dfs向下，pointer右移 if (pointer >= str.length - 1) return 1; // 指针抵达边界和超出边界都返回1 const temp = Number(str[pointer] + str[pointer + 1]); // 考察该2位数 if (temp >= 10 &amp;&amp; temp &lt;= 25) &#123; return dfs(str, pointer + 1) + dfs(str, pointer + 2); // 2个分支的结果相加 &#125; else &#123; return dfs(str, pointer + 1); // 返回1个分支的结果 &#125; &#125; return dfs(str, 0); &#125; 14、字符串解码给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 输入：s = \"3[a]2[bc]\", 输出：\"aaabcbc\" 输入：s = \"3[a2[c]]\", 输出：\"accaccacc\" 输入：s = \"2[abc]3[cd]ef\", 输出：\"abcabccdcdcdef\" 输入：s = \"abc3[cd]xyz\", 输出：\"abccdcdcdxyz\" 题解：var decodeString = function(s) &#123; let numStack = []; // 存倍数的栈 let strStack = []; // 存 待拼接的str 的栈 let num = 0; // 倍数的“搬运工” let result = ''; // 字符串的“搬运工” for (const char of s) &#123; // 逐字符扫描 if (!isNaN(char)) &#123; // 遇到数字 num = num * 10 + Number(char); // 算出倍数 &#125; else if (char == '[') &#123; // 遇到 [ strStack.push(result); // result串入栈 result = ''; // 入栈后清零 numStack.push(num); // 倍数num进入栈等待 num = 0; // 入栈后清零 &#125; else if (char == ']') &#123; // 遇到 ]，两个栈的栈顶出栈 let repeatTimes = numStack.pop(); // 获取拷贝次数 result = strStack.pop() + result.repeat(repeatTimes); // 构建子串 &#125; else &#123; result += char; // 遇到字母，追加给result串 &#125; &#125; return result; &#125;; 15、RGB转换为16进制// RGB转换为16进制 String.prototype.colorHex = function () &#123; // RGB颜色值的正则 var reg = /^(rgb|RGB)/; var color = this; if (reg.test(color)) &#123; var strHex = \"#\"; // 把RGB的3个数值变成数组 var colorArr = color.replace(/(?:\\(|\\)|rgb|RGB)*/g, \"\").split(\",\"); // 转成16进制 for (var i = 0; i &lt; colorArr.length; i++) &#123; var hex = Number(colorArr[i]).toString(16); if (hex === \"0\") &#123; hex += hex; &#125; strHex += hex; &#125; return strHex; &#125; else &#123; return String(color); &#125; &#125;; // str = \"rgb(255,255,255)\" hex的意思是16进制 function rgbToSixteen(str) &#123; let color = str; // RGB颜色值的正则 let reg = /^(rgb|RGB)/; let regNum = /[0-9]&#123;1,3&#125;/g; if (reg.test(str)) &#123; let strHex = \"#\"; // 把RGB的3个数值变成数组 let colorArr = color.match(regNum) // 转成16进制 for (var i = 0; i &lt; colorArr.length; i++) &#123; // 字符串转成16进制 // var hex = Number(colorArr[i]).toString(16); var hex = parseInt(colorArr[i]).toString(16); if (hex === \"0\") &#123; hex += hex; &#125; strHex += hex; &#125; return strHex; &#125; else &#123; return String(color); &#125; &#125; console.log(rgbToSixteen(\"rgb(255,255,255)\")) 16、16进制转换为RGBfunction sixteenToRGB(str) &#123; // 16进制颜色值的正则 var reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/; // 把颜色值变成小写 var color = str.toLowerCase(); if (reg.test(color)) &#123; // 如果只有三位的值，需变成六位，如：#fff => #ffffff // 如果只有三位的值, color的长度为4位 if (color.length === 4) &#123; var colorNew = \"#\"; for (var i = 1; i &lt; 4; i++) &#123; colorNew += color[i] + color[i]; &#125; color = colorNew; &#125; // 处理六位的颜色值，转为RGB var colorChange = []; for (var i = 1; i &lt; 7; i = i + 2) &#123; // 以16进制解析 colorChange.push(parseInt(\"0x\" + color.slice(i, i + 2))); &#125; return \"RGB(\" + colorChange.join(\",\") + \")\"; &#125; else &#123; return color; &#125; &#125; console.log(sixteenToRGB(\"#ffffff\")) String.prototype.colorRgb = function () &#123; // 16进制颜色值的正则 var reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/; // 把颜色值变成小写 var color = this.toLowerCase(); if (reg.test(color)) &#123; // 如果只有三位的值，需变成六位，如：#fff => #ffffff if (color.length === 4) &#123; var colorNew = \"#\"; for (var i = 1; i &lt; 4; i += 1) &#123; colorNew += color.slice(i, i + 1).concat(color.slice(i, i + 1)); &#125; color = colorNew; &#125; // 处理六位的颜色值，转为RGB var colorChange = []; for (var i = 1; i &lt; 7; i += 2) &#123; colorChange.push(parseInt(\"0x\" + color.slice(i, i + 2))); &#125; return \"RGB(\" + colorChange.join(\",\") + \")\"; &#125; else &#123; return color; &#125; &#125;; 数组 title: 数组date: 2021-01-15 10:22:01permalink: &#x2F;algorithm&#x2F;leetcode&#x2F;arraycategories: LeetCodetags: 数组 算法 数组数组内存中是连续的，插入和删除会让后面的元素发生挪动 查询数组元素arr[i]，O(1) insert插入数据元素arr[i]，平均O(n) delete删除数组元素arr[i]，平均O(n) 1、三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。（结果不可以包含重复的三元组） 输入：nums = [-1, 0, 1, 2, -1, -4], 输出：[[-1, -1, 2],[-1, 0, 1]] 题解：// 思路 // 外层循环：指针 i 遍历数组。 // 内层循环：用双指针，去寻找满足三数之和 == 0 的元素 // 先排序的意义 // 便于跳过重复元素，如果当前元素和前一个元素相同，跳过。 // 双指针的移动时，避免出现重复解 // 找到一个解后，左右指针同时向内收缩，为了避免指向重复的元素，需要： // 左指针在保证left &lt; right的前提下，一直右移，直到指向不重复的元素 // 右指针在保证left &lt; right的前提下，一直左移，直到指向不重复的元素 // 小优化 // 排序后，如果外层遍历的数已经大于0，则另外两个数一定大于0，sum不会等于0，直接break。 var threeSum = (nums) => &#123; nums.sort((a, b) => a - b); // 排序 升序 const res = []; for (let i = 0; i &lt; nums.length - 2; i++) &#123; // 外层遍历 let n1 = nums[i]; if (n1 > 0) break; // 如果已经爆0，不用做了，break if (i - 1 >= 0 &amp;&amp; n1 == nums[i - 1]) continue; // 遍历到重复的数，跳过 let left = i + 1; // 左指针 let right = nums.length - 1; // 右指针 while (left &lt; right) &#123; let n2 = nums[left], n3 = nums[right]; if (n1 + n2 + n3 === 0) &#123; // 三数和=0，加入解集res res.push([n1, n2, n3]); while (left &lt; right &amp;&amp; nums[left] == n2) left++; // 直到指向不一样的数 while (left &lt; right &amp;&amp; nums[right] == n3) right--; // 直到指向不一样的数 &#125; else if (n1 + n2 + n3 &lt; 0) &#123; // 三数和小于0，则左指针右移 left++; &#125; else &#123; // 三数和大于0，则右指针左移 right--; &#125; &#125; &#125; return res; &#125;; 2、合并区间以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 输入：intervals = [[1, 3],[2, 6],[8, 10],[15, 18]], 输出：[[1, 6],[8, 10],[15, 18]] 解释：区间 [1, 3] 和 [2, 6] 重叠, 将它们合并为 [1, 6]. 输入：intervals = [[1, 4],[4, 5]], 输出：[[1, 5]] 解释：区间 [1, 4] 和 [4, 5] 可被视为重叠区间。 题解：// prev 初始为第一个区间，cur 表示当前的区间，res 表示结果数组 // 开启遍历，尝试合并 prev 和 cur，合并后更新到 prev // 合并后的新区间还可能和后面的区间重合，继续尝试合并新的 cur，更新给 prev // 直到不能合并 —— prev[1] &lt; cur[0]，此时将 prev 区间推入 res 数组 // 合并的策略 // 原则上要更新prev[0]和prev[1]，即左右端: // prev[0] = min(prev[0], cur[0]) // prev[1] = max(prev[1], cur[1]) // 但如果先按区间的左端排升序，就能保证 prev[0] &lt; cur[0] // 所以合并只需这条：prev[1] = max(prev[1], cur[1]) // 易错点 // 我们是先合并，遇到不重合再推入 prev。 // 当考察完最后一个区间，后面没区间了，遇不到不重合区间，最后的 prev 没推入 res。 // 要单独补上。 var merge = function (intervals) &#123; let res = []; intervals.sort((a, b) => a[0] - b[0]); let prev = intervals[0]; // arr for (let i = 1; i &lt; intervals.length; i++) &#123; let cur = intervals[i]; if (prev[1] >= cur[0]) &#123; // 有重合 更新 prev[1] prev[1] = Math.max(cur[1], prev[1]); &#125; else &#123; // 不重合，prev推入res数组 res.push(prev); prev = cur; // 更新 prev &#125; &#125; res.push(prev); return res; &#125;; 3、旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。 // 首页将输入 // 1 2 3 // 4 5 6 // 7 8 9 // 通过交换matrix[i][j], matrix[j][i] 得到 // 1 4 7 // 2 5 8 // 3 6 9 // 最后将得到每组数组倒序排列即可 // 7 4 1 // 8 5 2 // 9 6 3 题解：var rotate = function(matrix) &#123; let martrixLength = matrix.length; for(let i = 0; i &lt; martrixLength; i++) &#123; for(let j = i; j &lt; martrixLength; j++) &#123; let temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; return matrix.map(item => item.reverse()); &#125;; 4、把数组排成最小的数输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 输入: [10,2], 输出: \"102\" 输入: [3,30,34,5,9], 输出: \"3033459\" 题解：var minNumber = function(nums) &#123; return nums.sort((a, b) => `$&#123;a&#125;$&#123;b&#125;` - `$&#123;b&#125;$&#123;a&#125;`).join(''); &#125;; var minNumber = function(nums) &#123; nums = nums.map(item => item + \"\"); // 转字符串 nums.sort((a, b) => &#123; let x = a + b; let y = b + a; return x - y; &#125;) return nums.join('') &#125;; 5、移除元素给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变，不需要考虑数组中超出新长度后面的元素。 输入：nums = [3,2,2,3], val = 3, 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 题解：var removeElement = function(nums, val) &#123; let res = 0; for(let i = 0; i &lt; nums.length; i++)&#123; if(nums[i] !== val) &#123; nums[res] = nums[i]; res++; &#125; &#125; return res; &#125;; // res 为 2 // nums 为 [2, 2, 2, 3] 系统取前两个元素 6、滑动窗口最大值给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3, 输出: [3,3,5,5,6,7] 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 题解： // 滑动窗口的最大值 暴力法 var maxSlidingWindow = function(nums, k) &#123; // 数组长度为零 if(nums.length === 0)&#123; return [] &#125; let res = []; // 存放结果 // for循环的 循环次数 let len = nums.length - k; for(let i = 0; i &lt;= len; i++)&#123; let tempArr = nums.slice(i,i + k) res.push(Math.max(...tempArr)) &#125; return res &#125;; // 暴力法 var maxSlidingWindow = function(nums, k) &#123; if (k &lt;= 1) return nums; const res = []; for (let i = 0; i &lt; nums.length - k + 1; i++) &#123; res.push(Math.max(...nums.slice(i, i + k))); &#125; return res; &#125;; 7、在排序数组中查找数字 I统计一个数字在排序数组中出现的次数。 输入: nums = [5,7,7,8,8,10], target = 8, 输出: 2 输入: nums = [5,7,7,8,8,10], target = 6, 输出: 0 题解： // 哈希 var search = function(nums, target) &#123; let map = new Map(); for(let i = 0; i &lt; nums.length; i++)&#123; if(map.has(nums[i]))&#123; map.set(nums[i], map.get(nums[i])+1) &#125;else&#123; map.set(nums[i], 1); &#125; &#125; return map.get(target) || 0; &#125;; var search = function(nums, target) &#123; let count = 0; for(let i = 0; i &lt; nums.length; i++)&#123; if(nums[i] === target)&#123; count++ &#125; &#125; return count; &#125;; 8、数组中出现次数超过一半的数字在排序数组中查找数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。统计一个数字在排序数组中出现的次数 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2], 输出: 2 题解： // 哈希 var majorityElement = function(nums) &#123; let len = nums.length /2; let obj = &#123;&#125; for(let i = 0; i &lt; nums.length; i++)&#123; // if(obj[`$&#123;nums[i]&#125;`])&#123; // obj[`$&#123;nums[i]&#125;`] = obj[`$&#123;nums[i]&#125;`] + 1 // &#125;else&#123; // obj[`$&#123;nums[i]&#125;`] = 1; // &#125; obj[`$&#123;nums[i]&#125;`] = (obj[`$&#123;nums[i]&#125;`] || 0) + 1; &#125; for(let key in obj)&#123; if(obj[key] > len)&#123; return key; &#125; &#125; &#125;; // obj[str] = (obj[str] || 0) + 1; 9、II. 0～n-1中缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 输入: [0,1,3], 输出: 2 输入: [0,1,2,3,4,5,6,7,9], 输出: 8 题解：// 0～n-1中缺失的数字 二分法 // 找一个中间元素，它左边没有缺失的话，就会满足 i==nums[i] // 如果不满足，则缺失的数在右边 var missingNumber = (nums) => &#123; let left = 0; let right = nums.length - 1; while (left &lt;= right) &#123; // let mid = left + ((right - left) >>> 1); // 向下取整后， mid = Math.floor((left + right)/2) if (mid == nums[mid]) &#123; // 缺失的元素在右边 left = mid + 1; &#125; else &#123; // 缺失的元素在左边 right = mid - 1; &#125; &#125; return left; &#125;; 10、打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字 输入: n = 1, 输出: [1,2,3,4,5,6,7,8,9] 题解：var printNumbers = function (n) &#123; let res = []; // n=1, Math.pow(10, 1) = 10 // n=2, Math.pow(10, 2) = 100 // n=3, Math.pow(10, 3) = 1000 for (let i = 1; i &lt; Math.pow(10, n); i++) &#123; res.push(i); &#125; return res; &#125;; 11、单调数列如果数组是单调递增或单调递减的，那么它是 单调 的。如果对于所有 i &lt;&#x3D; j，nums[i] &lt;&#x3D; nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i &lt;&#x3D; j，nums[i]&gt; &#x3D; nums[j]，那么数组 nums 是单调递减的。当给定的数组 nums 是单调数组时返回 true，否则返回 false。 输入：nums = [1,2,2,3], 输出：true 输入：nums = [6,5,4,4], 输出：true 输入：nums = [1,3,2], 输出：false 题解：// 一次遍历 // 初始化 inc 单调递增 和 desc 单调递减 为 true // 使用 inc 标记数组是否单调上升的，如果有下降，则将其置为 false // 使用 dec 标记数组是否单调递减的，如果有上升，则将其置为 false // 如果数列为单调 必有inc与desc 一个为true 一个为false // 如果数列不是单调数列 则inc 与 desc均为false var isMonotonic = function(A) &#123; let [inc, dec] = [true, true]; for (let i = 0; i &lt; A.length - 1; i++) &#123; if (A[i] > A[i + 1]) &#123; inc = false; &#125; if (A[i] &lt; A[i + 1]) &#123; dec = false; &#125; &#125; return inc || dec; &#125;; 12、分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 输入: g = [1,2,3], s = [1,1], 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 输入: g = [1,2], s = [1,2,3], 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 题解：// 双指针： // 解题思路 // 1，先按从小到大排序g(胃口值)和s(饼干尺寸)； // 2，遍历g,s，相同坐标下的s[i] >= g[i] 则max(满足的孩子) +1； // 3，当max已经等于s.length(饼干数量)了，则直接返回max； var findContentChildren = function (g, s) &#123; g.sort((a, b) => a - b);// g孩子的胃口 s.sort((a, b) => a - b);// s是饼干的大小 // s[i] 大于 g[i] 才能喂饱 孩子 let child = 0, // 能喂饱的孩子数 cookie = 0; // while (cookie &lt; s.length &amp;&amp; child &lt; g.length) &#123; // 发现满足条件的饼干，喂饱一个孩子 if (s[cookie] >= g[child]) &#123; child++; &#125; // 继续找下一块饼干 cookie++; &#125; return child; &#125;; 13、扑克牌中的顺子从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 输入: [1,2,3,4,5], 输出: True 输入: [0,0,1,2,5], 输出: True 题解：// 解题思路 // 分治思想 五张牌构成顺子的充分条件需要满足 // 1. 不重复 使用Set去重 // 2. max - min &lt; 5 最大牌值 减去 最小牌值 小于5 且跳过大小王 var isStraight = function(nums) &#123; /* 分治思想 五张牌构成顺子的充分条件需要满足 1. 不重复 使用Set去重 2. max - min &lt; 5 最大牌值 减去 最小牌值 小于5 且跳过大小王 */ const set = new Set(); let min = 14, max = 0 // min和max的初始值是两个边界值[0, 13] for(let i = 0; i &lt; nums.length; i++)&#123; // 遇到大小王 跳过 if (!nums[i]) continue; // 遇到重复则直接 返回false if (set.has(nums[i])) &#123; return false; &#125; set.add(nums[i]) // 迭代更新 min和max 以及set min = Math.min(min, nums[i]); max = Math.max(max, nums[i]); &#125; return max - min &lt; 5; &#125;; var isStraight = function(nums) &#123; //从小到大排序 const minSort = nums.sort((a, b) => a - b); //记录每个数字之间大差值，反正不能大于4 let sum = 0; //不能超过4 for(let i = 0; i &lt; 4; i++)&#123; //忽略0也就是王 if(minSort[i] === 0)&#123; continue &#125; //如果扑克牌（非0）重复，说明不是顺子 else if(nums[i] === nums[i + 1])&#123; return false &#125;else&#123; //差值记录 sum = sum + nums[i + 1] - nums[i] &#125; &#125; //如果超过4，说明不是顺子。 return sum &lt; 5 &#125;; 14、矩阵中的路径给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 输入： board = [ [\"A\",\"B\",\"C\",\"E\"], [\"S\",\"F\",\"C\",\"S\"], [\"A\",\"D\",\"E\",\"E\"] ], word = \"ABCCED\" 输出：true 题解： // 解题思路 // 典型的dfs算法，第一步先遍历一遍board，寻找第一个符合的位置，然后再使用dfs递归，因为寻找路径，要记录一下路径，防止每次递归会回到之前的路径 var exist = function(board, word) &#123; var row = board.length; var col = board[0].length; var dfs = function(i, j, board, word, index)&#123; // 判断不符合条件 if(i &lt; 0 || i >= row || j &lt; 0 || j > col || board[i][j] !== word[index]) &#123; return false; &#125; if(index === word.length - 1) &#123; // word遍历完了 return true; &#125; // 记录到board的值 var tmp = board[i][j]; // 锁上，因为后续的递归是4个方向上的，无法保证上一个方向的值 board[i][j] = '-' var res = dfs(i - 1, j, board, word, index + 1) || dfs(i + 1, j, board, word, index + 1) || dfs(i, j - 1, board, word, index + 1) || dfs(i, j + 1, board, word, index + 1); // 恢复现场 board[i][j] = tmp; return res; &#125; // for循环作用 ： 遍历整个board，找到初始位置点 for(var i = 0;i &lt; row; i++)&#123; for(var j = 0; j &lt; col; j++)&#123; if(dfs(i, j, board, word, 0)) &#123; return true; &#125; &#125; &#125; // 没找到 return false; &#125;; // 思路 有点类似岛屿数量 // 先从头遍历矩阵，找到第一个符合的字符，开始深度优先遍历 // 深度优先遍历： // 定义index代表索引，或者说已经匹配了多少个字符 // 要写递归的出口：i、j越界或者字符不匹配 // 匹配成功：index等于word.length - 1，匹配成功，直接返回true // 为了同一个单元格内的字母不允许被重复使用，遍历到某字符后，将当前字符设置为''，防止四个方向dfs再次遍历到 // 四个方向遍历完毕后，再恢复这个字符 // 最后若一直匹配失败，返回false // 排除法 var exist = (board, word) => &#123; const [m, n] = [board.length, board[0].length]; // index 是word的下标 const dfs = (i, j, index) => &#123; // 越界、或者字符不匹配 if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || board[i][j] !== word[index]) &#123; return false; &#125; // 索引等于 单词长度-1，说明全匹配上了 if (index === word.length - 1) &#123; return true; &#125; // 保存当前字符 const temp = board[i][j]; // 将当前字符设置为空，防止四个方向dfs再次遍历到 board[i][j] = ''; // 四个方向遍历 res是布尔值 const res = dfs(i + 1, j, index + 1) || dfs(i, j + 1, index + 1) || dfs(i - 1, j, index + 1) || dfs(i, j - 1, index + 1); // 恢复当前字符 board[i][j] = temp; return res; &#125;; // 从第一个匹配的字符处开始dfs for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (dfs(i, j, 0)) &#123; return true; &#125; &#125; &#125; return false; &#125;; 15、寻找两个正序数组的中位数输入：nums1 = [1, 3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1, 2, 3]，中位数 2 输入：nums1 = [1, 2], nums2 = [3, 4] 输出：2.50000 解释：合并数组 = [1, 2, 3, 4]，中位数(2 + 3) / 2 = 2.5 题解：function findMedian(nums1, nums2) &#123; //let num = nums1.concat(nums2); let num = [...nums1, ...nums2].sort((a, b) => a - b); //num = num.sort((a, b) => a - b); let length = num.length; if (length > 0 &amp;&amp; length % 2 === 0) &#123; return (num[length / 2 - 1] + num[length / 2]) / 2; &#125; else &#123; return num[(length - 1) / 2]; &#125; &#125;; 16、矩阵的转置给定一个矩阵 A， 返回 A 的转置矩阵。矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 输入：[[1,2,3],[4,5,6],[7,8,9]] 输出：[[1,4,7],[2,5,8],[3,6,9]] 输入：[[1,2,3],[4,5,6]] 输出：[[1,4],[2,5],[3,6]] 题解：function transpose(A) &#123; let B = []; for (let i = 0;i &lt; A.length; i++) &#123; for (let j = 0;j &lt; A[i].length; j++) &#123; if (!B[j]) &#123; B[j] = []; &#125; B[j][i] = A[i][j]; &#125; &#125; return B; &#125; 17、两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 输入：nums = [2,7,11,15], target = 9, 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 输入：nums = [3,2,4], target = 6 输出：[1,2] 题解：// 数组是有序的，则用双指针 var twoSum = function(numbers, target) &#123; let low = 0; let high = numbers.length - 1; while (low &lt; high) &#123; let sum = numbers[low] + numbers[high]; if (sum == target) &#123; return [low + 1, high + 1]; &#125; else if (sum > target) &#123; high--; &#125; else &#123; low++; &#125; &#125; return (\"No such two value!\"); &#125;; // 方法二 // 如果数组不是有序的，不能用双指针，用哈希表 var twoSum = function(arr, target) &#123; let map = new Map(); let len = arr.length; for(let i = 0, i &lt; len; i++)&#123; let num = target - arr[i]; if(map.has(num))&#123; return [map.get(num), i]; &#125;else&#123; map.set(nums[i], i); &#125; &#125; return []; &#125; 18、合并两个有序数组给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 题解：// 有序非递减 后面的元素大于等于前面的 var merge = function(nums1, m, nums2, n) &#123; let len1 = m - 1, len2 = n - 1, k = m + n - 1; while (len1 >= 0 || len2 >= 0) &#123; if(len1 &lt; 0) &#123; nums1[k--] = nums2[len2--]; &#125;else if(len2 &lt; 0) &#123; nums1[k--] = nums1[len1--]; &#125;else if(nums1[len1] &lt; nums2[len2]) &#123; // 比较nums1 和 nums2 最后面的 元素大小 nums1[k--] = nums2[len2--]; &#125;else &#123; nums1[k--] = nums1[len1--]; &#125; &#125; return nums1; &#125;; // 归并排序法 function mergeSort(left,right)&#123; let result = [] while(left.length > 0 &amp;&amp; right.length > 0)&#123; if (left[0] &lt; right[0]) &#123; result.push(left.shift()) &#125;else&#123; result.push(right.shift()) &#125; &#125; //只要left,right数组其中一个长度为0，则将另外数组剩余的元素直接添加到result数组后面 return [...result, ...left, ...right]; &#125; 19、和为s的连续正数序列输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 输入：target = 9 输出：[[2,3,4],[4,5]] 输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 题解：// 这里的题意隐藏条件 没有给定具体的数组num 我们可以通过下标关联[1,2,3,4,5,6,7....] // 没有参照物数组 但是可以根据下标 // 滑动窗口（双指针） var findContinuousSequence = function(target) &#123; if(target &lt;= 2) return; let left = 1; let right = 2; let sum = 3; let res = []; // 滑动窗口框架 // 左指针小于 右指针 while(left &lt; right)&#123; if(sum === target)&#123; let ans = []; // 通过下标关联[1,2,3,4,5,6,7....] for(let k = left; k &lt;= right; k++)&#123; ans[k - left] = k; // 下标 0,1,2 &#125; res.push(ans); // 等于的情况 我们可以继续窗口往右搜索 同时缩小左边的 sum = sum - left; left++; &#125; else if(sum > target)&#123; // 大于的条件 缩小窗口，缩小左边的 sum已经加过了 sum = sum - left; left++; &#125; else &#123; // 小于的情况 滑动窗口继续扩大，不用减，往右加数字 right++; sum = sum + right; &#125; &#125; // 连续正整数序列（至少含有两个数）。 // 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 return res; &#125;; 20、数组乱序（洗牌算法）洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，即为乱序算法。 // Fisher - Yates // 先看最经典的 Fisher - Yates的洗牌算法 // 其算法思想就是从原数组中随机抽取一个元素放入新数组 // 从原数组（假如长度为n）中，随机生成一个索引 random // 从原数组中删除第 random 个元素并将其push到新数组 // 重复第2步直到所有元素取完 // 最终得到一个新的打乱的数组 // 按步骤一步一步来就很简单的实现。 const shuffle1 = arr => &#123; let res = [], random while (arr.length > 0) &#123; random = parseInt(Math.random() * arr.length); // arr.splice(random, 1) 返回的是一个被删除的元素数组，我们删除多少个元素，数组里就有元素 let el = arr.splice(random, 1)[0]; res.push(el); &#125; return res &#125; shuffle1([2, 3, 6, 2, 6, 2]) // [6, 3, 2, 2, 2, 6] // Knuth - Durstenfeld ShuffleFisher - Yates // 洗牌算法的一个变种是 Knuth Shuffle // 每次从原数组中随机取一个元素，然后把该元素跟最后个元素交换，即数组的尾部放的是已经处理过的元素 // 这是一种原地打乱的算法，不会产生新的数组，每个元随机概率也相等，时间复杂度从 Fisher 算法的 O(n2)提升了 O(n) // 假设原数组长度为n，生成一个0～n - 1的随机random，然后将第random个元素跟数组最后一个元素交换 // 生成一个0～n - 2的随机数random，然后将第random个素跟数组倒数第二个元素交换 // 以此类推，直到交换结束为止 const shuffle2 = arr => &#123; let n = arr.length, tmp, random while (n != 0) &#123; random = parseInt(Math.random() * n) n-- // n减一，方便下一趟循环继续交换 // 交换 tmp = arr[length] arr[length] = arr[random] arr[random] = tmp &#125; return arr; &#125; shuffle2([2, 3, 6, 2, 6, 2]) // [6, 3, 2, 2, 6, 2] 21、螺旋矩阵给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 题解：var spiralOrder = function(matrix) &#123; if(matrix.length === 0)&#123; return []; &#125; // 四个边界 let left = 0; // 左边界 let top = 0; // 上边界 let right = matrix[0].length - 1; // 右边界 let bottom = matrix.length - 1; // 下边界 let direction = \"right\"; // 初始方向 let result = []; // 结果 // 执行while 的判断条件 while(left &lt;= right &amp;&amp; top &lt;= bottom)&#123; if(direction === \"right\")&#123; for(let i = left; i &lt;= right; i++)&#123; result.push(matrix[top][i]) &#125; top++; direction = \"down\"; &#125;else if(direction === \"down\")&#123; for(let i = top; i &lt;= bottom; i++)&#123; result.push(matrix[i][right]) &#125; right--; direction = \"left\"; &#125;else if(direction === \"left\")&#123; for(let i = right; i >= left; i--)&#123; result.push(matrix[bottom][i]); &#125; bottom--; direction = \"up\"; &#125;else if(direction === \"up\")&#123; for(let i = bottom; i >= top; i--)&#123; result.push(matrix[i][left]); &#125; left++; direction = \"right\"; &#125; &#125; return result &#125;; 22、螺旋矩阵II给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 题解：/ 思路和代码 // 构建 n * n 的矩阵 // 确定矩阵的四个边界，它是初始遍历的边界。 // 按 上 右 下 左，一层层向内，遍历矩阵填格子 // 每遍历一个格子，填上对应的 num，num 自增 // 直到 num > n*n ，遍历结束 var generateMatrix = function (n) &#123; const matrix = new Array(n); for (let i = 0; i &lt; n; i++) &#123; matrix[i] = new Array(n); &#125; let num = 1; let left = 0, right = n - 1, top = 0, bottom = n - 1; while (num &lt;= n * n) &#123; for (let i = left; i &lt;= right; i++) &#123; matrix[top][i] = num num++ &#125; top++; for (let i = top; i &lt;= bottom; i++) &#123; matrix[i][right] = num num++; &#125; right--; for (let i = right; i >= left; i--) &#123; matrix[bottom][i] = num num++; &#125; bottom--; for (let i = bottom; i >= top; i--) &#123; matrix[i][left] = num num++; &#125; left++; &#125; return matrix; &#125;; 队列栈哈希表哈希算法之美 堆链表链表的9个基本操作 二叉树二叉树之美 算法常见的排序算法梳理6大排序算法 我们常说的稳定的算法是指，值相等的元素保持排序前的相对顺序不变。举个例子，A2和A4的位置都是3。对于稳定排序来说，排序后的序列，a2一定还是在a4前面。但是对于非稳定排序来说，就不一定了，可能排完序之后，a4反而在a2的前面了。 冒泡排序（稳定排序） 时间复杂度最好O(n)，最坏O(n2)，平均时间复杂度O(n2) 相邻元素比较，大的往后放，每趟排完，最大元素位置已经排好 // 常规 function bubbleSort(arr) &#123; const len = arr.length; // 外层循环i控制比较的轮数 for (let i = 0; i &lt; len; i++) &#123; // 里层循环控制每一轮比较的次数j，arr[i] 只用跟其余的len - i个元素比较 for (let j = 1; j &lt; len - i; j++) &#123; // 若前一个元素\"大于\"后一个元素，则两者交换位置 if (arr[j - 1] > arr[j]) &#123; [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]; &#125; &#125; &#125; return arr; &#125; 优化后的冒泡排序遍历一圈后，如果没有将flag 置为 0，则说明已经不需要交换，完成了整个排序 function bubble(arr) &#123; // [1, 3, 2, 4] // 需要排序n-1趟 for (let i = 0; i &lt; arr.length; i++) &#123; let flag = i; for (let j = 1; j &lt; arr.length - i; j++) &#123; // 碰到前面比后面大的数，进行交换 if (arr[j - 1] > arr[j]) &#123; [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]; flag = 0; &#125; &#125; // 没有冒泡结束循环 if (flag) &#123; break; &#125; &#125; return arr; &#125; 插入排序（稳定排序） 最好O(n)，最坏O(n2)，平均时间复杂度O(n2) 从arr[1]开始，与前面元素相比，小的往前放，大的往后放（将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。） function insertSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; // 将arr[i]插入到arr[i-1]，arr[i-2]，arr[i-3]……之中 for (let j = i; j > 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]; &#125; &#125; &#125; return arr &#125; 优化后的插入排序再次遍历时 arr[target] &lt; arr[j] 不满足，并且arr[j]往前的是有序的，则说明arr[j]往前的元素不在需要比较，没有优化的排序算法是需要比较的。 function insertSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; let target = i; for (let j = i - 1; j >= 0; j--) &#123; if (arr[target] &lt; arr[j]) &#123; [arr[target], arr[j]] = [arr[j], arr[target]]; // 把j赋值给 target 再次遍历时 arr[target] &lt; arr[j] 不满足 // 执行break 跳过此时循环(主要作用) target = j; &#125; else &#123; break; &#125; &#125; &#125; return arr; &#125; // test console.log(insertSort([7, 3, 5, 9, 4, 1])) 归并排序（稳定排序） 平均复杂度O(nlog n) 一直把数组递归到单个元素成有序数组，然后合并 function mergeSort(arr) &#123; var len = arr.length; if (len &lt;= 1) &#123; return arr; &#125; // var mid = parseInt(len / 2); var mid = Math.floor(len / 2); var leftArr = arr.slice(0, mid); var rightArr = arr.slice(mid); return merge(mergeSort(leftArr), mergeSort(rightArr)) &#125; // 合并有序数组的方法 与 合并两个有序的链表类似 function merge(leftArr, rightArr) &#123; const temp = []; while (leftArr.length &amp;&amp; rightArr.length) &#123; if (leftArr[0] &lt; rightArr[0]) &#123; temp.push(leftArr.shift()); &#125; else &#123; temp.push(rightArr.shift()); &#125; &#125; while (leftArr.length) &#123; temp.push(leftArr.shift()); &#125; while (rightArr.length) &#123; temp.push(rightArr.shift()); &#125; return temp; &#125; const mergeSort = function(arr) &#123; if (arr.length &lt; 2)&#123; return arr &#125; const mid = Math.floor(arr.length / 2) const left = arr.splice(0, mid) //用 array.splice 取代 array.slice，减少一半的空间消耗。 const right = arr return mergeFn(mergeSort(left), mergeSort(right)) &#125; const mergeFn = function(left, right) &#123; const result = [] while (left.length > 0 &amp;&amp; right.length > 0) &#123; if (left[0] &lt;= right[0]) &#123; // left.shift() 从left数组前面删除元素据，返回shift()方法返回被删除的元素 result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; //只要left,right数组其中一个长度为0，则将另外数组剩余的元素直接添加到result数组后面 return [...result, ...left, ...right] &#125; 选择排序（不稳定） 平均复杂度 O(n2) 每趟找到最小元素，与前面排好序的最后一位交换 function selectionSort(arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; let minIndex = i; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; &#125; return arr; &#125; 快速排序（不稳定） 平均复杂度 O(nlog n) 选定数组中的一个数，比如第一个或者中间那个，比它小的放在左边，比它大的放在右边，递归依次进行。 function quickSort(arr) &#123; // 出现空数组或者只有一个元素的数组就直接返回 if (arr.length &lt; 2) &#123; return arr; &#125; // 数组元素大于等于2的情况 // 选取第一个数 const num = arr[0]; const left = []; const right = []; for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt;= num) &#123; left.push(cur); &#125; else &#123; right.push(cur); &#125; &#125; return [...quickSort(left), num, ...quickSort(right)]; &#125; // 快排写法二 快速排序原地排序 // 时间复杂度：平均O(nlogn)，最坏O(n2)，实际上大多数情况下小于O(nlogn) // 空间复杂度: O(logn)（递归调用消耗） // 记录一个索引l从数组最左侧开始，记录一个索引r从数组右侧开始 // 在l &lt; r的条件下，找到右侧小于target的值arr[r]，并将其赋值到arr[l] // 在l &lt; r的条件下，找到左侧大于target的值arr[l]，并将其赋值到arr[r] // 这样让l = r时，左侧的值全部小于target，右侧的值全部小于target，将target到该位置 // 不需要额外存储空间，写法思路稍复杂（有能力推荐这种写法） function quickSort(arr, start, end) &#123; if (end &lt; start) &#123; return; &#125; const target = arr[start]; let l = start; let r = end; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; arr[r] >= target) &#123; r--; &#125; arr[l] = arr[r]; while (l &lt; r &amp;&amp; arr[l] &lt; target) &#123; l++; &#125; arr[r] = arr[l]; &#125; arr[l] = target; quickSort(arr, start, l - 1); quickSort(arr, l + 1, end); return arr; &#125; console.log(`quickSort`, quickSort([7, 3, 5, 9, 4, 1], 0, 5)) /* * 快速排序算法，非递归实现 * 主要思想：利用栈实现 * 过程：快速排序的思想就是分治法，第一趟将序列分成两部分，每一部分都可以看一个小的序列，可以将小的序列最左最右指针下表入栈。 * @param &#123; number[] &#125; arr * @param &#123; number &#125; left * @param &#123; number &#125; right */ let quickSort = (arr, left, right) => &#123; let stack = []; //js中用数组模拟栈 stack.push(left); //左指针入栈 stack.push(right); //右指针入栈 while (stack.length > 0) &#123; //栈不为空时，说明还有序列没有排序好 let right = stack.pop();//后进先出，栈顶元素出栈，是为待排序列的最右下标（指针） let left = stack.pop(); //栈顶元素出栈，是为待排序列的最左下标（指针） let index = partition(arr, left, right); //划分，将待排序列进行一趟快速排序，最终有一个数获得最终位置，其下标为index if (left &lt; index - 1) &#123; //将index将待排序列分为两部分 stack.push(left); //左边那部分左指针入栈 stack.push(index - 1);//左边那部分右指针入栈 &#125; if (right > index + 1) &#123; //右边部分入栈 stack.push(index + 1); stack.push(right); &#125; &#125; return arr; //返回数组 &#125; 查找二分搜索算法回溯算法带你看回溯算法之美 剪枝递归DFS和BFSDFS和BFS算法之美 动态规划动态规划算法之美 动态规划KMP算法（模式匹配算法）KMP算法名字的由来：3位创始人的名字。KMP算法解决的是字符串匹配的问题 分治思想分治算法之美 贪心思想参考 awesome-coding-js 前端算法与数据结构总结","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"工程化","slug":"工程化","permalink":"http://example.com/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"http://example.com/tags/Koa/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}